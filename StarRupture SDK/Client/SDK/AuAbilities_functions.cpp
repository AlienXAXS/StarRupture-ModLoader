#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AuAbilities

#include "Basic.hpp"

#include "AuAbilities_classes.hpp"
#include "AuAbilities_parameters.hpp"


namespace SDK
{

// Function AuAbilities.AuAbilitiesBPF.AddInstigator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectContextHandle&Context                                                (Parm, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InEffectCauser                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilitiesBPF::AddInstigator(const struct FGameplayEffectContextHandle& Context, class AActor* InInstigator, class AActor* InEffectCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "AddInstigator");

	Params::AuAbilitiesBPF_AddInstigator Parms{};

	Parms.Context = std::move(Context);
	Parms.InInstigator = InInstigator;
	Parms.InEffectCauser = InEffectCauser;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitiesBPF.AddSpecTag
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectSpecHandle& Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilitiesBPF::AddSpecTag(const struct FGameplayEffectSpecHandle& Spec, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "AddSpecTag");

	Params::AuAbilitiesBPF_AddSpecTag Parms{};

	Parms.Spec = std::move(Spec);
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitiesBPF.AddSpecTags
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectSpecHandle& Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAuAbilitiesBPF::AddSpecTags(const struct FGameplayEffectSpecHandle& Spec, const struct FGameplayTagContainer& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "AddSpecTags");

	Params::AuAbilitiesBPF_AddSpecTags Parms{};

	Parms.Spec = std::move(Spec);
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitiesBPF.DuplicateEffectContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectContextHandle&Context                                                (Parm, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectContextHandle UAuAbilitiesBPF::DuplicateEffectContext(const struct FGameplayEffectContextHandle& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "DuplicateEffectContext");

	Params::AuAbilitiesBPF_DuplicateEffectContext Parms{};

	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.EqualEqual_NxAttribute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAuGameplayAttribute&      A                                                      (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuGameplayAttribute&      B                                                      (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAuAbilitiesBPF::EqualEqual_NxAttribute(const struct FAuGameplayAttribute& A, const struct FAuGameplayAttribute& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "EqualEqual_NxAttribute");

	Params::AuAbilitiesBPF_EqualEqual_NxAttribute Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.EqualEqual_NxToGameplayAttribute
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAuGameplayAttribute&      A                                                      (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAttribute&        B                                                      (ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAuAbilitiesBPF::EqualEqual_NxToGameplayAttribute(const struct FAuGameplayAttribute& A, const struct FGameplayAttribute& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "EqualEqual_NxToGameplayAttribute");

	Params::AuAbilitiesBPF_EqualEqual_NxToGameplayAttribute Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.GetAttributeName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayAttribute&        Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAuAbilitiesBPF::GetAttributeName(const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "GetAttributeName");

	Params::AuAbilitiesBPF_GetAttributeName Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.GetCooldownTimeRemainingAndDuration
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UGameplayAbility*                 Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  TimeRemaining                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  CooldownDuration                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilitiesBPF::GetCooldownTimeRemainingAndDuration(class UGameplayAbility* Ability, float* TimeRemaining, float* CooldownDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "GetCooldownTimeRemainingAndDuration");

	Params::AuAbilitiesBPF_GetCooldownTimeRemainingAndDuration Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TimeRemaining != nullptr)
		*TimeRemaining = Parms.TimeRemaining;

	if (CooldownDuration != nullptr)
		*CooldownDuration = Parms.CooldownDuration;
}


// Function AuAbilities.AuAbilitiesBPF.GetNxAttributeName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAuGameplayAttribute&      Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAuAbilitiesBPF::GetNxAttributeName(const struct FAuGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "GetNxAttributeName");

	Params::AuAbilitiesBPF_GetNxAttributeName Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.GetOwnerItem
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayEffectContextHandle&Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UAuItemDataBase*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAuItemDataBase* UAuAbilitiesBPF::GetOwnerItem(const struct FGameplayEffectContextHandle& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "GetOwnerItem");

	Params::AuAbilitiesBPF_GetOwnerItem Parms{};

	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.GetSpecName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayEffectSpecHandle& Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAuAbilitiesBPF::GetSpecName(const struct FGameplayEffectSpecHandle& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "GetSpecName");

	Params::AuAbilitiesBPF_GetSpecName Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.MakeSpecHandle
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      InGameplayEffect                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InEffectCauser                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEffectSpecHandle        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectSpecHandle UAuAbilitiesBPF::MakeSpecHandle(TSubclassOf<class UGameplayEffect> InGameplayEffect, class AActor* InInstigator, class AActor* InEffectCauser, float InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "MakeSpecHandle");

	Params::AuAbilitiesBPF_MakeSpecHandle Parms{};

	Parms.InGameplayEffect = InGameplayEffect;
	Parms.InInstigator = InInstigator;
	Parms.InEffectCauser = InEffectCauser;
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.RemoveEffectsFromTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FActiveGameplayEffectHandle>&Handles                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&Target                                                 (Parm, NativeAccessSpecifierPublic)

void UAuAbilitiesBPF::RemoveEffectsFromTarget(const TArray<struct FActiveGameplayEffectHandle>& Handles, const struct FGameplayAbilityTargetDataHandle& Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "RemoveEffectsFromTarget");

	Params::AuAbilitiesBPF_RemoveEffectsFromTarget Parms{};

	Parms.Handles = std::move(Handles);
	Parms.Target = std::move(Target);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitiesBPF.SetAbilityProjectile
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&To                                                     (Parm, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpecHandle& EffectSpec                                             (Parm, NativeAccessSpecifierPublic)
// float                                   InSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAbilityPMC*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAbilityPMC* UAuAbilitiesBPF::SetAbilityProjectile(const struct FGameplayAbilityTargetDataHandle& To, class AActor* Instigator, const struct FGameplayEffectSpecHandle& EffectSpec, float InSpeed, const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "SetAbilityProjectile");

	Params::AuAbilitiesBPF_SetAbilityProjectile Parms{};

	Parms.To = std::move(To);
	Parms.Instigator = Instigator;
	Parms.EffectSpec = std::move(EffectSpec);
	Parms.InSpeed = InSpeed;
	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.SetAbilityProjectileHit
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&To                                                     (Parm, NativeAccessSpecifierPublic)
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpecHandle& EffectSpec                                             (Parm, NativeAccessSpecifierPublic)
// float                                   InSpeed                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UAuAbilityPMC*                    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAbilityPMC* UAuAbilitiesBPF::SetAbilityProjectileHit(const struct FGameplayAbilityTargetDataHandle& To, class AActor* Instigator, const struct FGameplayEffectSpecHandle& EffectSpec, float InSpeed, const TArray<struct FHitResult>& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "SetAbilityProjectileHit");

	Params::AuAbilitiesBPF_SetAbilityProjectileHit Parms{};

	Parms.To = std::move(To);
	Parms.Instigator = Instigator;
	Parms.EffectSpec = std::move(EffectSpec);
	Parms.InSpeed = InSpeed;
	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilitiesBPF.SetContextInSpec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectSpecHandle& SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// const struct FGameplayEffectContextHandle&Context                                                (Parm, NativeAccessSpecifierPublic)

void UAuAbilitiesBPF::SetContextInSpec(const struct FGameplayEffectSpecHandle& SpecHandle, const struct FGameplayEffectContextHandle& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "SetContextInSpec");

	Params::AuAbilitiesBPF_SetContextInSpec Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitiesBPF.SetTargetHandleInContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectContextHandle&Context                                                (Parm, NativeAccessSpecifierPublic)
// const struct FAuTargetDataHandle&       TargetDataHandle                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilitiesBPF::SetTargetHandleInContext(const struct FGameplayEffectContextHandle& Context, const struct FAuTargetDataHandle& TargetDataHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAbilitiesBPF", "SetTargetHandleInContext");

	Params::AuAbilitiesBPF_SetTargetHandleInContext Parms{};

	Parms.Context = std::move(Context);
	Parms.TargetDataHandle = std::move(TargetDataHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityActor.NativeOnActorHit
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAuAbilityActor::NativeOnActorHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityActor", "NativeOnActorHit");

	Params::AuAbilityActor_NativeOnActorHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityActor.NativeOnActorOverlapEnd
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAuAbilityActor::NativeOnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityActor", "NativeOnActorOverlapEnd");

	Params::AuAbilityActor_NativeOnActorOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityActor.NativeOnActorOverlapStart
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAuAbilityActor::NativeOnActorOverlapStart(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityActor", "NativeOnActorOverlapStart");

	Params::AuAbilityActor_NativeOnActorOverlapStart Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityActor.OnActorHit
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAuAbilityActor::OnActorHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityActor", "OnActorHit");

	Params::AuAbilityActor_OnActorHit Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuAbilityActor.OnActorOverlapEnd
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAuAbilityActor::OnActorOverlapEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityActor", "OnActorOverlapEnd");

	Params::AuAbilityActor_OnActorOverlapEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuAbilityActor.OnActorOverlapStart
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AAuAbilityActor::OnActorOverlapStart(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityActor", "OnActorOverlapStart");

	Params::AuAbilityActor_OnActorOverlapStart Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuAbilityActor.GetMass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AAuAbilityActor::GetMass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityActor", "GetMass");

	Params::AuAbilityActor_GetMass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilityPersistentActor.NativeOnAbilitySystemCreated
// (Native, Protected)

void AAuAbilityPersistentActor::NativeOnAbilitySystemCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityPersistentActor", "NativeOnAbilitySystemCreated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityPMC_SimpleHoming.SetHomingSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InHomingSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilityPMC_SimpleHoming::SetHomingSpeed(float InHomingSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityPMC_SimpleHoming", "SetHomingSpeed");

	Params::AuAbilityPMC_SimpleHoming_SetHomingSpeed Parms{};

	Parms.InHomingSpeed = InHomingSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityPMC_SimpleHoming.SetHomingTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InTarget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilityPMC_SimpleHoming::SetHomingTarget(class USceneComponent* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityPMC_SimpleHoming", "SetHomingTarget");

	Params::AuAbilityPMC_SimpleHoming_SetHomingTarget Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityProjectile.SetLocalVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Speed                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAuAbilityProjectile::SetLocalVelocity(const struct FVector& Start, const struct FVector& End, float Speed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityProjectile", "SetLocalVelocity");

	Params::AuAbilityProjectile_SetLocalVelocity Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Speed = Speed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityProjectile.SetVelocity
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InVelocity                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAuAbilityProjectile::SetVelocity(const struct FVector& InVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityProjectile", "SetVelocity");

	Params::AuAbilityProjectile_SetVelocity Parms{};

	Parms.InVelocity = std::move(InVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitySystemComponent.ClientNotifyTargetAttributeChanged
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuReplicatedAttribute&    Attribute                                              (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayAbilitySpecHandle&AbilitySpec                                            (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetDataHandle&       TargetDataHandle                                       (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilitySystemComponent::ClientNotifyTargetAttributeChanged(class AActor* Target, const struct FAuReplicatedAttribute& Attribute, const struct FGameplayAbilitySpecHandle& AbilitySpec, const struct FAuTargetDataHandle& TargetDataHandle, float InLevel, float NewValue, float OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilitySystemComponent", "ClientNotifyTargetAttributeChanged");

	Params::AuAbilitySystemComponent_ClientNotifyTargetAttributeChanged Parms{};

	Parms.Target = Target;
	Parms.Attribute = std::move(Attribute);
	Parms.AbilitySpec = std::move(AbilitySpec);
	Parms.TargetDataHandle = std::move(TargetDataHandle);
	Parms.InLevel = InLevel;
	Parms.NewValue = NewValue;
	Parms.OldValue = OldValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitySystemComponent.ClientNotifyTargetEffectApplied
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const struct FGameplayEffectSpecForRPC& Spec                                                   (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UAuAbilitySystemComponent::ClientNotifyTargetEffectApplied(const struct FGameplayEffectSpecForRPC& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilitySystemComponent", "ClientNotifyTargetEffectApplied");

	Params::AuAbilitySystemComponent_ClientNotifyTargetEffectApplied Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitySystemComponent.DebugGetAttributeValueTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayAttribute&        Attribute                                              (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagRequirements&  SourceTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     TargetTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAuAbilitySystemComponent::DebugGetAttributeValueTag(const struct FGameplayAttribute& Attribute, const struct FGameplayTagRequirements& SourceTags, const struct FGameplayTagContainer& TargetTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilitySystemComponent", "DebugGetAttributeValueTag");

	Params::AuAbilitySystemComponent_DebugGetAttributeValueTag Parms{};

	Parms.Attribute = std::move(Attribute);
	Parms.SourceTags = std::move(SourceTags);
	Parms.TargetTags = std::move(TargetTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitySystemComponent.GameplayEffectAppliedToSelf
// (Native, Public, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          InstigatorASC                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpec&       Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FActiveGameplayEffectHandle&EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilitySystemComponent::GameplayEffectAppliedToSelf(class UAbilitySystemComponent* InstigatorASC, const struct FGameplayEffectSpec& Spec, const struct FActiveGameplayEffectHandle& EffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilitySystemComponent", "GameplayEffectAppliedToSelf");

	Params::AuAbilitySystemComponent_GameplayEffectAppliedToSelf Parms{};

	Parms.InstigatorASC = InstigatorASC;
	Parms.Spec = std::move(Spec);
	Parms.EffectHandle = std::move(EffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitySystemComponent.GameplayEffectAppliedToTarget
// (Native, Public, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          TargetASC                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpec&       Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FActiveGameplayEffectHandle&EffectHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilitySystemComponent::GameplayEffectAppliedToTarget(class UAbilitySystemComponent* TargetASC, const struct FGameplayEffectSpec& Spec, const struct FActiveGameplayEffectHandle& EffectHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilitySystemComponent", "GameplayEffectAppliedToTarget");

	Params::AuAbilitySystemComponent_GameplayEffectAppliedToTarget Parms{};

	Parms.TargetASC = TargetASC;
	Parms.Spec = std::move(Spec);
	Parms.EffectHandle = std::move(EffectHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitySystemComponent.OnRep_ReplicatedProjectiles
// (Final, Native, Public)

void UAuAbilitySystemComponent::OnRep_ReplicatedProjectiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilitySystemComponent", "OnRep_ReplicatedProjectiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilitySystemComponent.FindAllAbilitiesWithExactTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, Const)
// Parameters:
// TArray<struct FGameplayAbilitySpecHandle>*OutAbilityHandles                                      (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Tags                                                   (Parm, NativeAccessSpecifierPublic)

void UAuAbilitySystemComponent::FindAllAbilitiesWithExactTag(TArray<struct FGameplayAbilitySpecHandle>* OutAbilityHandles, const struct FGameplayTagContainer& Tags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilitySystemComponent", "FindAllAbilitiesWithExactTag");

	Params::AuAbilitySystemComponent_FindAllAbilitiesWithExactTag Parms{};

	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAbilityHandles != nullptr)
		*OutAbilityHandles = std::move(Parms.OutAbilityHandles);
}


// Function AuAbilities.AuAbilityTargetingComponent.ClientSendServerCustomTargets
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FAuTargetData&             ClientResult                                           (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetRequest&          RequestHandle                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bValid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilityTargetingComponent::ClientSendServerCustomTargets(const struct FAuTargetData& ClientResult, const struct FAuTargetRequest& RequestHandle, bool bValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "ClientSendServerCustomTargets");

	Params::AuAbilityTargetingComponent_ClientSendServerCustomTargets Parms{};

	Parms.ClientResult = std::move(ClientResult);
	Parms.RequestHandle = std::move(RequestHandle);
	Parms.bValid = bValid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.ClientSendServerTargets
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FAuTargetData&             ClientResult                                           (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetRequest&          RequestHandle                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilityTargetingComponent::ClientSendServerTargets(const struct FAuTargetData& ClientResult, const struct FAuTargetRequest& RequestHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "ClientSendServerTargets");

	Params::AuAbilityTargetingComponent_ClientSendServerTargets Parms{};

	Parms.ClientResult = std::move(ClientResult);
	Parms.RequestHandle = std::move(RequestHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.IsTargetingActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAuAbilityTargetingComponent::IsTargetingActive(const struct FAuTickTargetingHandle& TargetingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "IsTargetingActive");

	Params::AuAbilityTargetingComponent_IsTargetingActive Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilityTargetingComponent.OnRep_CustomTraceReplicatedData
// (Final, Native, Protected)

void UAuAbilityTargetingComponent::OnRep_CustomTraceReplicatedData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "OnRep_CustomTraceReplicatedData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.OnRep_NetCameraUpdate
// (Final, Native, Protected)

void UAuAbilityTargetingComponent::OnRep_NetCameraUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "OnRep_NetCameraUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.RequestActivateTrace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilityTargetingComponent::RequestActivateTrace(const struct FAuTickTargetingHandle& TargetingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "RequestActivateTrace");

	Params::AuAbilityTargetingComponent_RequestActivateTrace Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.RequestDeactivateTrace
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilityTargetingComponent::RequestDeactivateTrace(const struct FAuTickTargetingHandle& TargetingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "RequestDeactivateTrace");

	Params::AuAbilityTargetingComponent_RequestDeactivateTrace Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.ServerRequestCustomTargets
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FAuTargetData&             ClientResult                                           (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuCustomTargetHandle&     InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetRequest&          RequestHandle                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuCustomTraceDataHandle&  CustomData                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UAuAbilityTargetingComponent::ServerRequestCustomTargets(const struct FAuTargetData& ClientResult, const struct FAuCustomTargetHandle& InHandle, const struct FAuTargetRequest& RequestHandle, const struct FAuCustomTraceDataHandle& CustomData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "ServerRequestCustomTargets");

	Params::AuAbilityTargetingComponent_ServerRequestCustomTargets Parms{};

	Parms.ClientResult = std::move(ClientResult);
	Parms.InHandle = std::move(InHandle);
	Parms.RequestHandle = std::move(RequestHandle);
	Parms.CustomData = std::move(CustomData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.ServerRequestCustomTargetsBatchSend
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FAuRequestCustomTargetsRPCBatch&InBatch                                                (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAuAbilityTargetingComponent::ServerRequestCustomTargetsBatchSend(const struct FAuRequestCustomTargetsRPCBatch& InBatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "ServerRequestCustomTargetsBatchSend");

	Params::AuAbilityTargetingComponent_ServerRequestCustomTargetsBatchSend Parms{};

	Parms.InBatch = std::move(InBatch);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.ServerRequestServerTargets
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const struct FAuTargetData&             ClientResult                                           (ConstParm, Parm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetRequest&          RequestHandle                                          (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAbilityTargetingComponent::ServerRequestServerTargets(const struct FAuTargetData& ClientResult, const struct FAuTargetRequest& RequestHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "ServerRequestServerTargets");

	Params::AuAbilityTargetingComponent_ServerRequestServerTargets Parms{};

	Parms.ClientResult = std::move(ClientResult);
	Parms.RequestHandle = std::move(RequestHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.ServerUpdateCamera
// (Net, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   Locatiom                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UAuAbilityTargetingComponent::ServerUpdateCamera(const struct FVector& Locatiom, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "ServerUpdateCamera");

	Params::AuAbilityTargetingComponent_ServerUpdateCamera Parms{};

	Parms.Locatiom = std::move(Locatiom);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAbilityTargetingComponent.FilterHitResult
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuGameplayTargetDataFilterHandle&Filter                                                 (Parm, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> UAuAbilityTargetingComponent::FilterHitResult(const struct FAuGameplayTargetDataFilterHandle& Filter, const struct FAuTickTargetingHandle& TargetingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "FilterHitResult");

	Params::AuAbilityTargetingComponent_FilterHitResult Parms{};

	Parms.Filter = std::move(Filter);
	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilityTargetingComponent.FilterTargetData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuGameplayTargetDataFilterHandle&Filter                                                 (Parm, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UAuAbilityTargetingComponent::FilterTargetData(const struct FAuGameplayTargetDataFilterHandle& Filter, const struct FAuTickTargetingHandle& TargetingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "FilterTargetData");

	Params::AuAbilityTargetingComponent_FilterTargetData Parms{};

	Parms.Filter = std::move(Filter);
	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilityTargetingComponent.GetTargetData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetData              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FAuTargetData UAuAbilityTargetingComponent::GetTargetData(const struct FAuTickTargetingHandle& TargetingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "GetTargetData");

	Params::AuAbilityTargetingComponent_GetTargetData Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAbilityTargetingComponent.GetTargetDataHandles
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UAuAbilityTargetingComponent::GetTargetDataHandles(const struct FAuTickTargetingHandle& TargetingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAbilityTargetingComponent", "GetTargetDataHandles");

	Params::AuAbilityTargetingComponent_GetTargetDataHandles Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.AddItemOnSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               InSlot                                                 (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAuItemData>          InItem                                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::AddItemOnSlot(const struct FAuItemSlot& InSlot, TSubclassOf<class UAuItemData> InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "AddItemOnSlot");

	Params::AuGameplayAbility_AddItemOnSlot Parms{};

	Parms.InSlot = std::move(InSlot);
	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuGameplayAbility.ApplyAllEffectsFromItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAuTargetData&             InHitResults                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseOwnerItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UAuGameplayAbility::ApplyAllEffectsFromItem(const struct FAuTargetData& InHitResults, bool bUseOwnerItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "ApplyAllEffectsFromItem");

	Params::AuGameplayAbility_ApplyAllEffectsFromItem Parms{};

	Parms.InHitResults = std::move(InHitResults);
	Parms.bUseOwnerItem = bUseOwnerItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.ApplyEffectsFromItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EffectTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetData&             InHitResults                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseOwnerItem                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActiveGameplayEffectHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FActiveGameplayEffectHandle> UAuGameplayAbility::ApplyEffectsFromItem(const struct FGameplayTag& EffectTag, const struct FAuTargetData& InHitResults, bool bUseOwnerItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "ApplyEffectsFromItem");

	Params::AuGameplayAbility_ApplyEffectsFromItem Parms{};

	Parms.EffectTag = std::move(EffectTag);
	Parms.InHitResults = std::move(InHitResults);
	Parms.bUseOwnerItem = bUseOwnerItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.BP_OnAvatarSet
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayAbilityActorInfo& ActorInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayAbilitySpec&      Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAuGameplayAbility::BP_OnAvatarSet(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "BP_OnAvatarSet");

	Params::AuGameplayAbility_BP_OnAvatarSet Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.Spec = std::move(Spec);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuGameplayAbility.BP_OnGiveAbility
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayAbilityActorInfo& ActorInfo                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayAbilitySpec&      Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAuGameplayAbility::BP_OnGiveAbility(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "BP_OnGiveAbility");

	Params::AuGameplayAbility_BP_OnGiveAbility Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.Spec = std::move(Spec);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuGameplayAbility.BP_OnItemAssigned
// (Event, Public, BlueprintEvent)

void UAuGameplayAbility::BP_OnItemAssigned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "BP_OnItemAssigned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AuAbilities.AuGameplayAbility.BP_OnRemoveAbility
// (Event, Protected, BlueprintEvent)
// Parameters:
// const struct FGameplayAbilitySpec&      AbilitySpec                                            (Parm, NativeAccessSpecifierPublic)

void UAuGameplayAbility::BP_OnRemoveAbility(const struct FGameplayAbilitySpec& AbilitySpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "BP_OnRemoveAbility");

	Params::AuGameplayAbility_BP_OnRemoveAbility Parms{};

	Parms.AbilitySpec = std::move(AbilitySpec);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuGameplayAbility.DestroyTargetActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNetForce                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::DestroyTargetActor(class AActor* TargetActor, bool bNetForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "DestroyTargetActor");

	Params::AuGameplayAbility_DestroyTargetActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.bNetForce = bNetForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuGameplayAbility.GetAuActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAuGameplayAbilityActorInfo      ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FAuGameplayAbilityActorInfo UAuGameplayAbility::GetAuActorInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetAuActorInfo");

	Params::AuGameplayAbility_GetAuActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetGrantedEffectHandle
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UAuGameplayAbility::GetGrantedEffectHandle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetGrantedEffectHandle");

	Params::AuGameplayAbility_GetGrantedEffectHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.OnClientTraceResult
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAuTargetData&             OutHits                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        RawHits                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bServerConfirmed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::OnClientTraceResult(const struct FAuTargetData& OutHits, const TArray<struct FHitResult>& RawHits, bool bServerConfirmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "OnClientTraceResult");

	Params::AuGameplayAbility_OnClientTraceResult Parms{};

	Parms.OutHits = std::move(OutHits);
	Parms.RawHits = std::move(RawHits);
	Parms.bServerConfirmed = bServerConfirmed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuGameplayAbility.OnServerTraceResult
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAuTargetData&             OutHits                                                (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        RawHits                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bServerConfirmed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::OnServerTraceResult(const struct FAuTargetData& OutHits, const TArray<struct FHitResult>& RawHits, bool bServerConfirmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "OnServerTraceResult");

	Params::AuGameplayAbility_OnServerTraceResult Parms{};

	Parms.OutHits = std::move(OutHits);
	Parms.RawHits = std::move(RawHits);
	Parms.bServerConfirmed = bServerConfirmed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuGameplayAbility.RemoveSingleOwnedItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAuGameplayAbility::RemoveSingleOwnedItem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "RemoveSingleOwnedItem");

	Params::AuGameplayAbility_RemoveSingleOwnedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.SetAttributeValueOnItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuGameplayAttribute&      Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::SetAttributeValueOnItem(const struct FAuGameplayAttribute& Attribute, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "SetAttributeValueOnItem");

	Params::AuGameplayAbility_SetAttributeValueOnItem Parms{};

	Parms.Attribute = std::move(Attribute);
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuGameplayAbility.SetByCallerMagnitude
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              DataTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Magnitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              EffectTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::SetByCallerMagnitude(const struct FGameplayTag& DataTag, float Magnitude, const struct FGameplayTag& EffectTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "SetByCallerMagnitude");

	Params::AuGameplayAbility_SetByCallerMagnitude Parms{};

	Parms.DataTag = std::move(DataTag);
	Parms.Magnitude = Magnitude;
	Parms.EffectTag = std::move(EffectTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuGameplayAbility.SetEffectDuration
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              DataTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              EffectTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::SetEffectDuration(const struct FGameplayTag& DataTag, float Duration, const struct FGameplayTag& EffectTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "SetEffectDuration");

	Params::AuGameplayAbility_SetEffectDuration Parms{};

	Parms.DataTag = std::move(DataTag);
	Parms.Duration = Duration;
	Parms.EffectTag = std::move(EffectTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuGameplayAbility.SetEffectPeriod
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              DataTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Period                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              EffectTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::SetEffectPeriod(const struct FGameplayTag& DataTag, float Period, const struct FGameplayTag& EffectTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "SetEffectPeriod");

	Params::AuGameplayAbility_SetEffectPeriod Parms{};

	Parms.DataTag = std::move(DataTag);
	Parms.Period = Period;
	Parms.EffectTag = std::move(EffectTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuGameplayAbility.StartCustomTargetTrace
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAuCustomTraceDataHandle&  InCustomData                                           (Parm, NativeAccessSpecifierPublic)
// const struct FAuGameplayTargetDataFilterHandle&InFilter                                               (Parm, NativeAccessSpecifierPublic)
// const struct FAuCustomTargetHandle&     InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbDrawDebug                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTraceDebugParams&       InDebugParams                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    InbDrawServerDebug                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuGameplayAbility::StartCustomTargetTrace(const struct FAuCustomTraceDataHandle& InCustomData, const struct FAuGameplayTargetDataFilterHandle& InFilter, const struct FAuCustomTargetHandle& InHandle, bool InbDrawDebug, const struct FAuTraceDebugParams& InDebugParams, bool InbDrawServerDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "StartCustomTargetTrace");

	Params::AuGameplayAbility_StartCustomTargetTrace Parms{};

	Parms.InCustomData = std::move(InCustomData);
	Parms.InFilter = std::move(InFilter);
	Parms.InHandle = std::move(InHandle);
	Parms.InbDrawDebug = InbDrawDebug;
	Parms.InDebugParams = std::move(InDebugParams);
	Parms.InbDrawServerDebug = InbDrawServerDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuGameplayAbility.BP_OnCanActivateAbilityFailed
// (Event, Protected, BlueprintEvent, Const)

void UAuGameplayAbility::BP_OnCanActivateAbilityFailed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "BP_OnCanActivateAbilityFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AuAbilities.AuGameplayAbility.BP_OnCanActivateAbilitySuccess
// (Event, Protected, BlueprintEvent, Const)

void UAuGameplayAbility::BP_OnCanActivateAbilitySuccess() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "BP_OnCanActivateAbilitySuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AuAbilities.AuGameplayAbility.BP_OnCheckCostFailed
// (Event, Protected, BlueprintEvent, Const)

void UAuGameplayAbility::BP_OnCheckCostFailed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "BP_OnCheckCostFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AuAbilities.AuGameplayAbility.BP_OnCheckCostSuccess
// (Event, Protected, BlueprintEvent, Const)

void UAuGameplayAbility::BP_OnCheckCostSuccess() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "BP_OnCheckCostSuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AuAbilities.AuGameplayAbility.GetAbilityAttribute
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuGameplayAttribute&      Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InReqTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAuGameplayAbility::GetAbilityAttribute(const struct FAuGameplayAttribute& Attribute, const struct FGameplayTagContainer& InReqTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetAbilityAttribute");

	Params::AuGameplayAbility_GetAbilityAttribute Parms{};

	Parms.Attribute = std::move(Attribute);
	Parms.InReqTags = std::move(InReqTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetAbilityItemAttribute
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuGameplayAttribute&      Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAuGameplayAbility::GetAbilityItemAttribute(const struct FAuGameplayAttribute& Attribute) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetAbilityItemAttribute");

	Params::AuGameplayAbility_GetAbilityItemAttribute Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetAnimationPlayRate
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAuGameplayAbility::GetAnimationPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetAnimationPlayRate");

	Params::AuGameplayAbility_GetAnimationPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetAttributeValueFromItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuGameplayAttribute&      Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAuGameplayAbility::GetAttributeValueFromItem(const struct FAuGameplayAttribute& Attribute) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetAttributeValueFromItem");

	Params::AuGameplayAbility_GetAttributeValueFromItem Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetEffectSpecFromItem
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              EffectTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayEffectSpecHandle>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayEffectSpecHandle> UAuGameplayAbility::GetEffectSpecFromItem(const struct FGameplayTag& EffectTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetEffectSpecFromItem");

	Params::AuGameplayAbility_GetEffectSpecFromItem Parms{};

	Parms.EffectTag = std::move(EffectTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetItemsComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAuItemsComponent>    IC                                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuItemsComponent*                ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuItemsComponent* UAuGameplayAbility::GetItemsComponent(TSubclassOf<class UAuItemsComponent> IC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetItemsComponent");

	Params::AuGameplayAbility_GetItemsComponent Parms{};

	Parms.IC = IC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetItemStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuGameplayAttribute&      Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAuGameplayAbility::GetItemStat(const struct FAuGameplayAttribute& Attribute) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetItemStat");

	Params::AuGameplayAbility_GetItemStat Parms{};

	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetOwnerItemData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAuItemDataBase>      ItemClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAuItemDataBase*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAuItemDataBase* UAuGameplayAbility::GetOwnerItemData(TSubclassOf<class UAuItemDataBase> ItemClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetOwnerItemData");

	Params::AuGameplayAbility_GetOwnerItemData Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetSourceItemData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAuItemDataBase>      ItemClass                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAuItemDataBase*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAuItemDataBase* UAuGameplayAbility::GetSourceItemData(TSubclassOf<class UAuItemDataBase> ItemClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetSourceItemData");

	Params::AuGameplayAbility_GetSourceItemData Parms{};

	Parms.ItemClass = ItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetSourceItemHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAuItemId                        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuItemId UAuGameplayAbility::GetSourceItemHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetSourceItemHandle");

	Params::AuGameplayAbility_GetSourceItemHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetSourceOwnerItemHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAuItemId                        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuItemId UAuGameplayAbility::GetSourceOwnerItemHandle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetSourceOwnerItemHandle");

	Params::AuGameplayAbility_GetSourceOwnerItemHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.GetTargetingSystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAuAbilityTargetingComponent*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAbilityTargetingComponent* UAuGameplayAbility::GetTargetingSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "GetTargetingSystem");

	Params::AuGameplayAbility_GetTargetingSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuGameplayAbility.HasAuthority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAuGameplayAbility::HasAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuGameplayAbility", "HasAuthority");

	Params::AuGameplayAbility_HasAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuActorGameplayAbility.NativeSpawnedActorDestroyed
// (Native, Protected)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuActorGameplayAbility::NativeSpawnedActorDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "NativeSpawnedActorDestroyed");

	Params::AuActorGameplayAbility_NativeSpawnedActorDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuActorGameplayAbility.NativeSpawnedActorOverlapBeginEvent
// (Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAuActorGameplayAbility::NativeSpawnedActorOverlapBeginEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "NativeSpawnedActorOverlapBeginEvent");

	Params::AuActorGameplayAbility_NativeSpawnedActorOverlapBeginEvent Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuActorGameplayAbility.NativeSpawnedActorOverlapEndEvent
// (Native, Protected)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuActorGameplayAbility::NativeSpawnedActorOverlapEndEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "NativeSpawnedActorOverlapEndEvent");

	Params::AuActorGameplayAbility_NativeSpawnedActorOverlapEndEvent Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuActorGameplayAbility.NativeSpawnedActorOverlapHitEvent
// (Native, Protected, HasOutParams, HasDefaults)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAuActorGameplayAbility::NativeSpawnedActorOverlapHitEvent(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "NativeSpawnedActorOverlapHitEvent");

	Params::AuActorGameplayAbility_NativeSpawnedActorOverlapHitEvent Parms{};

	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuActorGameplayAbility.OnSpawnedActorOverlapBeginEvent
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAuActorGameplayAbility::OnSpawnedActorOverlapBeginEvent(class AActor* Owner, class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "OnSpawnedActorOverlapBeginEvent");

	Params::AuActorGameplayAbility_OnSpawnedActorOverlapBeginEvent Parms{};

	Parms.Owner = Owner;
	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuActorGameplayAbility.OnSpawnedActorOverlapEndEvent
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuActorGameplayAbility::OnSpawnedActorOverlapEndEvent(class AActor* Owner, class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "OnSpawnedActorOverlapEndEvent");

	Params::AuActorGameplayAbility_OnSpawnedActorOverlapEndEvent Parms{};

	Parms.Owner = Owner;
	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuActorGameplayAbility.OnSpawnedActorOverlapHitEvent
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAuActorGameplayAbility::OnSpawnedActorOverlapHitEvent(class AActor* Owner, class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "OnSpawnedActorOverlapHitEvent");

	Params::AuActorGameplayAbility_OnSpawnedActorOverlapHitEvent Parms{};

	Parms.Owner = Owner;
	Parms.HitComponent = HitComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AuAbilities.AuActorGameplayAbility.GetAbilityActor
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAuActorGameplayAbility::GetAbilityActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "GetAbilityActor");

	Params::AuActorGameplayAbility_GetAbilityActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuActorGameplayAbility.GetActorLocation
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAuActorGameplayAbility::GetActorLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuActorGameplayAbility", "GetActorLocation");

	Params::AuActorGameplayAbility_GetActorLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAP_PickAndPull.ActivateBasePMC
// (Final, Native, Public, BlueprintCallable)

void AAuAP_PickAndPull::ActivateBasePMC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAP_PickAndPull", "ActivateBasePMC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAP_PickAndPull.ActivatePullPMC
// (Final, Native, Public, BlueprintCallable)

void AAuAP_PickAndPull::ActivatePullPMC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAP_PickAndPull", "ActivatePullPMC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAP_PickAndPull.DeactivatePullPMC
// (Final, Native, Public, BlueprintCallable)

void AAuAP_PickAndPull::DeactivatePullPMC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAP_PickAndPull", "DeactivatePullPMC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAP_PickAndPull.SetPullSpeed
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PullSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAuAP_PickAndPull::SetPullSpeed(float PullSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAP_PickAndPull", "SetPullSpeed");

	Params::AuAP_PickAndPull_SetPullSpeed Parms{};

	Parms.PullSpeed = PullSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAP_PickAndPull.SetPullTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InTarget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAuAP_PickAndPull::SetPullTarget(class USceneComponent* InTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAP_PickAndPull", "SetPullTarget");

	Params::AuAP_PickAndPull_SetPullTarget Parms{};

	Parms.InTarget = InTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAP_PickAndPull.SetStaticMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAuAP_PickAndPull::SetStaticMesh(class UStaticMesh* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAP_PickAndPull", "SetStaticMesh");

	Params::AuAP_PickAndPull_SetStaticMesh Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAP_SimpleHoming.ActivateBasePMC
// (Final, Native, Public, BlueprintCallable)

void AAuAP_SimpleHoming::ActivateBasePMC()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAP_SimpleHoming", "ActivateBasePMC");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAP_SimpleHoming.ActivateSimpleHoming
// (Final, Native, Public, BlueprintCallable)

void AAuAP_SimpleHoming::ActivateSimpleHoming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAP_SimpleHoming", "ActivateSimpleHoming");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_ARMToAndFloat.ApplyRootMotionMoveToAndFloat
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRestrictSpeedToExpected_0                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCurveVector*                     PathOffsetCurve_0                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERootMotionFinishVelocityMode           VelocityOnFinishMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SetVelocityOnFinish                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClampVelocityOnFinish                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_ARMToAndFloat*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_ARMToAndFloat* UAuAT_ARMToAndFloat::ApplyRootMotionMoveToAndFloat(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FVector& TargetLocation_0, float Duration_0, bool bRestrictSpeedToExpected_0, class UCurveVector* PathOffsetCurve_0, ERootMotionFinishVelocityMode VelocityOnFinishMode, const struct FVector& SetVelocityOnFinish, float ClampVelocityOnFinish)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_ARMToAndFloat", "ApplyRootMotionMoveToAndFloat");

	Params::AuAT_ARMToAndFloat_ApplyRootMotionMoveToAndFloat Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.TargetLocation_0 = std::move(TargetLocation_0);
	Parms.Duration_0 = Duration_0;
	Parms.bRestrictSpeedToExpected_0 = bRestrictSpeedToExpected_0;
	Parms.PathOffsetCurve_0 = PathOffsetCurve_0;
	Parms.VelocityOnFinishMode = VelocityOnFinishMode;
	Parms.SetVelocityOnFinish = std::move(SetVelocityOnFinish);
	Parms.ClampVelocityOnFinish = ClampVelocityOnFinish;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_PlayMontageNotify.PlayMontageNotify
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     InMontageToPlay                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InStartingPosition                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InbStopWhenAbilityEnds                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAnimRootMotionTranslationScale                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStartingSection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_PlayMontageNotify*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_PlayMontageNotify* UAuAT_PlayMontageNotify::PlayMontageNotify(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* InMontageToPlay, float InPlayRate, float InStartingPosition, bool InbStopWhenAbilityEnds, float InAnimRootMotionTranslationScale, class FName InStartingSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_PlayMontageNotify", "PlayMontageNotify");

	Params::AuAT_PlayMontageNotify_PlayMontageNotify Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InMontageToPlay = InMontageToPlay;
	Parms.InPlayRate = InPlayRate;
	Parms.InStartingPosition = InStartingPosition;
	Parms.InbStopWhenAbilityEnds = InbStopWhenAbilityEnds;
	Parms.InAnimRootMotionTranslationScale = InAnimRootMotionTranslationScale;
	Parms.InStartingSection = InStartingSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_PlayMontageNotify.OnMontageBlendingOut
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAT_PlayMontageNotify::OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_PlayMontageNotify", "OnMontageBlendingOut");

	Params::AuAT_PlayMontageNotify_OnMontageBlendingOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_PlayMontageNotify.OnMontageEnded
// (Final, Native, Protected)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAT_PlayMontageNotify::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_PlayMontageNotify", "OnMontageEnded");

	Params::AuAT_PlayMontageNotify_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_PlayMontageNotify.OnMontageInterrupted
// (Final, Native, Protected)

void UAuAT_PlayMontageNotify::OnMontageInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_PlayMontageNotify", "OnMontageInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_PlayMontageNotify.OnNotifyBeginReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAuAT_PlayMontageNotify::OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_PlayMontageNotify", "OnNotifyBeginReceived");

	Params::AuAT_PlayMontageNotify_OnNotifyBeginReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_PlayMontageNotify.OnNotifyEndReceived
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UAuAT_PlayMontageNotify::OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_PlayMontageNotify", "OnNotifyEndReceived");

	Params::AuAT_PlayMontageNotify_OnNotifyEndReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_RepeatUntilInputRelease.WaitRepeatUntilInputRelease
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InTimeBetweenTicks                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTestAlreadyReleased                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_RepeatUntilInputRelease*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_RepeatUntilInputRelease* UAuAT_RepeatUntilInputRelease::WaitRepeatUntilInputRelease(class UGameplayAbility* OwningAbility, float InTimeBetweenTicks, bool bTestAlreadyReleased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_RepeatUntilInputRelease", "WaitRepeatUntilInputRelease");

	Params::AuAT_RepeatUntilInputRelease_WaitRepeatUntilInputRelease Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InTimeBetweenTicks = InTimeBetweenTicks;
	Parms.bTestAlreadyReleased = bTestAlreadyReleased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_RepeatUntilInputRelease.OnReleaseCallback
// (Final, Native, Public)

void UAuAT_RepeatUntilInputRelease::OnReleaseCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_RepeatUntilInputRelease", "OnReleaseCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_RepeatUntilInputRelease.OnTickCallback
// (Final, Native, Public)

void UAuAT_RepeatUntilInputRelease::OnTickCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_RepeatUntilInputRelease", "OnTickCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitCharacterJump.WaitCharacterJump
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_WaitCharacterJump*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitCharacterJump* UAuAT_WaitCharacterJump::WaitCharacterJump(class UGameplayAbility* OwningAbility, class FName TaskInstanceName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitCharacterJump", "WaitCharacterJump");

	Params::AuAT_WaitCharacterJump_WaitCharacterJump Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitCharacterJump.Landed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAuAT_WaitCharacterJump::Landed(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitCharacterJump", "Landed");

	Params::AuAT_WaitCharacterJump_Landed Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitCharacterJump.OnApex
// (Final, Native, Protected)

void UAuAT_WaitCharacterJump::OnApex()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitCharacterJump", "OnApex");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitClientDelay.WaitClientDelay
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_WaitClientDelay*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitClientDelay* UAuAT_WaitClientDelay::WaitClientDelay(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitClientDelay", "WaitClientDelay");

	Params::AuAT_WaitClientDelay_WaitClientDelay Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitClientDelay.OnDelayFinished
// (Final, Native, Protected)

void UAuAT_WaitClientDelay::OnDelayFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitClientDelay", "OnDelayFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitClientDelay.OnSignalCallback
// (Final, Native, Protected)

void UAuAT_WaitClientDelay::OnSignalCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitClientDelay", "OnSignalCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitConfirmCustomSplinePoints.WaitSplinePointsUntilRelease
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPointMinRadius                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AAuTargetingVisualizationActor>InVisualizationActorClass                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuCustomTraceDataHandle&  InCustomData                                           (Parm, NativeAccessSpecifierPublic)
// const struct FAuGameplayTargetDataFilterHandle&InFilter                                               (Parm, NativeAccessSpecifierPublic)
// const struct FAuCustomTargetHandle&     InTargetingType                                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    InVisActorTargeting                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTraceDebugParams&       InDebugParams                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UAuAT_WaitConfirmCustomSplinePoints*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitConfirmCustomSplinePoints* UAuAT_WaitConfirmCustomSplinePoints::WaitSplinePointsUntilRelease(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, float InPointMinRadius, TSubclassOf<class AAuTargetingVisualizationActor> InVisualizationActorClass, const struct FAuCustomTraceDataHandle& InCustomData, const struct FAuGameplayTargetDataFilterHandle& InFilter, const struct FAuCustomTargetHandle& InTargetingType, const struct FAuTickTargetingHandle& InVisActorTargeting, const struct FAuTraceDebugParams& InDebugParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitConfirmCustomSplinePoints", "WaitSplinePointsUntilRelease");

	Params::AuAT_WaitConfirmCustomSplinePoints_WaitSplinePointsUntilRelease Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InPointMinRadius = InPointMinRadius;
	Parms.InVisualizationActorClass = InVisualizationActorClass;
	Parms.InCustomData = std::move(InCustomData);
	Parms.InFilter = std::move(InFilter);
	Parms.InTargetingType = std::move(InTargetingType);
	Parms.InVisActorTargeting = std::move(InVisActorTargeting);
	Parms.InDebugParams = std::move(InDebugParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitConfirmCustomSplinePoints.OnReleaseCallback
// (Final, Native, Private)

void UAuAT_WaitConfirmCustomSplinePoints::OnReleaseCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitConfirmCustomSplinePoints", "OnReleaseCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitConfirmWithVistualization.WaitConfirmWithVistualization
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AAuTargetingVisualizationActor>InVisualizationActorClass                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuCustomTraceDataHandle&  InCustomData                                           (Parm, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    InVisActorTargeting                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_WaitConfirmWithVistualization*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitConfirmWithVistualization* UAuAT_WaitConfirmWithVistualization::WaitConfirmWithVistualization(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, TSubclassOf<class AAuTargetingVisualizationActor> InVisualizationActorClass, const struct FAuCustomTraceDataHandle& InCustomData, const struct FAuTickTargetingHandle& InVisActorTargeting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitConfirmWithVistualization", "WaitConfirmWithVistualization");

	Params::AuAT_WaitConfirmWithVistualization_WaitConfirmWithVistualization Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InVisualizationActorClass = InVisualizationActorClass;
	Parms.InCustomData = std::move(InCustomData);
	Parms.InVisActorTargeting = std::move(InVisActorTargeting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitConfirmWithVistualization.OnLocalConfirmCallback
// (Final, Native, Private)

void UAuAT_WaitConfirmWithVistualization::OnLocalConfirmCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitConfirmWithVistualization", "OnLocalConfirmCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitGameplayEffectExecute.OnExecuteGameplayEffectCallback
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpec&       SpecApplied                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FActiveGameplayEffectHandle&ActiveHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAT_WaitGameplayEffectExecute::OnExecuteGameplayEffectCallback(class UAbilitySystemComponent* Target, const struct FGameplayEffectSpec& SpecApplied, const struct FActiveGameplayEffectHandle& ActiveHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitGameplayEffectExecute", "OnExecuteGameplayEffectCallback");

	Params::AuAT_WaitGameplayEffectExecute_OnExecuteGameplayEffectCallback Parms{};

	Parms.Target = Target;
	Parms.SpecApplied = std::move(SpecApplied);
	Parms.ActiveHandle = std::move(ActiveHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitGetPriodicTargetData.WaitGetPriodicTargetData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuCustomTargetHandle&     InCorrectiveTraceHandle                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuGameplayTargetDataFilterHandle&InFilter                                               (Parm, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_WaitGetPriodicTargetData*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitGetPriodicTargetData* UAuAT_WaitGetPriodicTargetData::WaitGetPriodicTargetData(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FAuCustomTargetHandle& InCorrectiveTraceHandle, const struct FAuGameplayTargetDataFilterHandle& InFilter, const struct FAuTickTargetingHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitGetPriodicTargetData", "WaitGetPriodicTargetData");

	Params::AuAT_WaitGetPriodicTargetData_WaitGetPriodicTargetData Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InCorrectiveTraceHandle = std::move(InCorrectiveTraceHandle);
	Parms.InFilter = std::move(InFilter);
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitGetPriodicTargetData.OnServerTargetConfirmed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FAuTargetData&             HitResults                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerConfirmed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAT_WaitGetPriodicTargetData::OnServerTargetConfirmed(const struct FAuTargetData& HitResults, bool bServerConfirmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitGetPriodicTargetData", "OnServerTargetConfirmed");

	Params::AuAT_WaitGetPriodicTargetData_OnServerTargetConfirmed Parms{};

	Parms.HitResults = std::move(HitResults);
	Parms.bServerConfirmed = bServerConfirmed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitGetPriodicTargetData.OnTargetConfirmed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FAuTargetData&             HitResults                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bServerConfirmed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAT_WaitGetPriodicTargetData::OnTargetConfirmed(const struct FAuTargetData& HitResults, bool bServerConfirmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitGetPriodicTargetData", "OnTargetConfirmed");

	Params::AuAT_WaitGetPriodicTargetData_OnTargetConfirmed Parms{};

	Parms.HitResults = std::move(HitResults);
	Parms.bServerConfirmed = bServerConfirmed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitGetTickHitResults.WaitGetTickHitResults
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuGameplayTargetDataFilterHandle&InFilterHandle                                         (Parm, NativeAccessSpecifierPublic)
// class UAuAT_WaitGetTickHitResults*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitGetTickHitResults* UAuAT_WaitGetTickHitResults::WaitGetTickHitResults(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FAuTickTargetingHandle& InHandle, const struct FAuGameplayTargetDataFilterHandle& InFilterHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitGetTickHitResults", "WaitGetTickHitResults");

	Params::AuAT_WaitGetTickHitResults_WaitGetTickHitResults Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InHandle = std::move(InHandle);
	Parms.InFilterHandle = std::move(InFilterHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitRepeat.WaitWaitRepeat
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPeriodTime                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMaxRepeats                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_WaitRepeat*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitRepeat* UAuAT_WaitRepeat::WaitWaitRepeat(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, float InPeriodTime, int32 InMaxRepeats)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitRepeat", "WaitWaitRepeat");

	Params::AuAT_WaitRepeat_WaitWaitRepeat Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InPeriodTime = InPeriodTime;
	Parms.InMaxRepeats = InMaxRepeats;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitRepeat.OnDelayFinished
// (Final, Native, Protected)

void UAuAT_WaitRepeat::OnDelayFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitRepeat", "OnDelayFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitSpawnAbilityActor.WaitSpawnAbilityActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InAbilityEffect                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class AAuAbilityActor>      Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_WaitSpawnAbilityActor*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitSpawnAbilityActor* UAuAT_WaitSpawnAbilityActor::WaitSpawnAbilityActor(class UGameplayAbility* OwningAbility, TSubclassOf<class UGameplayEffect> InAbilityEffect, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AAuAbilityActor> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitSpawnAbilityActor", "WaitSpawnAbilityActor");

	Params::AuAT_WaitSpawnAbilityActor_WaitSpawnAbilityActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InAbilityEffect = InAbilityEffect;
	Parms.TargetData = std::move(TargetData);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitSpawnAbilityActor.BeginSpawningActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InAbilityEffect                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class AAuAbilityActor>      Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAuAbilityActor**                 SpawnedActor                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAuAT_WaitSpawnAbilityActor::BeginSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class UGameplayEffect> InAbilityEffect, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class AAuAbilityActor> Class_0, class AAuAbilityActor** SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitSpawnAbilityActor", "BeginSpawningActor");

	Params::AuAT_WaitSpawnAbilityActor_BeginSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InAbilityEffect = InAbilityEffect;
	Parms.TargetData = std::move(TargetData);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = Parms.SpawnedActor;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitSpawnAbilityActor.FinishSpawningActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InAbilityEffect                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// class AAuAbilityActor*                  SpawnedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAT_WaitSpawnAbilityActor::FinishSpawningActor(class UGameplayAbility* OwningAbility, TSubclassOf<class UGameplayEffect> InAbilityEffect, const struct FGameplayAbilityTargetDataHandle& TargetData, class AAuAbilityActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitSpawnAbilityActor", "FinishSpawningActor");

	Params::AuAT_WaitSpawnAbilityActor_FinishSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.InAbilityEffect = InAbilityEffect;
	Parms.TargetData = std::move(TargetData);
	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitSpawnAuProjectile.SpawnAuProjectile
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             TaskName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InStartVelocity                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InSpawnTransform                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InAbilityEffect                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AAuAbilityProjectile> Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_WaitSpawnAuProjectile*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitSpawnAuProjectile* UAuAT_WaitSpawnAuProjectile::SpawnAuProjectile(class FName TaskName, class UGameplayAbility* OwningAbility, const struct FVector& InStartVelocity, const struct FTransform& InSpawnTransform, TSubclassOf<class UGameplayEffect> InAbilityEffect, TSubclassOf<class AAuAbilityProjectile> Class_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitSpawnAuProjectile", "SpawnAuProjectile");

	Params::AuAT_WaitSpawnAuProjectile_SpawnAuProjectile Parms{};

	Parms.TaskName = TaskName;
	Parms.OwningAbility = OwningAbility;
	Parms.InStartVelocity = std::move(InStartVelocity);
	Parms.InSpawnTransform = std::move(InSpawnTransform);
	Parms.InAbilityEffect = InAbilityEffect;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitSpawnAuProjectile.BeginSpawningActor
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InAbilityEffect                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AAuAbilityProjectile> Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAuAbilityProjectile**            SpawnedActor                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAuAT_WaitSpawnAuProjectile::BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class UGameplayEffect> InAbilityEffect, TSubclassOf<class AAuAbilityProjectile> Class_0, class AAuAbilityProjectile** SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitSpawnAuProjectile", "BeginSpawningActor");

	Params::AuAT_WaitSpawnAuProjectile_BeginSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.InAbilityEffect = InAbilityEffect;
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = Parms.SpawnedActor;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitSpawnAuProjectile.FinishSpawningActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilityTargetDataHandle&TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      InAbilityEffect                                        (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAuAbilityProjectile*             SpawnedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAT_WaitSpawnAuProjectile::FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class UGameplayEffect> InAbilityEffect, class AAuAbilityProjectile* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitSpawnAuProjectile", "FinishSpawningActor");

	Params::AuAT_WaitSpawnAuProjectile_FinishSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.InAbilityEffect = InAbilityEffect;
	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitSpawnAuProjectile.OnProjectileReplicated
// (Final, Native, Protected)
// Parameters:
// const TArray<class AAuAbilityProjectile*>&Projectiles                                            (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAuAT_WaitSpawnAuProjectile::OnProjectileReplicated(const TArray<class AAuAbilityProjectile*>& Projectiles)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitSpawnAuProjectile", "OnProjectileReplicated");

	Params::AuAT_WaitSpawnAuProjectile_OnProjectileReplicated Parms{};

	Parms.Projectiles = std::move(Projectiles);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuAT_WaitTargetDataChanged.WaitTargetDataChanged
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuAT_WaitTargetDataChanged*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAuAT_WaitTargetDataChanged* UAuAT_WaitTargetDataChanged::WaitTargetDataChanged(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FAuTickTargetingHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuAT_WaitTargetDataChanged", "WaitTargetDataChanged");

	Params::AuAT_WaitTargetDataChanged_WaitTargetDataChanged Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuAT_WaitTargetDataChanged.OnTargetDataChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FAuTargetData&             NewResults                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuAT_WaitTargetDataChanged::OnTargetDataChanged(const struct FAuTargetData& NewResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuAT_WaitTargetDataChanged", "OnTargetDataChanged");

	Params::AuAT_WaitTargetDataChanged_OnTargetDataChanged Parms{};

	Parms.NewResults = std::move(NewResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuTargetingBPF.GetActorFromTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAuTargetingBPF::GetActorFromTargetData(const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "GetActorFromTargetData");

	Params::AuTargetingBPF_GetActorFromTargetData Parms{};

	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.GetHitsFromTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAuTargetData&             InTargetData                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> UAuTargetingBPF::GetHitsFromTargetData(const struct FAuTargetData& InTargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "GetHitsFromTargetData");

	Params::AuTargetingBPF_GetHitsFromTargetData Parms{};

	Parms.InTargetData = std::move(InTargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.GetRangeTraceData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FAuCustomTraceDataHandle&  InHandle                                               (Parm, NativeAccessSpecifierPublic)
// struct FAuRangeTraceData                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuRangeTraceData UAuTargetingBPF::GetRangeTraceData(const struct FAuCustomTraceDataHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "GetRangeTraceData");

	Params::AuTargetingBPF_GetRangeTraceData Parms{};

	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.GetTargetData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           From                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetDataHandle&       Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAbilitySpecHandle&Ability                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAuTargetData                    ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuTargetData UAuTargetingBPF::GetTargetData(class AActor* From, const struct FAuTargetDataHandle& Handle, const struct FGameplayAbilitySpecHandle& Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "GetTargetData");

	Params::AuTargetingBPF_GetTargetData Parms{};

	Parms.From = From;
	Parms.Handle = std::move(Handle);
	Parms.Ability = std::move(Ability);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.GetTargetDataFromContext
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           From                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectContextHandle&Context                                                (Parm, NativeAccessSpecifierPublic)
// struct FAuTargetData                    ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuTargetData UAuTargetingBPF::GetTargetDataFromContext(class AActor* From, const struct FGameplayEffectContextHandle& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "GetTargetDataFromContext");

	Params::AuTargetingBPF_GetTargetDataFromContext Parms{};

	Parms.From = From;
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.GetTargetDataHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAuTargetData&             InTargetData                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAuTargetDataHandle              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuTargetDataHandle UAuTargetingBPF::GetTargetDataHandle(const struct FAuTargetData& InTargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "GetTargetDataHandle");

	Params::AuTargetingBPF_GetTargetDataHandle Parms{};

	Parms.InTargetData = std::move(InTargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.MakeFilterClosestToCrosshair
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAuGameplayTargetDataFilterHandleReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuGameplayTargetDataFilterHandle UAuTargetingBPF::MakeFilterClosestToCrosshair()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "MakeFilterClosestToCrosshair");

	Params::AuTargetingBPF_MakeFilterClosestToCrosshair Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.MakeHitResultArray
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 SourceAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetData&             TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UAuTargetingBPF::MakeHitResultArray(class UGameplayAbility* SourceAbility, const struct FAuTargetData& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "MakeHitResultArray");

	Params::AuTargetingBPF_MakeHitResultArray Parms{};

	Parms.SourceAbility = SourceAbility;
	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.MakeRangeTraceData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCameraTraceCutoff                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAuCustomTraceDataHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuCustomTraceDataHandle UAuTargetingBPF::MakeRangeTraceData(float InRange, float InCameraTraceCutoff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "MakeRangeTraceData");

	Params::AuTargetingBPF_MakeRangeTraceData Parms{};

	Parms.InRange = InRange;
	Parms.InCameraTraceCutoff = InCameraTraceCutoff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingBPF.SetRangeRandomSeedTraceData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FAuCustomTraceDataHandle&  InHandle                                               (Parm, NativeAccessSpecifierPublic)
// int32                                   InSeed                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuTargetingBPF::SetRangeRandomSeedTraceData(const struct FAuCustomTraceDataHandle& InHandle, int32 InSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "SetRangeRandomSeedTraceData");

	Params::AuTargetingBPF_SetRangeRandomSeedTraceData Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InSeed = InSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuTargetingBPF.SetRangeTraceData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FAuCustomTraceDataHandle&  InHandle                                               (Parm, NativeAccessSpecifierPublic)
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuTargetingBPF::SetRangeTraceData(const struct FAuCustomTraceDataHandle& InHandle, float InRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AuTargetingBPF", "SetRangeTraceData");

	Params::AuTargetingBPF_SetRangeTraceData Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.InRange = InRange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuTargetingInterface.RequestActivateTrace
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAuTargetingInterface::RequestActivateTrace(const struct FAuTickTargetingHandle& TargetingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AuTargetingInterface", "RequestActivateTrace");

	Params::AuTargetingInterface_RequestActivateTrace Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuTargetingInterface.RequestDeactivateTrace
// (Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAuTargetingInterface::RequestDeactivateTrace(const struct FAuTickTargetingHandle& TargetingType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AuTargetingInterface", "RequestDeactivateTrace");

	Params::AuTargetingInterface_RequestDeactivateTrace Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AuAbilities.AuTargetingInterface.FilterHitResult
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuGameplayTargetDataFilterHandle&Filter                                                 (Parm, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> IAuTargetingInterface::FilterHitResult(const struct FAuGameplayTargetDataFilterHandle& Filter, const struct FAuTickTargetingHandle& TargetingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AuTargetingInterface", "FilterHitResult");

	Params::AuTargetingInterface_FilterHitResult Parms{};

	Parms.Filter = std::move(Filter);
	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingInterface.FilterTargetData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuGameplayTargetDataFilterHandle&Filter                                                 (Parm, NativeAccessSpecifierPublic)
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle IAuTargetingInterface::FilterTargetData(const struct FAuGameplayTargetDataFilterHandle& Filter, const struct FAuTickTargetingHandle& TargetingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AuTargetingInterface", "FilterTargetData");

	Params::AuTargetingInterface_FilterTargetData Parms{};

	Parms.Filter = std::move(Filter);
	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingInterface.GetTargetData
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetData              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FAuTargetData IAuTargetingInterface::GetTargetData(const struct FAuTickTargetingHandle& TargetingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AuTargetingInterface", "GetTargetData");

	Params::AuTargetingInterface_GetTargetData Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AuAbilities.AuTargetingInterface.GetTargetDataHandles
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FAuTickTargetingHandle&    TargetingType                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle IAuTargetingInterface::GetTargetDataHandles(const struct FAuTickTargetingHandle& TargetingType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("AuTargetingInterface", "GetTargetDataHandles");

	Params::AuTargetingInterface_GetTargetDataHandles Parms{};

	Parms.TargetingType = std::move(TargetingType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

