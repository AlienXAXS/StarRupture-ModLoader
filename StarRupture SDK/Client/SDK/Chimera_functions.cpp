#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Chimera

#include "Basic.hpp"

#include "Chimera_classes.hpp"
#include "Chimera_parameters.hpp"


namespace SDK
{

// Function Chimera.CrBaseAttackStateHelper.OnAttackFinished
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    FinishedSuccessful                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseAttackStateHelper::OnAttackFinished(bool FinishedSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseAttackStateHelper", "OnAttackFinished");

	Params::CrBaseAttackStateHelper_OnAttackFinished Parms{};

	Parms.FinishedSuccessful = FinishedSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseAttackStateHelper.OnBaseAttackWaveStarted
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FCrMassEntityReplicationHelper&AlienObelisks                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseAttackStateHelper::OnBaseAttackWaveStarted(const struct FCrMassEntityReplicationHelper& AlienObelisks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseAttackStateHelper", "OnBaseAttackWaveStarted");

	Params::CrBaseAttackStateHelper_OnBaseAttackWaveStarted Parms{};

	Parms.AlienObelisks = std::move(AlienObelisks);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseAttackStateHelper.OnRep_AttackedCore
// (Final, Native, Protected)

void ACrBaseAttackStateHelper::OnRep_AttackedCore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseAttackStateHelper", "OnRep_AttackedCore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAttributeChangeOnEventComponent.SendEvent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     EventPayloadTags                                       (Parm, NativeAccessSpecifierPublic)

void UCrAttributeChangeOnEventComponent::SendEvent(const struct FGameplayTag& EventTag, float Value, const struct FGameplayTagContainer& EventPayloadTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAttributeChangeOnEventComponent", "SendEvent");

	Params::CrAttributeChangeOnEventComponent_SendEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.Value = Value;
	Parms.EventPayloadTags = std::move(EventPayloadTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAudioBlueprintLibrary.CrPlaySoundForCharacter
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class ACrCharacterPlayerBase*     InCharacter                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       FppSound                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundBase*                       TppSound                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIsAttached                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   VolumeMultiplier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PitchMultiplier                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundConcurrency*                ConcurrencySettings                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                AttenuationSettings                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceFPPSound                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAudioComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAudioComponent* UCrAudioBlueprintLibrary::CrPlaySoundForCharacter(const class ACrCharacterPlayerBase* InCharacter, class USoundBase* FppSound, class USoundBase* TppSound, const struct FVector& Location, const struct FRotator& Rotation, bool bIsAttached, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundConcurrency* ConcurrencySettings, class USoundAttenuation* AttenuationSettings, bool bForceFPPSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAudioBlueprintLibrary", "CrPlaySoundForCharacter");

	Params::CrAudioBlueprintLibrary_CrPlaySoundForCharacter Parms{};

	Parms.InCharacter = InCharacter;
	Parms.FppSound = FppSound;
	Parms.TppSound = TppSound;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.bIsAttached = bIsAttached;
	Parms.VolumeMultiplier = VolumeMultiplier;
	Parms.PitchMultiplier = PitchMultiplier;
	Parms.StartTime = StartTime;
	Parms.ConcurrencySettings = ConcurrencySettings;
	Parms.AttenuationSettings = AttenuationSettings;
	Parms.bForceFPPSound = bForceFPPSound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudioBlueprintLibrary.GetWaveFromContext
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UDialogueWave*                    Dialogue                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDialogueContext&          Context                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class USoundBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundBase* UCrAudioBlueprintLibrary::GetWaveFromContext(class UDialogueWave* Dialogue, const struct FDialogueContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAudioBlueprintLibrary", "GetWaveFromContext");

	Params::CrAudioBlueprintLibrary_GetWaveFromContext Parms{};

	Parms.Dialogue = Dialogue;
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.BTTask_RunCrAiActionBlueprintBase.CreateAiAction
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UCrAiAction*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiAction* UBTTask_RunCrAiActionBlueprintBase::CreateAiAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BTTask_RunCrAiActionBlueprintBase", "CreateAiAction");

	Params::BTTask_RunCrAiActionBlueprintBase_CreateAiAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.ClipboardBPFunctionLibrary.CopyString
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// const class FString&                    Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClipboardBPFunctionLibrary::CopyString(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ClipboardBPFunctionLibrary", "CopyString");

	Params::ClipboardBPFunctionLibrary_CopyString Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.ClipboardBPFunctionLibrary.PasteString
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UClipboardBPFunctionLibrary::PasteString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ClipboardBPFunctionLibrary", "PasteString");

	Params::ClipboardBPFunctionLibrary_PasteString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAbilitiesBPFL.GetPlayRateForDuration
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// float                                   InCurrentMontageDuration                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InForcedMontageDuration                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrAbilitiesBPFL::GetPlayRateForDuration(float InCurrentMontageDuration, float InForcedMontageDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAbilitiesBPFL", "GetPlayRateForDuration");

	Params::CrAbilitiesBPFL_GetPlayRateForDuration Parms{};

	Parms.InCurrentMontageDuration = InCurrentMontageDuration;
	Parms.InForcedMontageDuration = InForcedMontageDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAbilitiesBPFL.MakeTargetDataHandleFromHitResults
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FHitResult>&        HitResults                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UCrAbilitiesBPFL::MakeTargetDataHandleFromHitResults(const TArray<struct FHitResult>& HitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAbilitiesBPFL", "MakeTargetDataHandleFromHitResults");

	Params::CrAbilitiesBPFL_MakeTargetDataHandleFromHitResults Parms{};

	Parms.HitResults = std::move(HitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAbilitiesBPFL.MakeTargetHitResultsFromDataHandle
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayAbilityTargetDataHandle&InTargetDataHandle                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FHitResult> UCrAbilitiesBPFL::MakeTargetHitResultsFromDataHandle(const struct FGameplayAbilityTargetDataHandle& InTargetDataHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAbilitiesBPFL", "MakeTargetHitResultsFromDataHandle");

	Params::CrAbilitiesBPFL_MakeTargetHitResultsFromDataHandle Parms{};

	Parms.InTargetDataHandle = std::move(InTargetDataHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrOreMassSpawner.OreFinishedSpawning
// (Final, Native, Private)

void ACrOreMassSpawner::OreFinishedSpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreMassSpawner", "OreFinishedSpawning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityProjectile.SetSourceWeaponActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrWeaponActor*                   InWeaponActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAbilityProjectile::SetSourceWeaponActor(class ACrWeaponActor* InWeaponActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityProjectile", "SetSourceWeaponActor");

	Params::CrAbilityProjectile_SetSourceWeaponActor Parms{};

	Parms.InWeaponActor = InWeaponActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityProjectile.SetSourceWeaponItemSlot
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               InSourceItemSlot                                       (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAbilityProjectile::SetSourceWeaponItemSlot(const struct FAuItemSlot& InSourceItemSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityProjectile", "SetSourceWeaponItemSlot");

	Params::CrAbilityProjectile_SetSourceWeaponItemSlot Parms{};

	Parms.InSourceItemSlot = std::move(InSourceItemSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityProjectile.GetSourceWeaponActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class ACrWeaponActor*             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class ACrWeaponActor* ACrAbilityProjectile::GetSourceWeaponActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityProjectile", "GetSourceWeaponActor");

	Params::CrAbilityProjectile_GetSourceWeaponActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAbilityProjectile.GetSourceWeaponItemSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAuItemSlot                      ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuItemSlot ACrAbilityProjectile::GetSourceWeaponItemSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityProjectile", "GetSourceWeaponItemSlot");

	Params::CrAbilityProjectile_GetSourceWeaponItemSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAbilitySystemComponent.AddGameplayCueLocal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCueParameters&    GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrAbilitySystemComponent::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilitySystemComponent", "AddGameplayCueLocal");

	Params::CrAbilitySystemComponent_AddGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilitySystemComponent.AddGameplayLooseTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAbilitySystemComponent::AddGameplayLooseTag(const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilitySystemComponent", "AddGameplayLooseTag");

	Params::CrAbilitySystemComponent_AddGameplayLooseTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilitySystemComponent.ClientNotifyAbilityFailed
// (Net, Native, Event, Protected, NetClient)
// Parameters:
// const class UGameplayAbility*           Ability                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     FailureReason                                          (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrAbilitySystemComponent::ClientNotifyAbilityFailed(const class UGameplayAbility* Ability, const struct FGameplayTagContainer& FailureReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilitySystemComponent", "ClientNotifyAbilityFailed");

	Params::CrAbilitySystemComponent_ClientNotifyAbilityFailed Parms{};

	Parms.Ability = Ability;
	Parms.FailureReason = std::move(FailureReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilitySystemComponent.ExecuteGameplayCueLocal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCueParameters&    GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrAbilitySystemComponent::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilitySystemComponent", "ExecuteGameplayCueLocal");

	Params::CrAbilitySystemComponent_ExecuteGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilitySystemComponent.RemoveGameplayCueLocal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayCueParameters&    GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrAbilitySystemComponent::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilitySystemComponent", "RemoveGameplayCueLocal");

	Params::CrAbilitySystemComponent_RemoveGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilitySystemComponent.RemoveGameplayLooseTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAbilitySystemComponent::RemoveGameplayLooseTag(const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilitySystemComponent", "RemoveGameplayLooseTag");

	Params::CrAbilitySystemComponent_RemoveGameplayLooseTag Parms{};

	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityTask_WaitActorPlaced.WaitActorPlaced
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrBuildingComponent*             BuildingComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAbilityTask_WaitActorPlaced*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAbilityTask_WaitActorPlaced* UCrAbilityTask_WaitActorPlaced::WaitActorPlaced(class UGameplayAbility* OwningAbility, class UCrBuildingComponent* BuildingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAbilityTask_WaitActorPlaced", "WaitActorPlaced");

	Params::CrAbilityTask_WaitActorPlaced_WaitActorPlaced Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.BuildingComponent = BuildingComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrActorLookupSubsystem.RegisterActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrActorLookupSubsystem::RegisterActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrActorLookupSubsystem", "RegisterActor");

	Params::CrActorLookupSubsystem_RegisterActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrActorLookupSubsystem.UnregisterActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrActorLookupSubsystem::UnregisterActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrActorLookupSubsystem", "UnregisterActor");

	Params::CrActorLookupSubsystem_UnregisterActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrActorLookupSubsystem.FindActors
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActorInstanceHandle>*    OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCrActorLookupSubsystem::FindActors(const struct FVector& InLocation, float InRadius, TArray<struct FActorInstanceHandle>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrActorLookupSubsystem", "FindActors");

	Params::CrActorLookupSubsystem_FindActors Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRadius = InRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Chimera.CrActorLookupSubsystem.FindActorsByBaseClass
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               InBaseClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActorInstanceHandle>*    OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCrActorLookupSubsystem::FindActorsByBaseClass(const struct FVector& InLocation, float InRadius, TSubclassOf<class AActor> InBaseClass, TArray<struct FActorInstanceHandle>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrActorLookupSubsystem", "FindActorsByBaseClass");

	Params::CrActorLookupSubsystem_FindActorsByBaseClass Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRadius = InRadius;
	Parms.InBaseClass = InBaseClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Chimera.CrActorLookupSubsystem.FindActorsByClass
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               InClass                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FActorInstanceHandle>*    OutActors                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCrActorLookupSubsystem::FindActorsByClass(const struct FVector& InLocation, float InRadius, TSubclassOf<class AActor> InClass, TArray<struct FActorInstanceHandle>* OutActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrActorLookupSubsystem", "FindActorsByClass");

	Params::CrActorLookupSubsystem_FindActorsByClass Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRadius = InRadius;
	Parms.InClass = InClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function Chimera.CrActorLookupSubsystem.FindClosestActorByBaseClass
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRadius                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               InBaseClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActorInstanceHandle             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActorInstanceHandle UCrActorLookupSubsystem::FindClosestActorByBaseClass(const struct FVector& InLocation, float InRadius, TSubclassOf<class AActor> InBaseClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrActorLookupSubsystem", "FindClosestActorByBaseClass");

	Params::CrActorLookupSubsystem_FindClosestActorByBaseClass Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.InRadius = InRadius;
	Parms.InBaseClass = InBaseClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrActorLookupSubsystem.ResolveActor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FActorInstanceHandle&      ActorHandle                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCrActorLookupSubsystem::ResolveActor(const struct FActorInstanceHandle& ActorHandle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrActorLookupSubsystem", "ResolveActor");

	Params::CrActorLookupSubsystem_ResolveActor Parms{};

	Parms.ActorHandle = std::move(ActorHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingCustomNameSubsystem.BindOnBuildingCustomNameChangedEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           BuildingActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TDelegate<void(const class FString& NewName)>&Delegate                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingCustomNameSubsystem::BindOnBuildingCustomNameChangedEvent(class AActor* BuildingActor, const TDelegate<void(const class FString& NewName)>& Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingCustomNameSubsystem", "BindOnBuildingCustomNameChangedEvent");

	Params::CrBuildingCustomNameSubsystem_BindOnBuildingCustomNameChangedEvent Parms{};

	Parms.BuildingActor = BuildingActor;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingCustomNameSubsystem.GetBuildingCustomName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           BuildingActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrBuildingCustomNameSubsystem::GetBuildingCustomName(class AActor* BuildingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingCustomNameSubsystem", "GetBuildingCustomName");

	Params::CrBuildingCustomNameSubsystem_GetBuildingCustomName Parms{};

	Parms.BuildingActor = BuildingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingCustomNameSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrBuildingCustomNameSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingCustomNameSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingCustomNameSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrBuildingCustomNameSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingCustomNameSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingCustomNameSubsystem.SetBuildingCustomNameReplicated
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           BuildingActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    CustomName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingCustomNameSubsystem::SetBuildingCustomNameReplicated(class AActor* BuildingActor, const class FString& CustomName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingCustomNameSubsystem", "SetBuildingCustomNameReplicated");

	Params::CrBuildingCustomNameSubsystem_SetBuildingCustomNameReplicated Parms{};

	Parms.BuildingActor = BuildingActor;
	Parms.CustomName = std::move(CustomName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAggroSubsystem.AddAggroLevelToActor
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LevelTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LevelVal                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAggroSubsystem::AddAggroLevelToActor(class AActor* Actor, class FName LevelTag, int32 LevelVal) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAggroSubsystem", "AddAggroLevelToActor");

	Params::CrAggroSubsystem_AddAggroLevelToActor Parms{};

	Parms.Actor = Actor;
	Parms.LevelTag = LevelTag;
	Parms.LevelVal = LevelVal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAggroSubsystem.AddCustomAggroModifierToActor
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ExtraAggroTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ExtraAggro                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAggroSubsystem::AddCustomAggroModifierToActor(class AActor* Actor, class FName ExtraAggroTag, float ExtraAggro) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAggroSubsystem", "AddCustomAggroModifierToActor");

	Params::CrAggroSubsystem_AddCustomAggroModifierToActor Parms{};

	Parms.Actor = Actor;
	Parms.ExtraAggroTag = ExtraAggroTag;
	Parms.ExtraAggro = ExtraAggro;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAggroSubsystem.RemoveAggroLevelFromActor
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LevelTag                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAggroSubsystem::RemoveAggroLevelFromActor(class AActor* Actor, class FName LevelTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAggroSubsystem", "RemoveAggroLevelFromActor");

	Params::CrAggroSubsystem_RemoveAggroLevelFromActor Parms{};

	Parms.Actor = Actor;
	Parms.LevelTag = LevelTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAggroSubsystem.RemoveCustomAggroModifierFromActor
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ExtraAggroTag                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAggroSubsystem::RemoveCustomAggroModifierFromActor(class AActor* Actor, class FName ExtraAggroTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAggroSubsystem", "RemoveCustomAggroModifierFromActor");

	Params::CrAggroSubsystem_RemoveCustomAggroModifierFromActor Parms{};

	Parms.Actor = Actor;
	Parms.ExtraAggroTag = ExtraAggroTag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiAction.Create_CrAiAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiAction>          ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxLifetimeS                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiAction*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiAction* UCrAiAction::Create_CrAiAction(TSubclassOf<class UCrAiAction> ActionType, float MaxLifetimeS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiAction", "Create_CrAiAction");

	Params::CrAiAction_Create_CrAiAction Parms{};

	Parms.ActionType = ActionType;
	Parms.MaxLifetimeS = MaxLifetimeS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAiAction.CanBeAborted
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrAiAction::CanBeAborted(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiAction", "CanBeAborted");

	Params::CrAiAction_CanBeAborted Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAiAction.FinishAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrAiActionResult                       Result                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiAction::FinishAction(ECrAiActionResult Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiAction", "FinishAction");

	Params::CrAiAction_FinishAction Parms{};

	Parms.Result = Result;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiAction.OnStart
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiAction::OnStart(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiAction", "OnStart");

	Params::CrAiAction_OnStart Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiAction.OnStartOnClient
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiAction::OnStartOnClient(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiAction", "OnStartOnClient");

	Params::CrAiAction_OnStartOnClient Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiAction.OnStop
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrAiActionStopReason                   StopReason                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiAction::OnStop(class AActor* AiActor, ECrAiActionStopReason StopReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiAction", "OnStop");

	Params::CrAiAction_OnStop Parms{};

	Parms.AiActor = AiActor;
	Parms.StopReason = StopReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiAction.OnStopOnClient
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiAction::OnStopOnClient(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiAction", "OnStopOnClient");

	Params::CrAiAction_OnStopOnClient Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiAction.OnUpdate
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiAction::OnUpdate(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiAction", "OnUpdate");

	Params::CrAiAction_OnUpdate Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiAction.OnUpdateOnClient
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiAction::OnUpdateOnClient(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiAction", "OnUpdateOnClient");

	Params::CrAiAction_OnUpdateOnClient Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrUW_FEMapLegend.SetTextArray
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class FText>&              InTexts                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const class FText&                      InFloorText                                            (ConstParm, Parm, NativeAccessSpecifierPublic)
// float                                   LeftMargin                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BottomMargin                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TMap<int32, float>&               FixedBottomMargin                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const float                             LegendVerticalOffset                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrUW_FEMapLegend::SetTextArray(const TArray<class FText>& InTexts, const class FText& InFloorText, float LeftMargin, float BottomMargin, const TMap<int32, float>& FixedBottomMargin, const float LegendVerticalOffset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrUW_FEMapLegend", "SetTextArray");

	Params::CrUW_FEMapLegend_SetTextArray Parms{};

	Parms.InTexts = std::move(InTexts);
	Parms.InFloorText = std::move(InFloorText);
	Parms.LeftMargin = LeftMargin;
	Parms.BottomMargin = BottomMargin;
	Parms.FixedBottomMargin = std::move(FixedBottomMargin);
	Parms.LegendVerticalOffset = LegendVerticalOffset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiActionComponent.CancelAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCrAiAction*                      AiAction                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionComponent::CancelAction(class UCrAiAction* AiAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionComponent", "CancelAction");

	Params::CrAiActionComponent_CancelAction Parms{};

	Parms.AiAction = AiAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiActionComponent.ExecuteAction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCrAiAction*                      AiAction                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrAiActionComponent::ExecuteAction(class UCrAiAction* AiAction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionComponent", "ExecuteAction");

	Params::CrAiActionComponent_ExecuteAction Parms{};

	Parms.AiAction = AiAction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAiActionComponent.OnRep_DeletedActions
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TArray<class UCrAiAction*>&       OldActions                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCrAiActionComponent::OnRep_DeletedActions(const TArray<class UCrAiAction*>& OldActions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionComponent", "OnRep_DeletedActions");

	Params::CrAiActionComponent_OnRep_DeletedActions Parms{};

	Parms.OldActions = std::move(OldActions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiActionComponent.OnRep_ReplicatedActions
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const TArray<class UCrAiAction*>&       OldActions                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCrAiActionComponent::OnRep_ReplicatedActions(const TArray<class UCrAiAction*>& OldActions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionComponent", "OnRep_ReplicatedActions");

	Params::CrAiActionComponent_OnRep_ReplicatedActions Parms{};

	Parms.OldActions = std::move(OldActions);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiActionGAS.Create_CrAiActionGAS
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionGAS>       ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     AbilityToRun_0                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionGAS*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionGAS* UCrAiActionGAS::Create_CrAiActionGAS(TSubclassOf<class UCrAiActionGAS> ActionType, float NewMaxLifetimeS, TSubclassOf<class UGameplayAbility> AbilityToRun_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionGAS", "Create_CrAiActionGAS");

	Params::CrAiActionGAS_Create_CrAiActionGAS Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.AbilityToRun_0 = AbilityToRun_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAiActionGAS.TryActivateGameplayAbilityAndRegisterCallbacks
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     AbilityToStart                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrAiActionGAS::TryActivateGameplayAbilityAndRegisterCallbacks(class AActor* AiActor, TSubclassOf<class UGameplayAbility> AbilityToStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionGAS", "TryActivateGameplayAbilityAndRegisterCallbacks");

	Params::CrAiActionGAS_TryActivateGameplayAbilityAndRegisterCallbacks Parms{};

	Parms.AiActor = AiActor;
	Parms.AbilityToStart = AbilityToStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWorldSpawnerRegionActor.Generate
// (Final, Native, Public, BlueprintCallable)

void ACrWorldSpawnerRegionActor::Generate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWorldSpawnerRegionActor", "Generate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWorldSpawnerRegionActor.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrWorldSpawnerRegionActor::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWorldSpawnerRegionActor", "OnBeginOverlap");

	Params::CrWorldSpawnerRegionActor_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWorldSpawnerRegionActor.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWorldSpawnerRegionActor::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWorldSpawnerRegionActor", "OnEndOverlap");

	Params::CrWorldSpawnerRegionActor_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWorldSpawnerRegionActor.TriggerGeneration
// (Final, Native, Private)

void ACrWorldSpawnerRegionActor::TriggerGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWorldSpawnerRegionActor", "TriggerGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAIBase.GetAbilitySystemComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAbilitySystemComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* ACrAIBase::GetAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAIBase", "GetAbilitySystemComponent");

	Params::CrAIBase_GetAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAIBase.GetAiActionComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrAiActionComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionComponent* ACrAIBase::GetAiActionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAIBase", "GetAiActionComponent");

	Params::CrAIBase_GetAiActionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAIBase.GetCharacterUniqueName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ACrAIBase::GetCharacterUniqueName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAIBase", "GetCharacterUniqueName");

	Params::CrAIBase_GetCharacterUniqueName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAIBase.GetHitNiagaraEffects
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* ACrAIBase::GetHitNiagaraEffects(const struct FHitResult& HitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAIBase", "GetHitNiagaraEffects");

	Params::CrAIBase_GetHitNiagaraEffects Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSimpleFoundableMassSpawner.GetCalculatedItemsToSpawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FCrItemsSpawnSettings>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCrItemsSpawnSettings> ACrSimpleFoundableMassSpawner::GetCalculatedItemsToSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSimpleFoundableMassSpawner", "GetCalculatedItemsToSpawn");

	Params::CrSimpleFoundableMassSpawner_GetCalculatedItemsToSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSimpleFoundableMassSpawner.GetItemsToSpawn
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TArray<struct FCrItemsSpawnSettings>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FCrItemsSpawnSettings> ACrSimpleFoundableMassSpawner::GetItemsToSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSimpleFoundableMassSpawner", "GetItemsToSpawn");

	Params::CrSimpleFoundableMassSpawner_GetItemsToSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSimpleFoundableMassSpawner.UpdateOwnedFoundableEntitiesLocation
// (Final, Native, Public, BlueprintCallable)

void ACrSimpleFoundableMassSpawner::UpdateOwnedFoundableEntitiesLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSimpleFoundableMassSpawner", "UpdateOwnedFoundableEntitiesLocation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSimpleFoundableMassSpawner.IsWorldEditorWorld
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrSimpleFoundableMassSpawner::IsWorldEditorWorld() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSimpleFoundableMassSpawner", "IsWorldEditorWorld");

	Params::CrSimpleFoundableMassSpawner_IsWorldEditorWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrHealthAttributeSet.OnRep_CurrentHealth
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentHealth                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHealthAttributeSet::OnRep_CurrentHealth(const struct FGameplayAttributeData& OldCurrentHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHealthAttributeSet", "OnRep_CurrentHealth");

	Params::CrHealthAttributeSet_OnRep_CurrentHealth Parms{};

	Parms.OldCurrentHealth = std::move(OldCurrentHealth);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHealthAttributeSet.OnRep_MaxHealth
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxHealth                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHealthAttributeSet::OnRep_MaxHealth(const struct FGameplayAttributeData& OldMaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHealthAttributeSet", "OnRep_MaxHealth");

	Params::CrHealthAttributeSet_OnRep_MaxHealth Parms{};

	Parms.OldMaxHealth = std::move(OldMaxHealth);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHealthAttributeSet.OnRep_MinHealth
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinHealth                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHealthAttributeSet::OnRep_MinHealth(const struct FGameplayAttributeData& OldMinHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHealthAttributeSet", "OnRep_MinHealth");

	Params::CrHealthAttributeSet_OnRep_MinHealth Parms{};

	Parms.OldMinHealth = std::move(OldMinHealth);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAIBaseAttributeSet.OnRep_MovementSpeed
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMovementSpeed                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrAIBaseAttributeSet::OnRep_MovementSpeed(const struct FGameplayAttributeData& OldMovementSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAIBaseAttributeSet", "OnRep_MovementSpeed");

	Params::CrAIBaseAttributeSet_OnRep_MovementSpeed Parms{};

	Parms.OldMovementSpeed = std::move(OldMovementSpeed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAIBaseAttributeSet.OnRep_MovementSpeedBoost
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMovementSpeedBoost                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrAIBaseAttributeSet::OnRep_MovementSpeedBoost(const struct FGameplayAttributeData& OldMovementSpeedBoost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAIBaseAttributeSet", "OnRep_MovementSpeedBoost");

	Params::CrAIBaseAttributeSet_OnRep_MovementSpeedBoost Parms{};

	Parms.OldMovementSpeedBoost = std::move(OldMovementSpeedBoost);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineSequenceDirector.SetSequenceOwner
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class ACrTimelineEvent*                 TimelineEvent                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrTimelineSequenceDirector::SetSequenceOwner(class ACrTimelineEvent* TimelineEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineSequenceDirector", "SetSequenceOwner");

	Params::CrTimelineSequenceDirector_SetSequenceOwner Parms{};

	Parms.TimelineEvent = TimelineEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineSequenceDirector.StartSpawning
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// class ACrAISpawner*                     Spawner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrTimelineSequenceDirector::StartSpawning(class ACrAISpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineSequenceDirector", "StartSpawning");

	Params::CrTimelineSequenceDirector_StartSpawning Parms{};

	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingComponent.ServerDestructBuildingActorInternal
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// const struct FMassNetworkID&            InActor                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingComponent::ServerDestructBuildingActorInternal(const struct FMassNetworkID& InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingComponent", "ServerDestructBuildingActorInternal");

	Params::CrBuildingComponent_ServerDestructBuildingActorInternal Parms{};

	Parms.InActor = std::move(InActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingComponent.BP_GetPlacementData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UAuActorPlacementData*      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAuActorPlacementData* UCrBuildingComponent::BP_GetPlacementData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingComponent", "BP_GetPlacementData");

	Params::CrBuildingComponent_BP_GetPlacementData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingInfectionComponent.OnBuildingInfectionActivityChange
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         EntityHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SignalName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingInfectionComponent::OnBuildingInfectionActivityChange(const struct FMassEntityHandle& EntityHandle, class FName SignalName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingInfectionComponent", "OnBuildingInfectionActivityChange");

	Params::CrBuildingInfectionComponent_OnBuildingInfectionActivityChange Parms{};

	Parms.EntityHandle = std::move(EntityHandle);
	Parms.SignalName = SignalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingInfectionComponent.OnBuildingInfectionCleanedUp
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         EntityHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingInfectionComponent::OnBuildingInfectionCleanedUp(const struct FMassEntityHandle& EntityHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingInfectionComponent", "OnBuildingInfectionCleanedUp");

	Params::CrBuildingInfectionComponent_OnBuildingInfectionCleanedUp Parms{};

	Parms.EntityHandle = std::move(EntityHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingInfectionComponent.OnFadeoutSubstageChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingInfectionComponent::OnFadeoutSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveFadeoutSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingInfectionComponent", "OnFadeoutSubstageChanged");

	Params::CrBuildingInfectionComponent_OnFadeoutSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingInfectionComponent.OnGrowbackSubstageChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingInfectionComponent::OnGrowbackSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveGrowbackSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingInfectionComponent", "OnGrowbackSubstageChanged");

	Params::CrBuildingInfectionComponent_OnGrowbackSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnAnimPoseSnapshotStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiDeathSequenceActor::OnAnimPoseSnapshotStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnAnimPoseSnapshotStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnDissolveEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiDeathSequenceActor::OnDissolveEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnDissolveEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnDissolveProgressChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DissolveProgress                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAiDeathSequenceActor::OnDissolveProgressChanged(float DissolveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnDissolveProgressChanged");

	Params::CrAiDeathSequenceActor_OnDissolveProgressChanged Parms{};

	Parms.DissolveProgress = DissolveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnPrepareRagdollType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiDeathSequenceActor::OnPrepareRagdollType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnPrepareRagdollType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnRagdollEnd
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiDeathSequenceActor::OnRagdollEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnRagdollEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnRagdollStart
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiDeathSequenceActor::OnRagdollStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnRagdollStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnReleasedToPool
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiDeathSequenceActor::OnReleasedToPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnReleasedToPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnReuse
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAiDeathSequenceActor::OnReuse(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnReuse");

	Params::CrAiDeathSequenceActor_OnReuse Parms{};

	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnTakenFromPool
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiDeathSequenceActor::OnTakenFromPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnTakenFromPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiDeathSequenceActor.OnVisualVariationSeedChanged
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAiDeathSequenceActor::OnVisualVariationSeedChanged(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceActor", "OnVisualVariationSeedChanged");

	Params::CrAiDeathSequenceActor_OnVisualVariationSeedChanged Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingSelectWidgetComponent.IsBuildingActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrBuildingSelectWidgetComponent::IsBuildingActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingSelectWidgetComponent", "IsBuildingActive");

	Params::CrBuildingSelectWidgetComponent_IsBuildingActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingSelectWidgetComponent.IsWeaponEquipped
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrBuildingSelectWidgetComponent::IsWeaponEquipped() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingSelectWidgetComponent", "IsWeaponEquipped");

	Params::CrBuildingSelectWidgetComponent_IsWeaponEquipped Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAiDeathSequenceSubsystem.StartDeadSequence
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACrAiDeathSequenceActor>DeathSequenceActorClass                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrAiDeathSequenceParameters&DeathSequenceParameters                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ACrAiDeathSequenceActor*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACrAiDeathSequenceActor* UCrAiDeathSequenceSubsystem::StartDeadSequence(TSubclassOf<class ACrAiDeathSequenceActor> DeathSequenceActorClass, const struct FCrAiDeathSequenceParameters& DeathSequenceParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiDeathSequenceSubsystem", "StartDeadSequence");

	Params::CrAiDeathSequenceSubsystem_StartDeadSequence Parms{};

	Parms.DeathSequenceActorClass = DeathSequenceActorClass;
	Parms.DeathSequenceParameters = std::move(DeathSequenceParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAIInterface.SetHP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   HP                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrAIInterface::SetHP(float HP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAIInterface", "SetHP");

	Params::CrAIInterface_SetHP Parms{};

	Parms.HP = HP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAIInterface.GetHP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrAIInterface::GetHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAIInterface", "GetHP");

	Params::CrAIInterface_GetHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAIInterface.GetMaxHP
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrAIInterface::GetMaxHP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAIInterface", "GetMaxHP");

	Params::CrAIInterface_GetMaxHP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAIInterface.IsDead
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrAIInterface::IsDead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAIInterface", "IsDead");

	Params::CrAIInterface_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrUW_BuildingCost.DeleteAllEntries
// (Event, Public, BlueprintEvent)

void UCrUW_BuildingCost::DeleteAllEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrUW_BuildingCost", "DeleteAllEntries");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrUW_BuildingCost.OnEntryCreated
// (Event, Public, BlueprintEvent)
// Parameters:
// class UCrUW_BuildingCostEntry*          CreatedEntry                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrUW_BuildingCost::OnEntryCreated(class UCrUW_BuildingCostEntry* CreatedEntry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrUW_BuildingCost", "OnEntryCreated");

	Params::CrUW_BuildingCost_OnEntryCreated Parms{};

	Parms.CreatedEntry = CreatedEntry;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrUW_BuildingCost.SetupInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrBuildingActorBase*             InBuilding                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrUW_BuildingCost::SetupInfo(class ACrBuildingActorBase* InBuilding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrUW_BuildingCost", "SetupInfo");

	Params::CrUW_BuildingCost_SetupInfo Parms{};

	Parms.InBuilding = InBuilding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingExclusionZoneBase.OnPlayerControlStateChanged
// (Final, Native, Public)
// Parameters:
// ECrPlayerControlState                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingExclusionZoneBase::OnPlayerControlStateChanged(ECrPlayerControlState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingExclusionZoneBase", "OnPlayerControlStateChanged");

	Params::CrBuildingExclusionZoneBase_OnPlayerControlStateChanged Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingExclusionZoneBase.SetExclusionZoneVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingExclusionZoneBase::SetExclusionZoneVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingExclusionZoneBase", "SetExclusionZoneVisibility");

	Params::CrBuildingExclusionZoneBase_SetExclusionZoneVisibility Parms{};

	Parms.Visible = Visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBPAimAnalysisCustomCriterion.BP_IsCriterionMet
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// const class ACrCharacterPlayerBase*     PossessedPlayer                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCrAbilitySystemComponent*  PossessedASC                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrBPAimAnalysisCustomCriterion::BP_IsCriterionMet(const class ACrCharacterPlayerBase* PossessedPlayer, const class UCrAbilitySystemComponent* PossessedASC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBPAimAnalysisCustomCriterion", "BP_IsCriterionMet");

	Params::CrBPAimAnalysisCustomCriterion_BP_IsCriterionMet Parms{};

	Parms.PossessedPlayer = PossessedPlayer;
	Parms.PossessedASC = PossessedASC;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrStorageAsBuilding.GetItemData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UCrItemDataBase**                 OutItemData                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrStorageAsBuilding::GetItemData(class UCrItemDataBase** OutItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStorageAsBuilding", "GetItemData");

	Params::CrStorageAsBuilding_GetItemData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItemData != nullptr)
		*OutItemData = Parms.OutItemData;

	return Parms.ReturnValue;
}


// Function Chimera.CrStorageAsBuilding.IsStorageEmpty
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrStorageAsBuilding::IsStorageEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStorageAsBuilding", "IsStorageEmpty");

	Params::CrStorageAsBuilding_IsStorageEmpty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrStorageAsBuilding.OnItemAddedToStorage
// (Event, Public, BlueprintEvent)

void ACrStorageAsBuilding::OnItemAddedToStorage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStorageAsBuilding", "OnItemAddedToStorage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrStorageAsBuilding.OnStorageEmptied
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrStorageAsBuilding::OnStorageEmptied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStorageAsBuilding", "OnStorageEmptied");

	Params::CrStorageAsBuilding_OnStorageEmptied Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBPAimAnalysisCustomResponse.BP_OnTriggered
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     PossessedPlayer                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCrAbilitySystemComponent*  PossessedASC                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TraceTickRate                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBPAimAnalysisCustomResponse::BP_OnTriggered(const struct FHitResult& HitResult, const class ACrCharacterPlayerBase* PossessedPlayer, const class UCrAbilitySystemComponent* PossessedASC, float TraceTickRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBPAimAnalysisCustomResponse", "BP_OnTriggered");

	Params::CrBPAimAnalysisCustomResponse_BP_OnTriggered Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.PossessedPlayer = PossessedPlayer;
	Parms.PossessedASC = PossessedASC;
	Parms.TraceTickRate = TraceTickRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCaloriesAttributeSet.OnRep_CurrentCalories
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentCalories                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrCaloriesAttributeSet::OnRep_CurrentCalories(const struct FGameplayAttributeData& OldCurrentCalories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCaloriesAttributeSet", "OnRep_CurrentCalories");

	Params::CrCaloriesAttributeSet_OnRep_CurrentCalories Parms{};

	Parms.OldCurrentCalories = std::move(OldCurrentCalories);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCaloriesAttributeSet.OnRep_MaxCalories
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxCalories                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrCaloriesAttributeSet::OnRep_MaxCalories(const struct FGameplayAttributeData& OldMaxCalories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCaloriesAttributeSet", "OnRep_MaxCalories");

	Params::CrCaloriesAttributeSet_OnRep_MaxCalories Parms{};

	Parms.OldMaxCalories = std::move(OldMaxCalories);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCaloriesAttributeSet.OnRep_MinCalories
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinCalories                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrCaloriesAttributeSet::OnRep_MinCalories(const struct FGameplayAttributeData& OldMinCalories)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCaloriesAttributeSet", "OnRep_MinCalories");

	Params::CrCaloriesAttributeSet_OnRep_MinCalories Parms{};

	Parms.OldMinCalories = std::move(OldMinCalories);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDatapadBase.GetAllDatapadRowHandles
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FDataTableRowHandle>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDataTableRowHandle> ACrDatapadBase::GetAllDatapadRowHandles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "GetAllDatapadRowHandles");

	Params::CrDatapadBase_GetAllDatapadRowHandles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDatapadBase.GetDatapadEntriesData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FDatapadData>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FDatapadData> ACrDatapadBase::GetDatapadEntriesData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "GetDatapadEntriesData");

	Params::CrDatapadBase_GetDatapadEntriesData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDatapadBase.OnDatapadEntryRead
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDataTableRowHandle&       RowHandle                                              (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrDatapadBase::OnDatapadEntryRead(class AActor* InteractingActor, const struct FDataTableRowHandle& RowHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "OnDatapadEntryRead");

	Params::CrDatapadBase_OnDatapadEntryRead Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.RowHandle = std::move(RowHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDatapadBase.OnEntryRead
// (Final, Native, Public)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EntryName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDatapadBase::OnEntryRead(class APlayerController* InPc, class FName EntryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "OnEntryRead");

	Params::CrDatapadBase_OnEntryRead Parms{};

	Parms.InPc = InPc;
	Parms.EntryName = EntryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDatapadBase.OnNativeInteract
// (Native, Event, Public, BlueprintEvent)

void ACrDatapadBase::OnNativeInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "OnNativeInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDatapadBase.OnRep_ReadEntries
// (Final, Native, Public)

void ACrDatapadBase::OnRep_ReadEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "OnRep_ReadEntries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDatapadBase.ResetGuid
// (Final, Native, Public, BlueprintCallable)

void ACrDatapadBase::ResetGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "ResetGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDatapadBase.UpdateActorVisualsBasedOnReadStatus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bWasRead                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrDatapadBase::UpdateActorVisualsBasedOnReadStatus(bool bWasRead)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "UpdateActorVisualsBasedOnReadStatus");

	Params::CrDatapadBase_UpdateActorVisualsBasedOnReadStatus Parms{};

	Parms.bWasRead = bWasRead;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDatapadBase.GetAllDatapadEntriesId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ACrDatapadBase::GetAllDatapadEntriesId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "GetAllDatapadEntriesId");

	Params::CrDatapadBase_GetAllDatapadEntriesId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDatapadBase.GetGuid
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid ACrDatapadBase::GetGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "GetGuid");

	Params::CrDatapadBase_GetGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDatapadBase.GetInteractionText
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ACrDatapadBase::GetInteractionText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "GetInteractionText");

	Params::CrDatapadBase_GetInteractionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDatapadBase.WasDatapadEntryRead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrDatapadBase::WasDatapadEntryRead(class FName RowName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "WasDatapadEntryRead");

	Params::CrDatapadBase_WasDatapadEntryRead Parms{};

	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDatapadBase.WereAllNotesRead
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrDatapadBase::WereAllNotesRead() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDatapadBase", "WereAllNotesRead");

	Params::CrDatapadBase_WereAllNotesRead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAimContextAnalyzerSubsystem.OnPawnChanged
// (Final, Native, Public)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAimContextAnalyzerSubsystem::OnPawnChanged(class APawn* OldPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAimContextAnalyzerSubsystem", "OnPawnChanged");

	Params::CrAimContextAnalyzerSubsystem_OnPawnChanged Parms{};

	Parms.OldPawn = OldPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointBase.MulticastSetOccupied
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    InIsOccupied                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterSpawnPointBase::MulticastSetOccupied(bool InIsOccupied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointBase", "MulticastSetOccupied");

	Params::CrCharacterSpawnPointBase_MulticastSetOccupied Parms{};

	Parms.InIsOccupied = InIsOccupied;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointBase.MulticastSetOccupyingActor
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACrCharacterPlayerBase*           InOccupyingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterSpawnPointBase::MulticastSetOccupyingActor(class ACrCharacterPlayerBase* InOccupyingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointBase", "MulticastSetOccupyingActor");

	Params::CrCharacterSpawnPointBase_MulticastSetOccupyingActor Parms{};

	Parms.InOccupyingActor = InOccupyingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointBase.MulticastSetOccupyingPlayer
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const class FString&                    InOccupyingPlayer                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterSpawnPointBase::MulticastSetOccupyingPlayer(const class FString& InOccupyingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointBase", "MulticastSetOccupyingPlayer");

	Params::CrCharacterSpawnPointBase_MulticastSetOccupyingPlayer Parms{};

	Parms.InOccupyingPlayer = std::move(InOccupyingPlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointBase.ServerSetOccupied
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    InIsOccupied                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterSpawnPointBase::ServerSetOccupied(bool InIsOccupied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointBase", "ServerSetOccupied");

	Params::CrCharacterSpawnPointBase_ServerSetOccupied Parms{};

	Parms.InIsOccupied = InIsOccupied;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointBase.ServerSetOccupyingActor
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACrCharacterPlayerBase*           InOccupyingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterSpawnPointBase::ServerSetOccupyingActor(class ACrCharacterPlayerBase* InOccupyingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointBase", "ServerSetOccupyingActor");

	Params::CrCharacterSpawnPointBase_ServerSetOccupyingActor Parms{};

	Parms.InOccupyingActor = InOccupyingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointBase.ServerSetOccupyingPlayer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    InOccupyingPlayer                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterSpawnPointBase::ServerSetOccupyingPlayer(const class FString& InOccupyingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointBase", "ServerSetOccupyingPlayer");

	Params::CrCharacterSpawnPointBase_ServerSetOccupyingPlayer Parms{};

	Parms.InOccupyingPlayer = std::move(InOccupyingPlayer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointBase.GetOccupyingActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACrCharacterPlayerBase*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACrCharacterPlayerBase* ACrCharacterSpawnPointBase::GetOccupyingActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointBase", "GetOccupyingActor");

	Params::CrCharacterSpawnPointBase_GetOccupyingActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterSpawnPointBase.GetOccupyingPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACrCharacterSpawnPointBase::GetOccupyingPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointBase", "GetOccupyingPlayer");

	Params::CrCharacterSpawnPointBase_GetOccupyingPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAiProjectileActor.CancelProjectile
// (Final, Native, Public, BlueprintCallable)

void ACrAiProjectileActor::CancelProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "CancelProjectile");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.OnHit
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrAiProjectileActor::OnHit(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "OnHit");

	Params::CrAiProjectileActor_OnHit Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.OnProjectileActivated
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiProjectileActor::OnProjectileActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "OnProjectileActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.OnProjectileDeactivated
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiProjectileActor::OnProjectileDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "OnProjectileDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.OnProjectileShot
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCrAiProjectileParameters& InProjectileParameters                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrAiProjectileActor::OnProjectileShot(const struct FCrAiProjectileParameters& InProjectileParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "OnProjectileShot");

	Params::CrAiProjectileActor_OnProjectileShot Parms{};

	Parms.InProjectileParameters = std::move(InProjectileParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.OnProjectileStop
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FHitResult&                ImpactResult                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrAiProjectileActor::OnProjectileStop(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "OnProjectileStop");

	Params::CrAiProjectileActor_OnProjectileStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.OnReleasedToPool
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiProjectileActor::OnReleasedToPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "OnReleasedToPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.OnReuse
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiProjectileActor::OnReuse()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "OnReuse");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.OnTakenFromPool
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrAiProjectileActor::OnTakenFromPool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "OnTakenFromPool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiProjectileActor.CanReturnToPoolAfterHit
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrAiProjectileActor::CanReturnToPoolAfterHit() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "CanReturnToPoolAfterHit");

	Params::CrAiProjectileActor_CanReturnToPoolAfterHit Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAiProjectileActor.ShouldForceReturnToPool
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrAiProjectileActor::ShouldForceReturnToPool() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileActor", "ShouldForceReturnToPool");

	Params::CrAiProjectileActor_ShouldForceReturnToPool Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAiProjectileSubsystem.ShootProjectile
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACrAiProjectileActor> ProjectileActorClass                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrAiProjectileParameters& ProjectileParameters                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class ACrAiProjectileActor*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACrAiProjectileActor* UCrAiProjectileSubsystem::ShootProjectile(TSubclassOf<class ACrAiProjectileActor> ProjectileActorClass, const struct FCrAiProjectileParameters& ProjectileParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiProjectileSubsystem", "ShootProjectile");

	Params::CrAiProjectileSubsystem_ShootProjectile Parms{};

	Parms.ProjectileActorClass = ProjectileActorClass;
	Parms.ProjectileParameters = std::move(ProjectileParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAISpawner.ResetGuid
// (Native, Public, BlueprintCallable)

void ACrAISpawner::ResetGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAISpawner", "ResetGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAISpawnerTriggerInterface.OnPlayerEnter
// (Native, Public)
// Parameters:
// class ACrPlayerControllerBase*          Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrAISpawnerTriggerInterface::OnPlayerEnter(class ACrPlayerControllerBase* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAISpawnerTriggerInterface", "OnPlayerEnter");

	Params::CrAISpawnerTriggerInterface_OnPlayerEnter Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAISpawnerTriggerInterface.OnPlayerExit
// (Native, Public)
// Parameters:
// class ACrPlayerControllerBase*          Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrAISpawnerTriggerInterface::OnPlayerExit(class ACrPlayerControllerBase* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAISpawnerTriggerInterface", "OnPlayerExit");

	Params::CrAISpawnerTriggerInterface_OnPlayerExit Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAISpawnerTriggerInterface.GetActivateAiAggroOnEnter
// (Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrAISpawnerTriggerInterface::GetActivateAiAggroOnEnter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAISpawnerTriggerInterface", "GetActivateAiAggroOnEnter");

	Params::CrAISpawnerTriggerInterface_GetActivateAiAggroOnEnter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAISpawnerTriggerInterface.GetAsBox
// (Native, Public, HasDefaults, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FBox ICrAISpawnerTriggerInterface::GetAsBox() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAISpawnerTriggerInterface", "GetAsBox");

	Params::CrAISpawnerTriggerInterface_GetAsBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAISpawnerTriggerInterface.GetAsSphere
// (Native, Public, HasDefaults, Const)
// Parameters:
// struct FSphere                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FSphere ICrAISpawnerTriggerInterface::GetAsSphere() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAISpawnerTriggerInterface", "GetAsSphere");

	Params::CrAISpawnerTriggerInterface_GetAsSphere Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAISpawnerTriggerInterface.GetTriggerType
// (Native, Public, Const)
// Parameters:
// EMassEnemySpawnerTriggerType            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMassEnemySpawnerTriggerType ICrAISpawnerTriggerInterface::GetTriggerType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAISpawnerTriggerInterface", "GetTriggerType");

	Params::CrAISpawnerTriggerInterface_GetTriggerType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAISpawnerTriggerInterface.IsSphereShape
// (Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrAISpawnerTriggerInterface::IsSphereShape() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAISpawnerTriggerInterface", "IsSphereShape");

	Params::CrAISpawnerTriggerInterface_IsSphereShape Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.AddActorWorldRotationWithoutAffectingMesh
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  DeltaRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::AddActorWorldRotationWithoutAffectingMesh(const struct FRotator& DeltaRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "AddActorWorldRotationWithoutAffectingMesh");

	Params::CrCharacterMovementComponent_AddActorWorldRotationWithoutAffectingMesh Parms{};

	Parms.DeltaRotation = std::move(DeltaRotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.CancelZiplineTravel
// (Final, Native, Public)

void UCrCharacterMovementComponent::CancelZiplineTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "CancelZiplineTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.CanEnterSlide
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::CanEnterSlide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "CanEnterSlide");

	Params::CrCharacterMovementComponent_CanEnterSlide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.CanExecuteDash
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::CanExecuteDash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "CanExecuteDash");

	Params::CrCharacterMovementComponent_CanExecuteDash Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.ClientSetTeleportDestinationFloorData
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FVector&                   FloorImpactPoint                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       FloorName                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::ClientSetTeleportDestinationFloorData(const struct FVector& FloorImpactPoint, const class FName FloorName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "ClientSetTeleportDestinationFloorData");

	Params::CrCharacterMovementComponent_ClientSetTeleportDestinationFloorData Parms{};

	Parms.FloorImpactPoint = std::move(FloorImpactPoint);
	Parms.FloorName = FloorName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.ClientSetTeleportDestinationFloorEntityID
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const struct FCrMassEntityReplicationHelper&MassReplicationHelper                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::ClientSetTeleportDestinationFloorEntityID(const struct FCrMassEntityReplicationHelper& MassReplicationHelper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "ClientSetTeleportDestinationFloorEntityID");

	Params::CrCharacterMovementComponent_ClientSetTeleportDestinationFloorEntityID Parms{};

	Parms.MassReplicationHelper = std::move(MassReplicationHelper);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.ExitSlide
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    FromInput                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::ExitSlide(bool FromInput)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "ExitSlide");

	Params::CrCharacterMovementComponent_ExitSlide Parms{};

	Parms.FromInput = FromInput;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.FinishZiplineTravel
// (Final, Native, Public)

void UCrCharacterMovementComponent::FinishZiplineTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "FinishZiplineTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.IsDashing
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::IsDashing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "IsDashing");

	Params::CrCharacterMovementComponent_IsDashing Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.IsInPushMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::IsInPushMovementMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "IsInPushMovementMode");

	Params::CrCharacterMovementComponent_IsInPushMovementMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.Multicast_CancelZiplineTravel
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UCrCharacterMovementComponent::Multicast_CancelZiplineTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Multicast_CancelZiplineTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Multicast_ExitSlide
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bExecuteOnOwningClient                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::Multicast_ExitSlide(bool bExecuteOnOwningClient)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Multicast_ExitSlide");

	Params::CrCharacterMovementComponent_Multicast_ExitSlide Parms{};

	Parms.bExecuteOnOwningClient = bExecuteOnOwningClient;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Multicast_FinishZiplineTravel
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UCrCharacterMovementComponent::Multicast_FinishZiplineTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Multicast_FinishZiplineTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Multicast_StartDash
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FVector&                   DashDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DashTimestamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::Multicast_StartDash(const struct FVector& DashDirection, float DashTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Multicast_StartDash");

	Params::CrCharacterMovementComponent_Multicast_StartDash Parms{};

	Parms.DashDirection = std::move(DashDirection);
	Parms.DashTimestamp = DashTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Multicast_StartSlide
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UCrCharacterMovementComponent::Multicast_StartSlide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Multicast_StartSlide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Multicast_StartZiplineTravel
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FVector&                   InZiplineDirection                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InEndZiplinePlayerPointLocation                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InZiplineSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassEntityReplicationHelper&InEndZipline                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::Multicast_StartZiplineTravel(const struct FVector& InZiplineDirection, const struct FVector& InEndZiplinePlayerPointLocation, float InZiplineSpeed, const struct FCrMassEntityReplicationHelper& InEndZipline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Multicast_StartZiplineTravel");

	Params::CrCharacterMovementComponent_Multicast_StartZiplineTravel Parms{};

	Parms.InZiplineDirection = std::move(InZiplineDirection);
	Parms.InEndZiplinePlayerPointLocation = std::move(InEndZiplinePlayerPointLocation);
	Parms.InZiplineSpeed = InZiplineSpeed;
	Parms.InEndZipline = std::move(InEndZipline);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Multicast_StopDash
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// float                                   DashTimestamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::Multicast_StopDash(float DashTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Multicast_StopDash");

	Params::CrCharacterMovementComponent_Multicast_StopDash Parms{};

	Parms.DashTimestamp = DashTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.MulticastSetOnLadder
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    bIsOnLadder                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::MulticastSetOnLadder(bool bIsOnLadder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "MulticastSetOnLadder");

	Params::CrCharacterMovementComponent_MulticastSetOnLadder Parms{};

	Parms.bIsOnLadder = bIsOnLadder;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.MulticastStartPush
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxPushDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPushDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::MulticastStartPush(const struct FVector& Direction, float InMaxPushDistance, float InPushDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "MulticastStartPush");

	Params::CrCharacterMovementComponent_MulticastStartPush Parms{};

	Parms.Direction = std::move(Direction);
	Parms.InMaxPushDistance = InMaxPushDistance;
	Parms.InPushDuration = InPushDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.OnZiplineModeEnded
// (Final, Native, Public)

void UCrCharacterMovementComponent::OnZiplineModeEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "OnZiplineModeEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.OnZiplineModeStarted
// (Final, Native, Public)

void UCrCharacterMovementComponent::OnZiplineModeStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "OnZiplineModeStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.PreDebugTeleport
// (Final, Native, Public, BlueprintCallable)

void UCrCharacterMovementComponent::PreDebugTeleport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "PreDebugTeleport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Server_CancelZiplineTravel
// (Net, NetReliable, Native, Event, Public, NetServer)

void UCrCharacterMovementComponent::Server_CancelZiplineTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Server_CancelZiplineTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Server_FinishZiplineTravel
// (Net, NetReliable, Native, Event, Public, NetServer)

void UCrCharacterMovementComponent::Server_FinishZiplineTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Server_FinishZiplineTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Server_StartDash
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   DashDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DashTimestamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::Server_StartDash(const struct FVector& DashDirection, float DashTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Server_StartDash");

	Params::CrCharacterMovementComponent_Server_StartDash Parms{};

	Parms.DashDirection = std::move(DashDirection);
	Parms.DashTimestamp = DashTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Server_StartZiplineTravel
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   InZiplineDirection                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InEndZiplinePlayerPointLocation                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InZiplineSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassEntityReplicationHelper&InEndZipline                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::Server_StartZiplineTravel(const struct FVector& InZiplineDirection, const struct FVector& InEndZiplinePlayerPointLocation, float InZiplineSpeed, const struct FCrMassEntityReplicationHelper& InEndZipline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Server_StartZiplineTravel");

	Params::CrCharacterMovementComponent_Server_StartZiplineTravel Parms{};

	Parms.InZiplineDirection = std::move(InZiplineDirection);
	Parms.InEndZiplinePlayerPointLocation = std::move(InEndZiplinePlayerPointLocation);
	Parms.InZiplineSpeed = InZiplineSpeed;
	Parms.InEndZipline = std::move(InEndZipline);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.Server_StopDash
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   DashTimestamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::Server_StopDash(float DashTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "Server_StopDash");

	Params::CrCharacterMovementComponent_Server_StopDash Parms{};

	Parms.DashTimestamp = DashTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.ServerExitSlide
// (Net, NetReliable, Native, Event, Public, NetServer)

void UCrCharacterMovementComponent::ServerExitSlide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "ServerExitSlide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.ServerSetOnLadder
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bIsOnLadder                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassEntityReplicationHelper&LadderEntityReplicationHelper                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::ServerSetOnLadder(bool bIsOnLadder, const struct FCrMassEntityReplicationHelper& LadderEntityReplicationHelper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "ServerSetOnLadder");

	Params::CrCharacterMovementComponent_ServerSetOnLadder Parms{};

	Parms.bIsOnLadder = bIsOnLadder;
	Parms.LadderEntityReplicationHelper = std::move(LadderEntityReplicationHelper);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.ServerStartSlide
// (Net, NetReliable, Native, Event, Public, NetServer)

void UCrCharacterMovementComponent::ServerStartSlide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "ServerStartSlide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.SetClientSmoothingRotationEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    NewEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::SetClientSmoothingRotationEnabled(bool NewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "SetClientSmoothingRotationEnabled");

	Params::CrCharacterMovementComponent_SetClientSmoothingRotationEnabled Parms{};

	Parms.NewEnabled = NewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.StartDash
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   DashDirection                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::StartDash(const struct FVector& DashDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "StartDash");

	Params::CrCharacterMovementComponent_StartDash Parms{};

	Parms.DashDirection = std::move(DashDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.StartZiplineTravel
// (Final, Native, Public, HasDefaults)
// Parameters:
// const struct FVector&                   InZiplineDirection                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InEndZiplinePlayerPointLocation                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InZiplineSpeed                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassEntityReplicationHelper&InEndZipline                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::StartZiplineTravel(const struct FVector& InZiplineDirection, const struct FVector& InEndZiplinePlayerPointLocation, float InZiplineSpeed, const struct FCrMassEntityReplicationHelper& InEndZipline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "StartZiplineTravel");

	Params::CrCharacterMovementComponent_StartZiplineTravel Parms{};

	Parms.InZiplineDirection = std::move(InZiplineDirection);
	Parms.InEndZiplinePlayerPointLocation = std::move(InEndZiplinePlayerPointLocation);
	Parms.InZiplineSpeed = InZiplineSpeed;
	Parms.InEndZipline = std::move(InEndZipline);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.StopDash
// (Final, Native, Public)
// Parameters:
// float                                   DashTimestamp                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterMovementComponent::StopDash(float DashTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "StopDash");

	Params::CrCharacterMovementComponent_StopDash Parms{};

	Parms.DashTimestamp = DashTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterMovementComponent.CanSlide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::CanSlide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "CanSlide");

	Params::CrCharacterMovementComponent_CanSlide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.GetCameraHeightForSlide
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrCharacterMovementComponent::GetCameraHeightForSlide() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "GetCameraHeightForSlide");

	Params::CrCharacterMovementComponent_GetCameraHeightForSlide Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.GetDashEnergyCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrCharacterMovementComponent::GetDashEnergyCost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "GetDashEnergyCost");

	Params::CrCharacterMovementComponent_GetDashEnergyCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.GetJumpEnergyCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrCharacterMovementComponent::GetJumpEnergyCost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "GetJumpEnergyCost");

	Params::CrCharacterMovementComponent_GetJumpEnergyCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.IsCustomMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECustomMovementMode                     InCustomMovementMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::IsCustomMovementMode(ECustomMovementMode InCustomMovementMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "IsCustomMovementMode");

	Params::CrCharacterMovementComponent_IsCustomMovementMode Parms{};

	Parms.InCustomMovementMode = InCustomMovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.IsSliding
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::IsSliding() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "IsSliding");

	Params::CrCharacterMovementComponent_IsSliding Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.IsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::IsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "IsSprinting");

	Params::CrCharacterMovementComponent_IsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.IsStandingOnStairs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::IsStandingOnStairs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "IsStandingOnStairs");

	Params::CrCharacterMovementComponent_IsStandingOnStairs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterMovementComponent.IsWalkableOnExtendedSlopeAngle
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrCharacterMovementComponent::IsWalkableOnExtendedSlopeAngle(const struct FHitResult& Hit) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterMovementComponent", "IsWalkableOnExtendedSlopeAngle");

	Params::CrCharacterMovementComponent_IsWalkableOnExtendedSlopeAngle Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.AddAvailableModForUnlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrWeaponModBlueprintItemBase>ModBlueprint                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USharedQuestItemsListComponent::AddAvailableModForUnlock(TSubclassOf<class UCrWeaponModBlueprintItemBase> ModBlueprint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "AddAvailableModForUnlock");

	Params::SharedQuestItemsListComponent_AddAvailableModForUnlock Parms{};

	Parms.ModBlueprint = ModBlueprint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.SharedQuestItemsListComponent.AddAvailableWeaponForUnlock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrWeaponItemDataBase>NewItem                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USharedQuestItemsListComponent::AddAvailableWeaponForUnlock(TSubclassOf<class UCrWeaponItemDataBase> NewItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "AddAvailableWeaponForUnlock");

	Params::SharedQuestItemsListComponent_AddAvailableWeaponForUnlock Parms{};

	Parms.NewItem = NewItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.SharedQuestItemsListComponent.AddItemToQuestList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAuItemDataBase>      ItemToAdd                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsListComponent::AddItemToQuestList(TSubclassOf<class UAuItemDataBase> ItemToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "AddItemToQuestList");

	Params::SharedQuestItemsListComponent_AddItemToQuestList Parms{};

	Parms.ItemToAdd = ItemToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.AddPickableGuidToPickedArray
// (Final, Native, Public, HasDefaults)
// Parameters:
// const struct FGuid&                     InGuid                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USharedQuestItemsListComponent::AddPickableGuidToPickedArray(const struct FGuid& InGuid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "AddPickableGuidToPickedArray");

	Params::SharedQuestItemsListComponent_AddPickableGuidToPickedArray Parms{};

	Parms.InGuid = std::move(InGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.SharedQuestItemsListComponent.GetAllAvailableMods
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<TSoftObjectPtr<class UCrWeaponModDataAsset>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UCrWeaponModDataAsset>> USharedQuestItemsListComponent::GetAllAvailableMods()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "GetAllAvailableMods");

	Params::SharedQuestItemsListComponent_GetAllAvailableMods Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.IsWeaponModUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSoftObjectPtr<class UCrWeaponModDataAsset>ModObject                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsListComponent::IsWeaponModUnlocked(TSoftObjectPtr<class UCrWeaponModDataAsset> ModObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "IsWeaponModUnlocked");

	Params::SharedQuestItemsListComponent_IsWeaponModUnlocked Parms{};

	Parms.ModObject = ModObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.OnPreSaveStart
// (Final, Native, Private)

void USharedQuestItemsListComponent::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.SharedQuestItemsListComponent.OnSaveLoaded
// (Final, Native, Private)

void USharedQuestItemsListComponent::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.SharedQuestItemsListComponent.RemoveItemFromQuestList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAuItemDataBase>      ItemToRemove                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsListComponent::RemoveItemFromQuestList(TSubclassOf<class UAuItemDataBase> ItemToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "RemoveItemFromQuestList");

	Params::SharedQuestItemsListComponent_RemoveItemFromQuestList Parms{};

	Parms.ItemToRemove = ItemToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.RemoveItemQuantityFromQuestList
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAuItemDataBase>      ItemToRemove                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   QuantityToRemove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsListComponent::RemoveItemQuantityFromQuestList(TSubclassOf<class UAuItemDataBase> ItemToRemove, int32 QuantityToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "RemoveItemQuantityFromQuestList");

	Params::SharedQuestItemsListComponent_RemoveItemQuantityFromQuestList Parms{};

	Parms.ItemToRemove = ItemToRemove;
	Parms.QuantityToRemove = QuantityToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.WasPickableTaken
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGuid&                     PickableGuid                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsListComponent::WasPickableTaken(const struct FGuid& PickableGuid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "WasPickableTaken");

	Params::SharedQuestItemsListComponent_WasPickableTaken Parms{};

	Parms.PickableGuid = std::move(PickableGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.ContainsItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAuItemDataBase>      Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsListComponent::ContainsItem(TSubclassOf<class UAuItemDataBase> Item) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "ContainsItem");

	Params::SharedQuestItemsListComponent_ContainsItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.GetAvailableWeaponsForUnlock
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TSubclassOf<class UCrWeaponItemDataBase>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class UCrWeaponItemDataBase>> USharedQuestItemsListComponent::GetAvailableWeaponsForUnlock() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "GetAvailableWeaponsForUnlock");

	Params::SharedQuestItemsListComponent_GetAvailableWeaponsForUnlock Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.GetSharedQuestItemsList
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TSubclassOf<class UAuItemDataBase>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class UAuItemDataBase>> USharedQuestItemsListComponent::GetSharedQuestItemsList() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "GetSharedQuestItemsList");

	Params::SharedQuestItemsListComponent_GetSharedQuestItemsList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsListComponent.GetSharedQuestItemsMap
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<TSubclassOf<class UAuItemDataBase>, int32>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<TSubclassOf<class UAuItemDataBase>, int32> USharedQuestItemsListComponent::GetSharedQuestItemsMap() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SharedQuestItemsListComponent", "GetSharedQuestItemsMap");

	Params::SharedQuestItemsListComponent_GetSharedQuestItemsMap Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrContextEffectComponent.AnimMotionEffect_Implementation
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FName                       bone                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              MotionEffect                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  RotationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const class UAnimSequenceBase*          AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bHitSuccess                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Contexts                                               (Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   VFXScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioPitch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrContextEffectComponent::AnimMotionEffect_Implementation(const class FName bone, const struct FGameplayTag& MotionEffect, class USceneComponent* StaticMeshComponent, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const class UAnimSequenceBase* AnimationSequence, const bool bHitSuccess, const struct FHitResult& HitResult, const struct FGameplayTagContainer& Contexts, const struct FVector& VFXScale, float AudioVolume, float AudioPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectComponent", "AnimMotionEffect_Implementation");

	Params::CrContextEffectComponent_AnimMotionEffect_Implementation Parms{};

	Parms.bone = bone;
	Parms.MotionEffect = std::move(MotionEffect);
	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.AnimationSequence = AnimationSequence;
	Parms.bHitSuccess = bHitSuccess;
	Parms.HitResult = std::move(HitResult);
	Parms.Contexts = std::move(Contexts);
	Parms.VFXScale = std::move(VFXScale);
	Parms.AudioVolume = AudioVolume;
	Parms.AudioPitch = AudioPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContextEffectComponent.UpdateEffectContexts
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     NewEffectContexts                                      (Parm, NativeAccessSpecifierPublic)

void UCrContextEffectComponent::UpdateEffectContexts(const struct FGameplayTagContainer& NewEffectContexts)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectComponent", "UpdateEffectContexts");

	Params::CrContextEffectComponent_UpdateEffectContexts Parms{};

	Parms.NewEffectContexts = std::move(NewEffectContexts);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContextEffectComponent.UpdateLibraries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TSet<TSoftObjectPtr<class UCrContextEffectsLibrary>>&NewContextEffectsLibraries                             (Parm, UObjectWrapper, NativeAccessSpecifierPublic)

void UCrContextEffectComponent::UpdateLibraries(const TSet<TSoftObjectPtr<class UCrContextEffectsLibrary>>& NewContextEffectsLibraries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectComponent", "UpdateLibraries");

	Params::CrContextEffectComponent_UpdateLibraries Parms{};

	Parms.NewContextEffectsLibraries = std::move(NewContextEffectsLibraries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.ActivateMachine
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorActivating                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::ActivateMachine(class AActor* ActorActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "ActivateMachine");

	Params::CrMegamachineDoor_ActivateMachine Parms{};

	Parms.ActorActivating = ActorActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.CloseAndLock
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorLocking                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::CloseAndLock(class AActor* ActorLocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "CloseAndLock");

	Params::CrMegamachineDoor_CloseAndLock Parms{};

	Parms.ActorLocking = ActorLocking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.CloseDoor
// (Final, BlueprintAuthorityOnly, Native, Private, BlueprintCallable)

void ACrMegamachineDoor::CloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "CloseDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.GetEmissiveLightColor
// (Final, Native, Private, HasDefaults, BlueprintCallable)
// Parameters:
// EDoorState                              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ACrMegamachineDoor::GetEmissiveLightColor(EDoorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "GetEmissiveLightColor");

	Params::CrMegamachineDoor_GetEmissiveLightColor Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.GetRule
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// EDoorState                              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACrMegamachineDoor::GetRule(EDoorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "GetRule");

	Params::CrMegamachineDoor_GetRule Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.GetTerminalColor
// (Final, Native, Private, HasDefaults, BlueprintCallable)
// Parameters:
// EDoorState                              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ACrMegamachineDoor::GetTerminalColor(EDoorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "GetTerminalColor");

	Params::CrMegamachineDoor_GetTerminalColor Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.GetTerminalIconTexture
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// EDoorState                              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* ACrMegamachineDoor::GetTerminalIconTexture(EDoorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "GetTerminalIconTexture");

	Params::CrMegamachineDoor_GetTerminalIconTexture Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.IsOpened
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDoor::IsOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "IsOpened");

	Params::CrMegamachineDoor_IsOpened Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.LockMachine
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorActivating                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::LockMachine(class AActor* ActorActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "LockMachine");

	Params::CrMegamachineDoor_LockMachine Parms{};

	Parms.ActorActivating = ActorActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.OnFirstTimeOpened
// (Native, Event, Public, BlueprintEvent)

void ACrMegamachineDoor::OnFirstTimeOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "OnFirstTimeOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.OnRep_ExternalLock
// (Final, Native, Public)

void ACrMegamachineDoor::OnRep_ExternalLock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "OnRep_ExternalLock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.OnRep_State_Inside
// (Final, Native, Public)

void ACrMegamachineDoor::OnRep_State_Inside()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "OnRep_State_Inside");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.OnRep_State_Outside
// (Final, Native, Public)

void ACrMegamachineDoor::OnRep_State_Outside()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "OnRep_State_Outside");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.OnUpdateDoorOpenState
// (Native, Event, Public, BlueprintEvent)

void ACrMegamachineDoor::OnUpdateDoorOpenState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "OnUpdateDoorOpenState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.OnUpdateDoorOpenStateImmediate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrMegamachineDoor::OnUpdateDoorOpenStateImmediate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "OnUpdateDoorOpenStateImmediate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.OnUpdateDoorVisuals
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrMegamachineDoor::OnUpdateDoorVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "OnUpdateDoorVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.OpenDoor
// (Final, BlueprintAuthorityOnly, Native, Private, BlueprintCallable)

void ACrMegamachineDoor::OpenDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "OpenDoor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.PlayDoorCloseSound
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDoor::PlayDoorCloseSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "PlayDoorCloseSound");

	Params::CrMegamachineDoor_PlayDoorCloseSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.PlayDoorOpenSound
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDoor::PlayDoorOpenSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "PlayDoorOpenSound");

	Params::CrMegamachineDoor_PlayDoorOpenSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.PlayInteractionSuccessfulSound
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDoor::PlayInteractionSuccessfulSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "PlayInteractionSuccessfulSound");

	Params::CrMegamachineDoor_PlayInteractionSuccessfulSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.PlayInteractionUnSuccessfulSound
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDoor::PlayInteractionUnSuccessfulSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "PlayInteractionUnSuccessfulSound");

	Params::CrMegamachineDoor_PlayInteractionUnSuccessfulSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.ResetGuid
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineDoor::ResetGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "ResetGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.ServerActivateMachine
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           ActorActivating                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::ServerActivateMachine(class AActor* ActorActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "ServerActivateMachine");

	Params::CrMegamachineDoor_ServerActivateMachine Parms{};

	Parms.ActorActivating = ActorActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.ServerCloseAndLock
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           ActorLocking                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::ServerCloseAndLock(class AActor* ActorLocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "ServerCloseAndLock");

	Params::CrMegamachineDoor_ServerCloseAndLock Parms{};

	Parms.ActorLocking = ActorLocking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.ServerLockMachine
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           ActorLocking                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::ServerLockMachine(class AActor* ActorLocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "ServerLockMachine");

	Params::CrMegamachineDoor_ServerLockMachine Parms{};

	Parms.ActorLocking = ActorLocking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.ServerUnlockAndActivate
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           ActorUnlocking                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::ServerUnlockAndActivate(class AActor* ActorUnlocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "ServerUnlockAndActivate");

	Params::CrMegamachineDoor_ServerUnlockAndActivate Parms{};

	Parms.ActorUnlocking = ActorUnlocking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.ServerUnlockMachine
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           ActorActivating                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::ServerUnlockMachine(class AActor* ActorActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "ServerUnlockMachine");

	Params::CrMegamachineDoor_ServerUnlockMachine Parms{};

	Parms.ActorActivating = ActorActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.SetExternalLock
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// bool                                    bInExternalLock                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::SetExternalLock(bool bInExternalLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "SetExternalLock");

	Params::CrMegamachineDoor_SetExternalLock Parms{};

	Parms.bInExternalLock = bInExternalLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.UnlockAndActivate
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorUnlocking                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::UnlockAndActivate(class AActor* ActorUnlocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "UnlockAndActivate");

	Params::CrMegamachineDoor_UnlockAndActivate Parms{};

	Parms.ActorUnlocking = ActorUnlocking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.UnlockMachine
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorUnlocking                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDoor::UnlockMachine(class AActor* ActorUnlocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "UnlockMachine");

	Params::CrMegamachineDoor_UnlockMachine Parms{};

	Parms.ActorUnlocking = ActorUnlocking;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDoor.GetGuid
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid ACrMegamachineDoor::GetGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "GetGuid");

	Params::CrMegamachineDoor_GetGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.GetState
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDoorState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDoorState ACrMegamachineDoor::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "GetState");

	Params::CrMegamachineDoor_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.GetTriggerText
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EDoorState                              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ACrMegamachineDoor::GetTriggerText(EDoorState State) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "GetTriggerText");

	Params::CrMegamachineDoor_GetTriggerText Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDoor.IsWorking
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDoor::IsWorking() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDoor", "IsWorking");

	Params::CrMegamachineDoor_IsWorking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterTraceInterface.GatherAllIgnoredActors
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<class AActor*>*                  OutIgnoredActors                                       (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ICrCharacterTraceInterface::GatherAllIgnoredActors(TArray<class AActor*>* OutIgnoredActors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrCharacterTraceInterface", "GatherAllIgnoredActors");

	Params::CrCharacterTraceInterface_GatherAllIgnoredActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutIgnoredActors != nullptr)
		*OutIgnoredActors = std::move(Parms.OutIgnoredActors);
}


// Function Chimera.CrCharacterBase.IsCharacterGameplayReady
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterBase::IsCharacterGameplayReady() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterBase", "IsCharacterGameplayReady");

	Params::CrCharacterBase_IsCharacterGameplayReady Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInfectionAttributeSet.OnRep_CurrentInfection
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentInfection                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrInfectionAttributeSet::OnRep_CurrentInfection(const struct FGameplayAttributeData& OldCurrentInfection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAttributeSet", "OnRep_CurrentInfection");

	Params::CrInfectionAttributeSet_OnRep_CurrentInfection Parms{};

	Parms.OldCurrentInfection = std::move(OldCurrentInfection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionAttributeSet.OnRep_MaxInfection
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxInfection                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrInfectionAttributeSet::OnRep_MaxInfection(const struct FGameplayAttributeData& OldMaxInfection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAttributeSet", "OnRep_MaxInfection");

	Params::CrInfectionAttributeSet_OnRep_MaxInfection Parms{};

	Parms.OldMaxInfection = std::move(OldMaxInfection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionAttributeSet.OnRep_MinInfection
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinInfection                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrInfectionAttributeSet::OnRep_MinInfection(const struct FGameplayAttributeData& OldMinInfection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAttributeSet", "OnRep_MinInfection");

	Params::CrInfectionAttributeSet_OnRep_MinInfection Parms{};

	Parms.OldMinInfection = std::move(OldMinInfection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.CheckpointReached
// (Final, Native, Public, BlueprintCallable)

void ACrTimelineEvent::CheckpointReached()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "CheckpointReached");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.DespawnAllEnemies
// (Final, Native, Private)

void ACrTimelineEvent::DespawnAllEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "DespawnAllEnemies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.GetProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrTimelineEvent::GetProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "GetProgress");

	Params::CrTimelineEvent_GetProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrTimelineEvent.GetProgressAsSeconds
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrTimelineEvent::GetProgressAsSeconds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "GetProgressAsSeconds");

	Params::CrTimelineEvent_GetProgressAsSeconds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrTimelineEvent.JumpToTimelineNormalized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTimelineEvent::JumpToTimelineNormalized(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "JumpToTimelineNormalized");

	Params::CrTimelineEvent_JumpToTimelineNormalized Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.JumpToTimelineTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTimelineEvent::JumpToTimelineTime(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "JumpToTimelineTime");

	Params::CrTimelineEvent_JumpToTimelineTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.OnCompleted
// (Native, Protected)

void ACrTimelineEvent::OnCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "OnCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.OnPlay
// (Final, Native, Private)

void ACrTimelineEvent::OnPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "OnPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.OnSubtimelineStateChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACrTimelineEvent*                 SubTimeline                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrTimelineState                        State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTimelineEvent::OnSubtimelineStateChanged(class ACrTimelineEvent* SubTimeline, ECrTimelineState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "OnSubtimelineStateChanged");

	Params::CrTimelineEvent_OnSubtimelineStateChanged Parms{};

	Parms.SubTimeline = SubTimeline;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.OnTimelineStateChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACrTimelineEvent*                 Timeline                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrTimelineState                        TimelineState                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTimelineEvent::OnTimelineStateChanged(class ACrTimelineEvent* Timeline, ECrTimelineState TimelineState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "OnTimelineStateChanged");

	Params::CrTimelineEvent_OnTimelineStateChanged Parms{};

	Parms.Timeline = Timeline;
	Parms.TimelineState = TimelineState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.PauseTimeline
// (Final, Native, Public, BlueprintCallable)

void ACrTimelineEvent::PauseTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "PauseTimeline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.PlaySubTimeline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrTimelineEvent*                 Timeline                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTimelineEvent::PlaySubTimeline(class ACrTimelineEvent* Timeline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "PlaySubTimeline");

	Params::CrTimelineEvent_PlaySubTimeline Parms{};

	Parms.Timeline = Timeline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.PlayTimeline
// (Final, Native, Public, BlueprintCallable)

void ACrTimelineEvent::PlayTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "PlayTimeline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.ResetTimeline
// (Final, Native, Public, BlueprintCallable)

void ACrTimelineEvent::ResetTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "ResetTimeline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.ResetToCheckpoint
// (Final, Native, Public, BlueprintCallable)

void ACrTimelineEvent::ResetToCheckpoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "ResetToCheckpoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.StartSpawning
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrAISpawner*                     Spawner                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTimelineEvent::StartSpawning(class ACrAISpawner* Spawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "StartSpawning");

	Params::CrTimelineEvent_StartSpawning Parms{};

	Parms.Spawner = Spawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.StopSpawningEnemies
// (Final, Native, Private)

void ACrTimelineEvent::StopSpawningEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "StopSpawningEnemies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.StopTimeline
// (Final, Native, Public, BlueprintCallable)

void ACrTimelineEvent::StopTimeline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "StopTimeline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTimelineEvent.SubtimelineStateChanged
// (Native, Protected)
// Parameters:
// class ACrTimelineEvent*                 SubTimeline                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrTimelineState                        State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTimelineEvent::SubtimelineStateChanged(class ACrTimelineEvent* SubTimeline, ECrTimelineState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTimelineEvent", "SubtimelineStateChanged");

	Params::CrTimelineEvent_SubtimelineStateChanged Parms{};

	Parms.SubTimeline = SubTimeline;
	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.IsShipping
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsShipping()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrCharacterPlayerBase", "IsShipping");

	Params::CrCharacterPlayerBase_IsShipping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.AddModToEquippedWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UCrWeaponModDataAsset*      InModData                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::AddModToEquippedWeapon(const class UCrWeaponModDataAsset* InModData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "AddModToEquippedWeapon");

	Params::CrCharacterPlayerBase_AddModToEquippedWeapon Parms{};

	Parms.InModData = InModData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.AddPistolToFirstSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::AddPistolToFirstSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "AddPistolToFirstSlot");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ApplyConstantSurvivalEffects
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bRemoveIfExists                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ApplyConstantSurvivalEffects(bool bRemoveIfExists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ApplyConstantSurvivalEffects");

	Params::CrCharacterPlayerBase_ApplyConstantSurvivalEffects Parms{};

	Parms.bRemoveIfExists = bRemoveIfExists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ApplyLoadedGEWithDuration
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FCrActiveGEChangingMaxAttributesValue>*InData                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ApplyLoadedGEWithDuration(TArray<struct FCrActiveGEChangingMaxAttributesValue>* InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ApplyLoadedGEWithDuration");

	Params::CrCharacterPlayerBase_ApplyLoadedGEWithDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InData != nullptr)
		*InData = std::move(Parms.InData);
}


// Function Chimera.CrCharacterPlayerBase.BlockEnergyLoweringDuringSprint
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::BlockEnergyLoweringDuringSprint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "BlockEnergyLoweringDuringSprint");

	Params::CrCharacterPlayerBase_BlockEnergyLoweringDuringSprint Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.BP_GetInventory
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCrInventoryComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrInventoryComponent* ACrCharacterPlayerBase::BP_GetInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "BP_GetInventory");

	Params::CrCharacterPlayerBase_BP_GetInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.BP_OnPlayerEnteredMovingWave
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::BP_OnPlayerEnteredMovingWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "BP_OnPlayerEnteredMovingWave");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.BP_OnPossess
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::BP_OnPossess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "BP_OnPossess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.BP_OnSprintEndedCosmetic
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::BP_OnSprintEndedCosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "BP_OnSprintEndedCosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.BP_OnSprintStartedCosmetic
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::BP_OnSprintStartedCosmetic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "BP_OnSprintStartedCosmetic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.ClientEquipFirstSlotWeapon
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACrCharacterPlayerBase::ClientEquipFirstSlotWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientEquipFirstSlotWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientOnDied
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ClientOnDied(class AActor* InInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientOnDied");

	Params::CrCharacterPlayerBase_ClientOnDied Parms{};

	Parms.InInstigator = InInstigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientOnIncapacitadedStateChanged
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// bool                                    bNowIncapacitated                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Revived                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ClientOnIncapacitadedStateChanged(bool bNowIncapacitated, bool Revived)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientOnIncapacitadedStateChanged");

	Params::CrCharacterPlayerBase_ClientOnIncapacitadedStateChanged Parms{};

	Parms.bNowIncapacitated = bNowIncapacitated;
	Parms.Revived = Revived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientOnInteractionEnded
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ClientOnInteractionEnded(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientOnInteractionEnded");

	Params::CrCharacterPlayerBase_ClientOnInteractionEnded Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientOnInteractionStarted
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ClientOnInteractionStarted(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientOnInteractionStarted");

	Params::CrCharacterPlayerBase_ClientOnInteractionStarted Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientReceiveLastEquippedWeaponPostJoin
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               InLastEquippedSlot                                     (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ClientReceiveLastEquippedWeaponPostJoin(const struct FAuItemSlot& InLastEquippedSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientReceiveLastEquippedWeaponPostJoin");

	Params::CrCharacterPlayerBase_ClientReceiveLastEquippedWeaponPostJoin Parms{};

	Parms.InLastEquippedSlot = std::move(InLastEquippedSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientShowHitmark
// (Net, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrHitmarkType                          HitmarkToShow                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ClientShowHitmark(class AActor* TargetActor, ECrHitmarkType HitmarkToShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientShowHitmark");

	Params::CrCharacterPlayerBase_ClientShowHitmark Parms{};

	Parms.TargetActor = TargetActor;
	Parms.HitmarkToShow = HitmarkToShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientShowRespawnPointSelectionWidget
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACrCharacterPlayerBase::ClientShowRespawnPointSelectionWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientShowRespawnPointSelectionWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientTeleportTo
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FVector&                   DestLocation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  DestRotation                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bIsATest                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNoCheck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ClientTeleportTo(const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bIsATest, bool bNoCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientTeleportTo");

	Params::CrCharacterPlayerBase_ClientTeleportTo Parms{};

	Parms.DestLocation = std::move(DestLocation);
	Parms.DestRotation = std::move(DestRotation);
	Parms.bIsATest = bIsATest;
	Parms.bNoCheck = bNoCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ClientTryEquipWeaponSlotUntilSuccess
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               InSlot                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ClientTryEquipWeaponSlotUntilSuccess(const struct FAuItemSlot& InSlot, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ClientTryEquipWeaponSlotUntilSuccess");

	Params::CrCharacterPlayerBase_ClientTryEquipWeaponSlotUntilSuccess Parms{};

	Parms.InSlot = std::move(InSlot);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ContextualDialogueFinished
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::ContextualDialogueFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ContextualDialogueFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.DebugSlottedWeapons
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::DebugSlottedWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "DebugSlottedWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.EnableUpdateAnimationOnAllSkeletalMeshes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnable                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::EnableUpdateAnimationOnAllSkeletalMeshes(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "EnableUpdateAnimationOnAllSkeletalMeshes");

	Params::CrCharacterPlayerBase_EnableUpdateAnimationOnAllSkeletalMeshes Parms{};

	Parms.bEnable = bEnable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.EnterIncapacitatedState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::EnterIncapacitatedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "EnterIncapacitatedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.EquipLastWeapon
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::EquipLastWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "EquipLastWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.EquipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               Slot                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::EquipWeapon(const struct FAuItemSlot& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "EquipWeapon");

	Params::CrCharacterPlayerBase_EquipWeapon Parms{};

	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.EquipWeaponAfterZipline
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::EquipWeaponAfterZipline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "EquipWeaponAfterZipline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.EquipWeaponOnClientWithDelay
// (Final, Net, NetReliable, Native, Event, Private, NetClient, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               Slot                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::EquipWeaponOnClientWithDelay(const struct FAuItemSlot& Slot, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "EquipWeaponOnClientWithDelay");

	Params::CrCharacterPlayerBase_EquipWeaponOnClientWithDelay Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.EquipWeaponWithDelay
// (Event, Public, BlueprintEvent)
// Parameters:
// const struct FAuItemSlot&               Slot                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::EquipWeaponWithDelay(const struct FAuItemSlot& Slot, float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "EquipWeaponWithDelay");

	Params::CrCharacterPlayerBase_EquipWeaponWithDelay Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCharacterPlayerBase.ExecuteBoxTracesForDropChest
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotator                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   HalfSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bDebug                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::ExecuteBoxTracesForDropChest(const struct FVector& Start, const struct FVector& End, const struct FRotator& Rotator, const struct FVector& HalfSize, TArray<struct FHitResult>* OutHits, bool bDebug)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ExecuteBoxTracesForDropChest");

	Params::CrCharacterPlayerBase_ExecuteBoxTracesForDropChest Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Rotator = std::move(Rotator);
	Parms.HalfSize = std::move(HalfSize);
	Parms.bDebug = bDebug;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.ExitIncapacitatedState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Revived                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ExitIncapacitatedState(bool Revived)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ExitIncapacitatedState");

	Params::CrCharacterPlayerBase_ExitIncapacitatedState Parms{};

	Parms.Revived = Revived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.FastSharedReplication
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FSharedRepMovement&        SharedRepMovement                                      (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::FastSharedReplication(const struct FSharedRepMovement& SharedRepMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "FastSharedReplication");

	Params::CrCharacterPlayerBase_FastSharedReplication Parms{};

	Parms.SharedRepMovement = std::move(SharedRepMovement);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ForceInputWeaponFireRelease
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::ForceInputWeaponFireRelease()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ForceInputWeaponFireRelease");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.GetAllIgnoreActorForLocalInteractionTraces
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ACrCharacterPlayerBase::GetAllIgnoreActorForLocalInteractionTraces()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetAllIgnoreActorForLocalInteractionTraces");

	Params::CrCharacterPlayerBase_GetAllIgnoreActorForLocalInteractionTraces Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCalories
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetCalories()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCalories");

	Params::CrCharacterPlayerBase_GetCalories Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCurrentDoubleJumpEnergyUsage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetCurrentDoubleJumpEnergyUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCurrentDoubleJumpEnergyUsage");

	Params::CrCharacterPlayerBase_GetCurrentDoubleJumpEnergyUsage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCurrentJumpEnergyUsage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetCurrentJumpEnergyUsage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCurrentJumpEnergyUsage");

	Params::CrCharacterPlayerBase_GetCurrentJumpEnergyUsage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetDrain
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetDrain()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetDrain");

	Params::CrCharacterPlayerBase_GetDrain Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetDropItemsLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACrCharacterPlayerBase::GetDropItemsLocation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetDropItemsLocation");

	Params::CrCharacterPlayerBase_GetDropItemsLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetDropItemsLocations
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   LocationsAmount                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> ACrCharacterPlayerBase::GetDropItemsLocations(int32 LocationsAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetDropItemsLocations");

	Params::CrCharacterPlayerBase_GetDropItemsLocations Parms{};

	Parms.LocationsAmount = LocationsAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetHealingRange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetHealingRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetHealingRange");

	Params::CrCharacterPlayerBase_GetHealingRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetHealthAfterRespawnBaseValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetHealthAfterRespawnBaseValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetHealthAfterRespawnBaseValue");

	Params::CrCharacterPlayerBase_GetHealthAfterRespawnBaseValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetHealthAfterRespawnCurrentValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetHealthAfterRespawnCurrentValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetHealthAfterRespawnCurrentValue");

	Params::CrCharacterPlayerBase_GetHealthAfterRespawnCurrentValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetHealthValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetHealthValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetHealthValue");

	Params::CrCharacterPlayerBase_GetHealthValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetHeat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetHeat()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetHeat");

	Params::CrCharacterPlayerBase_GetHeat Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetHydration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetHydration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetHydration");

	Params::CrCharacterPlayerBase_GetHydration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetMaxHealthValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetMaxHealthValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetMaxHealthValue");

	Params::CrCharacterPlayerBase_GetMaxHealthValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetMultiplayerColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ACrCharacterPlayerBase::GetMultiplayerColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetMultiplayerColor");

	Params::CrCharacterPlayerBase_GetMultiplayerColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetShield
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetShield()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetShield");

	Params::CrCharacterPlayerBase_GetShield Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GiveUpAndDie
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ACrCharacterPlayerBase::GiveUpAndDie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GiveUpAndDie");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.GrantDefaultAbilities
// (Final, Native, Public)

void ACrCharacterPlayerBase::GrantDefaultAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GrantDefaultAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.HandleExperienceOnEdibleUse
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ItemExperienceMultiplier                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::HandleExperienceOnEdibleUse(float ItemExperienceMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "HandleExperienceOnEdibleUse");

	Params::CrCharacterPlayerBase_HandleExperienceOnEdibleUse Parms{};

	Parms.ItemExperienceMultiplier = ItemExperienceMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.HandleSulphurGasEnter
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::HandleSulphurGasEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "HandleSulphurGasEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.HandleSulphurGasExit
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::HandleSulphurGasExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "HandleSulphurGasExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.HealPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrCharacterPlayerBase*           PlayerToHeal                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::HealPlayer(class ACrCharacterPlayerBase* PlayerToHeal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "HealPlayer");

	Params::CrCharacterPlayerBase_HealPlayer Parms{};

	Parms.PlayerToHeal = PlayerToHeal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.InitializeAttributesFromData
// (Final, Native, Private)
// Parameters:
// bool                                    bDied                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::InitializeAttributesFromData(bool bDied)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "InitializeAttributesFromData");

	Params::CrCharacterPlayerBase_InitializeAttributesFromData Parms{};

	Parms.bDied = bDied;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.IsBuildingDroneActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsBuildingDroneActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsBuildingDroneActive");

	Params::CrCharacterPlayerBase_IsBuildingDroneActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsLocationInInterior
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsLocationInInterior(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsLocationInInterior");

	Params::CrCharacterPlayerBase_IsLocationInInterior Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsOnLadder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   bIsOnMassEntityLadder                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsOnLadder(bool* bIsOnMassEntityLadder)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsOnLadder");

	Params::CrCharacterPlayerBase_IsOnLadder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bIsOnMassEntityLadder != nullptr)
		*bIsOnMassEntityLadder = Parms.bIsOnMassEntityLadder;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsProfessionAvailable
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EProfessionType                         ProfessionToCheck                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsProfessionAvailable(EProfessionType ProfessionToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsProfessionAvailable");

	Params::CrCharacterPlayerBase_IsProfessionAvailable Parms{};

	Parms.ProfessionToCheck = ProfessionToCheck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsProtected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsProtected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsProtected");

	Params::CrCharacterPlayerBase_IsProtected Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.K2_ClientOnInteractionEnded
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::K2_ClientOnInteractionEnded(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "K2_ClientOnInteractionEnded");

	Params::CrCharacterPlayerBase_K2_ClientOnInteractionEnded Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.K2_ClientOnInteractionStarted
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::K2_ClientOnInteractionStarted(class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "K2_ClientOnInteractionStarted");

	Params::CrCharacterPlayerBase_K2_ClientOnInteractionStarted Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.LocalEquipFirstSlotWeapon
// (Native, Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::LocalEquipFirstSlotWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "LocalEquipFirstSlotWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastCancelTool
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ACrCharacterPlayerBase::MulticastCancelTool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastCancelTool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastEnterIncapacitatedState
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrCharacterPlayerBase::MulticastEnterIncapacitatedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastEnterIncapacitatedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastEquipLastWeapon
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrCharacterPlayerBase::MulticastEquipLastWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastEquipLastWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastEquipWeaponByInputTag
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FGameplayTag&              InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::MulticastEquipWeaponByInputTag(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastEquipWeaponByInputTag");

	Params::CrCharacterPlayerBase_MulticastEquipWeaponByInputTag Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastEquipWeaponBySlot
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               Slot                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::MulticastEquipWeaponBySlot(const struct FAuItemSlot& Slot, bool bSkipOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastEquipWeaponBySlot");

	Params::CrCharacterPlayerBase_MulticastEquipWeaponBySlot Parms{};

	Parms.Slot = std::move(Slot);
	Parms.bSkipOwner = bSkipOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastExitIncapacitatedState
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// bool                                    Revived                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::MulticastExitIncapacitatedState(bool Revived)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastExitIncapacitatedState");

	Params::CrCharacterPlayerBase_MulticastExitIncapacitatedState Parms{};

	Parms.Revived = Revived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastOnEnteredMovingWave
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ACrCharacterPlayerBase::MulticastOnEnteredMovingWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastOnEnteredMovingWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastOnExitSpawnPoint
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrCharacterPlayerBase::MulticastOnExitSpawnPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastOnExitSpawnPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastOnPlayerTeleported
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FCrMassEntityReplicationHelper&SourceTeleporter                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassEntityReplicationHelper&TargetTeleporter                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::MulticastOnPlayerTeleported(const struct FCrMassEntityReplicationHelper& SourceTeleporter, const struct FCrMassEntityReplicationHelper& TargetTeleporter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastOnPlayerTeleported");

	Params::CrCharacterPlayerBase_MulticastOnPlayerTeleported Parms{};

	Parms.SourceTeleporter = std::move(SourceTeleporter);
	Parms.TargetTeleporter = std::move(TargetTeleporter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastOnZiplineModeCancelled
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrCharacterPlayerBase::MulticastOnZiplineModeCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastOnZiplineModeCancelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastOnZiplineTravelStarted
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrCharacterPlayerBase::MulticastOnZiplineTravelStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastOnZiplineTravelStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastPlayDeconstructionSound
// (Net, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::MulticastPlayDeconstructionSound(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastPlayDeconstructionSound");

	Params::CrCharacterPlayerBase_MulticastPlayDeconstructionSound Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastPlayDialogue
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const class UDialogueWave*              Dialogue                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDialogueContext&          Context                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::MulticastPlayDialogue(const class UDialogueWave* Dialogue, const struct FDialogueContext& Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastPlayDialogue");

	Params::CrCharacterPlayerBase_MulticastPlayDialogue Parms{};

	Parms.Dialogue = Dialogue;
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastSendGameplayEvent
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEventData&        Payload                                                (Parm, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::MulticastSendGameplayEvent(const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastSendGameplayEvent");

	Params::CrCharacterPlayerBase_MulticastSendGameplayEvent Parms{};

	Parms.EventTag = std::move(EventTag);
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastSetOccupiedSpawnPoint
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACrCharacterSpawnPointBase*       InNewSpawnPoint                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::MulticastSetOccupiedSpawnPoint(class ACrCharacterSpawnPointBase* InNewSpawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastSetOccupiedSpawnPoint");

	Params::CrCharacterPlayerBase_MulticastSetOccupiedSpawnPoint Parms{};

	Parms.InNewSpawnPoint = InNewSpawnPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.MulticastSkipCurrentDialogue
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ACrCharacterPlayerBase::MulticastSkipCurrentDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "MulticastSkipCurrentDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.NativeOnEquipWeaponByInputTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::NativeOnEquipWeaponByInputTag(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "NativeOnEquipWeaponByInputTag");

	Params::CrCharacterPlayerBase_NativeOnEquipWeaponByInputTag Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnBPStartOccupyingSpawnPoint
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::OnBPStartOccupyingSpawnPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnBPStartOccupyingSpawnPoint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.OnCameraChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bFirstPersonView                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnCameraChanged(bool bFirstPersonView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnCameraChanged");

	Params::CrCharacterPlayerBase_OnCameraChanged Parms{};

	Parms.bFirstPersonView = bFirstPersonView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnDashMovementModeChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsDoingDash                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnDashMovementModeChanged(bool bIsDoingDash)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnDashMovementModeChanged");

	Params::CrCharacterPlayerBase_OnDashMovementModeChanged Parms{};

	Parms.bIsDoingDash = bIsDoingDash;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnDatapadRead
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACrDatapadBase*                   Datapad                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EntryName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnDatapadRead(class ACrDatapadBase* Datapad, class FName EntryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnDatapadRead");

	Params::CrCharacterPlayerBase_OnDatapadRead Parms{};

	Parms.Datapad = Datapad;
	Parms.EntryName = EntryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnDefaultWeaponsLoaded
// (Final, Native, Public)

void ACrCharacterPlayerBase::OnDefaultWeaponsLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnDefaultWeaponsLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnDied
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::OnDied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnDied");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.OnDoubleJumpFailedOfEnergyCost
// (Native, Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::OnDoubleJumpFailedOfEnergyCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnDoubleJumpFailedOfEnergyCost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnEnterIncapacitatedState
// (Native, Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::OnEnterIncapacitatedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnEnterIncapacitatedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnExitSpawnPoint
// (Final, Native, Public)

void ACrCharacterPlayerBase::OnExitSpawnPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnExitSpawnPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnExitSpawnPointBP
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::OnExitSpawnPointBP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnExitSpawnPointBP");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.OnHealingEnd
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::OnHealingEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnHealingEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnHealingStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSelf                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnHealingStart(float Duration, bool bSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnHealingStart");

	Params::CrCharacterPlayerBase_OnHealingStart Parms{};

	Parms.Duration = Duration;
	Parms.bSelf = bSelf;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnIncapacitadedStateChanged
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bNowIncapacitated                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Revived                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnIncapacitadedStateChanged(bool bNowIncapacitated, bool Revived)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnIncapacitadedStateChanged");

	Params::CrCharacterPlayerBase_OnIncapacitadedStateChanged Parms{};

	Parms.bNowIncapacitated = bNowIncapacitated;
	Parms.Revived = Revived;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnInputModeChanged
// (Final, Native, Private)
// Parameters:
// ECommonInputMode                        InputMode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnInputModeChanged(ECommonInputMode InputMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnInputModeChanged");

	Params::CrCharacterPlayerBase_OnInputModeChanged Parms{};

	Parms.InputMode = InputMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnItemEaten
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCrEdibleItemBase*                EdibleItem                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnItemEaten(class UCrEdibleItemBase* EdibleItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnItemEaten");

	Params::CrCharacterPlayerBase_OnItemEaten Parms{};

	Parms.EdibleItem = EdibleItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnMultiplayerColorChanged
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FLinearColor&              NewColor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnMultiplayerColorChanged(const struct FLinearColor& NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnMultiplayerColorChanged");

	Params::CrCharacterPlayerBase_OnMultiplayerColorChanged Parms{};

	Parms.NewColor = std::move(NewColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCharacterPlayerBase.OnProfessionChanged
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::OnProfessionChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnProfessionChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRep_BeingHealed
// (Final, Native, Public)

void ACrCharacterPlayerBase::OnRep_BeingHealed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRep_BeingHealed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRep_Drone
// (Final, Native, Private)

void ACrCharacterPlayerBase::OnRep_Drone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRep_Drone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRep_HeatStackCount
// (Final, Native, Public)

void ACrCharacterPlayerBase::OnRep_HeatStackCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRep_HeatStackCount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRep_InteractionState
// (Final, Native, Private)

void ACrCharacterPlayerBase::OnRep_InteractionState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRep_InteractionState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRep_IsDisabledPawn
// (Final, Native, Private)

void ACrCharacterPlayerBase::OnRep_IsDisabledPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRep_IsDisabledPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRep_IsSprintActive
// (Final, Native, Private)

void ACrCharacterPlayerBase::OnRep_IsSprintActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRep_IsSprintActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRep_MultiplayerColor
// (Final, Native, Private)

void ACrCharacterPlayerBase::OnRep_MultiplayerColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRep_MultiplayerColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRep_Profession
// (Final, Native, Public)

void ACrCharacterPlayerBase::OnRep_Profession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRep_Profession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnRepDead
// (Final, Native, Public)

void ACrCharacterPlayerBase::OnRepDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRepDead");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnReplicatedHeatStackCount
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHarvesterRepHeatStackInfo&OutCurrentHarvesterHeatStack                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnReplicatedHeatStackCount(const struct FHarvesterRepHeatStackInfo& OutCurrentHarvesterHeatStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnReplicatedHeatStackCount");

	Params::CrCharacterPlayerBase_OnReplicatedHeatStackCount Parms{};

	Parms.OutCurrentHarvesterHeatStack = std::move(OutCurrentHarvesterHeatStack);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCharacterPlayerBase.OnRespawn
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACrCharacterPlayerBase::OnRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRespawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.OnRespawned
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrCharacterPlayerBase::OnRespawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnRespawned");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnServerCancelTool
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ACrCharacterPlayerBase::OnServerCancelTool()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnServerCancelTool");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnServerEquipWeaponByInputTag
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FGameplayTag&              InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnServerEquipWeaponByInputTag(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnServerEquipWeaponByInputTag");

	Params::CrCharacterPlayerBase_OnServerEquipWeaponByInputTag Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnServerSetFlashlightActive
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnServerSetFlashlightActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnServerSetFlashlightActive");

	Params::CrCharacterPlayerBase_OnServerSetFlashlightActive Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnServerSetFlashlightMode
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnServerSetFlashlightMode(int32 Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnServerSetFlashlightMode");

	Params::CrCharacterPlayerBase_OnServerSetFlashlightMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnSlideMovementModeChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    IsSliding                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnSlideMovementModeChanged(bool IsSliding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnSlideMovementModeChanged");

	Params::CrCharacterPlayerBase_OnSlideMovementModeChanged Parms{};

	Parms.IsSliding = IsSliding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnStartOccupyingSpawnPoint
// (Final, Net, Native, Event, NetMulticast, Private)

void ACrCharacterPlayerBase::OnStartOccupyingSpawnPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnStartOccupyingSpawnPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnUnlockedFeaturesChanged
// (Final, Native, Public)
// Parameters:
// const TArray<ECrCorporationUnlockedFeatures>&UnlockedFeatures                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnUnlockedFeaturesChanged(const TArray<ECrCorporationUnlockedFeatures>& UnlockedFeatures)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnUnlockedFeaturesChanged");

	Params::CrCharacterPlayerBase_OnUnlockedFeaturesChanged Parms{};

	Parms.UnlockedFeatures = std::move(UnlockedFeatures);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnUnlockedInventorySlotsChanged
// (Final, Native, Public)
// Parameters:
// int32                                   AllAdditionalSlots                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnUnlockedInventorySlotsChanged(int32 AllAdditionalSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnUnlockedInventorySlotsChanged");

	Params::CrCharacterPlayerBase_OnUnlockedInventorySlotsChanged Parms{};

	Parms.AllAdditionalSlots = AllAdditionalSlots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnWaveCanceled
// (Final, Native, Private, HasOutParams)
// Parameters:
// EEnviroWave                             Wave                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        Stage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnWaveCanceled(EEnviroWave Wave, EEnviroWaveStage Stage, const struct FCrEnviroWaveSettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnWaveCanceled");

	Params::CrCharacterPlayerBase_OnWaveCanceled Parms{};

	Parms.Wave = Wave;
	Parms.Stage = Stage;
	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnWaveFinished
// (Final, Native, Private, HasOutParams)
// Parameters:
// EEnviroWave                             Wave                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnWaveFinished(EEnviroWave Wave, const struct FCrEnviroWaveSettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnWaveFinished");

	Params::CrCharacterPlayerBase_OnWaveFinished Parms{};

	Parms.Wave = Wave;
	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnWavePositionChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// EEnviroWave                             Wave                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnWavePositionChanged(EEnviroWave Wave, const struct FCrEnviroWaveSettings& Settings, float Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnWavePositionChanged");

	Params::CrCharacterPlayerBase_OnWavePositionChanged Parms{};

	Parms.Wave = Wave;
	Parms.Settings = std::move(Settings);
	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnWaveStarted
// (Final, Native, Private, HasOutParams)
// Parameters:
// EEnviroWave                             Wave                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        Stage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   StageProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnWaveStarted(EEnviroWave Wave, EEnviroWaveStage Stage, const struct FCrEnviroWaveSettings& Settings, float StageProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnWaveStarted");

	Params::CrCharacterPlayerBase_OnWaveStarted Parms{};

	Parms.Wave = Wave;
	Parms.Stage = Stage;
	Parms.Settings = std::move(Settings);
	Parms.StageProgress = StageProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnWaveSubstageChanged
// (Final, Native, Private)
// Parameters:
// const struct FGameplayTag&              SubstageTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnWaveSubstageChanged(const struct FGameplayTag& SubstageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnWaveSubstageChanged");

	Params::CrCharacterPlayerBase_OnWaveSubstageChanged Parms{};

	Parms.SubstageTag = std::move(SubstageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnWeaponCycled
// (Final, Native, Protected)

void ACrCharacterPlayerBase::OnWeaponCycled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnWeaponCycled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnWeaponUsed
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FAuEquippedWeapon&         EquippedWeapon                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnWeaponUsed(const struct FAuEquippedWeapon& EquippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnWeaponUsed");

	Params::CrCharacterPlayerBase_OnWeaponUsed Parms{};

	Parms.EquippedWeapon = std::move(EquippedWeapon);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnZipLineMovementModeChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    OnZipline                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::OnZipLineMovementModeChanged(bool OnZipline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnZipLineMovementModeChanged");

	Params::CrCharacterPlayerBase_OnZipLineMovementModeChanged Parms{};

	Parms.OnZipline = OnZipline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.OnZiplineTravelCancelled
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::OnZiplineTravelCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnZiplineTravelCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.OnZiplineTravelEnded
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::OnZiplineTravelEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnZiplineTravelEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.OnZiplineTravelStarted
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::OnZiplineTravelStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "OnZiplineTravelStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.PostRespawn
// (Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::PostRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "PostRespawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCharacterPlayerBase.RemoveADSTagFromSelf
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::RemoveADSTagFromSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "RemoveADSTagFromSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.RemoveModFromEquippedWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UCrWeaponModDataAsset*      InModData                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::RemoveModFromEquippedWeapon(const class UCrWeaponModDataAsset* InModData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "RemoveModFromEquippedWeapon");

	Params::CrCharacterPlayerBase_RemoveModFromEquippedWeapon Parms{};

	Parms.InModData = InModData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ResetCharacterDataAfterCustomPossession
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::ResetCharacterDataAfterCustomPossession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ResetCharacterDataAfterCustomPossession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ResetCharacterDataAfterDeath
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::ResetCharacterDataAfterDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ResetCharacterDataAfterDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ResetWeaponsAfterDeath
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::ResetWeaponsAfterDeath()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ResetWeaponsAfterDeath");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SampleLookingBuilding
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::SampleLookingBuilding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SampleLookingBuilding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.Server_OnSprintEnded
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ACrCharacterPlayerBase::Server_OnSprintEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "Server_OnSprintEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.Server_OnSprintStarted
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void ACrCharacterPlayerBase::Server_OnSprintStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "Server_OnSprintStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.Server_SetDLCInstalled
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// ECrDLCId                                DlcId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::Server_SetDLCInstalled(ECrDLCId DlcId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "Server_SetDLCInstalled");

	Params::CrCharacterPlayerBase_Server_SetDLCInstalled Parms{};

	Parms.DlcId = DlcId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.Server_SetInitialEventsExecuted
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::Server_SetInitialEventsExecuted(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "Server_SetInitialEventsExecuted");

	Params::CrCharacterPlayerBase_Server_SetInitialEventsExecuted Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerAddItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class UAuItemDataBase*            InItem                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerAddItem(const class UAuItemDataBase* InItem, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerAddItem");

	Params::CrCharacterPlayerBase_ServerAddItem Parms{};

	Parms.InItem = InItem;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerAddItems
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TArray<struct FCrCountItem>&      InItemsToAdd                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bSpawnChestIfNoSpace                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerAddItems(const TArray<struct FCrCountItem>& InItemsToAdd, bool bSpawnChestIfNoSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerAddItems");

	Params::CrCharacterPlayerBase_ServerAddItems Parms{};

	Parms.InItemsToAdd = std::move(InItemsToAdd);
	Parms.bSpawnChestIfNoSpace = bSpawnChestIfNoSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerAddModToEquippedWeapon
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class UCrWeaponModDataAsset*      InModData                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerAddModToEquippedWeapon(const class UCrWeaponModDataAsset* InModData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerAddModToEquippedWeapon");

	Params::CrCharacterPlayerBase_ServerAddModToEquippedWeapon Parms{};

	Parms.InModData = InModData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerCheckGemEffects
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 RemovedSlot                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerCheckGemEffects(const struct FCrSlotId& RemovedSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerCheckGemEffects");

	Params::CrCharacterPlayerBase_ServerCheckGemEffects Parms{};

	Parms.RemovedSlot = std::move(RemovedSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerDebugSetGemStacks
// (Net, Native, Event, Public, NetServer)
// Parameters:
// TSubclassOf<class UCrGemItemData>       GemItem                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerDebugSetGemStacks(TSubclassOf<class UCrGemItemData> GemItem, int32 Stacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerDebugSetGemStacks");

	Params::CrCharacterPlayerBase_ServerDebugSetGemStacks Parms{};

	Parms.GemItem = GemItem;
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerDisablePawn
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// bool                                    bDisable                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerDisablePawn(bool bDisable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerDisablePawn");

	Params::CrCharacterPlayerBase_ServerDisablePawn Parms{};

	Parms.bDisable = bDisable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerEquipLastWeapon
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerEquipLastWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerEquipLastWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerEquipWeaponBySlot
// (Final, Net, NetReliable, Native, Event, Private, NetServer, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               Slot                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSkipOwner                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerEquipWeaponBySlot(const struct FAuItemSlot& Slot, bool bSkipOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerEquipWeaponBySlot");

	Params::CrCharacterPlayerBase_ServerEquipWeaponBySlot Parms{};

	Parms.Slot = std::move(Slot);
	Parms.bSkipOwner = bSkipOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerExecuteUnstackKill
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ACrCharacterPlayerBase::ServerExecuteUnstackKill()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerExecuteUnstackKill");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerHandleSulphurGasEnter
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerHandleSulphurGasEnter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerHandleSulphurGasEnter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerHandleSulphurGasExit
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerHandleSulphurGasExit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerHandleSulphurGasExit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerHealPlayer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACrCharacterPlayerBase*           PlayerToHeal                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerHealPlayer(class ACrCharacterPlayerBase* PlayerToHeal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerHealPlayer");

	Params::CrCharacterPlayerBase_ServerHealPlayer Parms{};

	Parms.PlayerToHeal = PlayerToHeal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnBuildingDroneActivated
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerOnBuildingDroneActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnBuildingDroneActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnBuildingDroneDeactivated
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerOnBuildingDroneDeactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnBuildingDroneDeactivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnEnteredGEBoxApplyEffects
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TArray<TSubclassOf<class UCrGameplayEffect>>&InGameplayEffectsToApply                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerOnEnteredGEBoxApplyEffects(const TArray<TSubclassOf<class UCrGameplayEffect>>& InGameplayEffectsToApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnEnteredGEBoxApplyEffects");

	Params::CrCharacterPlayerBase_ServerOnEnteredGEBoxApplyEffects Parms{};

	Parms.InGameplayEffectsToApply = std::move(InGameplayEffectsToApply);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnExitGEBoxApplyEffects
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TArray<TSubclassOf<class UCrGameplayEffect>>&InGameplayEffectsToRemove                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerOnExitGEBoxApplyEffects(const TArray<TSubclassOf<class UCrGameplayEffect>>& InGameplayEffectsToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnExitGEBoxApplyEffects");

	Params::CrCharacterPlayerBase_ServerOnExitGEBoxApplyEffects Parms{};

	Parms.InGameplayEffectsToRemove = std::move(InGameplayEffectsToRemove);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnExitSpawnPoint
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerOnExitSpawnPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnExitSpawnPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnPlayerEnterAFK
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerOnPlayerEnterAFK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnPlayerEnterAFK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnPlayerExitAFK
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerOnPlayerExitAFK()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnPlayerExitAFK");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnZiplineModeCancelled
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerOnZiplineModeCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnZiplineModeCancelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerOnZiplineTravelStarted
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerOnZiplineTravelStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerOnZiplineTravelStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerPlayDeconstructionSound
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerPlayDeconstructionSound(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerPlayDeconstructionSound");

	Params::CrCharacterPlayerBase_ServerPlayDeconstructionSound Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerRemoveGemEffects
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerRemoveGemEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerRemoveGemEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerRemoveModToEquippedWeapon
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class UCrWeaponModDataAsset*      InModData                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerRemoveModToEquippedWeapon(const class UCrWeaponModDataAsset* InModData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerRemoveModToEquippedWeapon");

	Params::CrCharacterPlayerBase_ServerRemoveModToEquippedWeapon Parms{};

	Parms.InModData = InModData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSetDiscoveredBuildings
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TArray<int32>&                    InData                                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerSetDiscoveredBuildings(const TArray<int32>& InData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSetDiscoveredBuildings");

	Params::CrCharacterPlayerBase_ServerSetDiscoveredBuildings Parms{};

	Parms.InData = std::move(InData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSetInElevator
// (Net, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bInElevator                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerSetInElevator(bool bInElevator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSetInElevator");

	Params::CrCharacterPlayerBase_ServerSetInElevator Parms{};

	Parms.bInElevator = bInElevator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSetInInterior
// (Net, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bNewInInterior                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewInSafeInterior                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerSetInInterior(bool bNewInInterior, bool bNewInSafeInterior)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSetInInterior");

	Params::CrCharacterPlayerBase_ServerSetInInterior Parms{};

	Parms.bNewInInterior = bNewInInterior;
	Parms.bNewInSafeInterior = bNewInSafeInterior;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSetMaxWalkSpeed
// (Net, Native, Event, Public, NetServer)
// Parameters:
// float                                   NewMaxWalkSpeed                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerSetMaxWalkSpeed(float NewMaxWalkSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSetMaxWalkSpeed");

	Params::CrCharacterPlayerBase_ServerSetMaxWalkSpeed Parms{};

	Parms.NewMaxWalkSpeed = NewMaxWalkSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSetMultiplayerColor
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FLinearColor&              NewColor                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerSetMultiplayerColor(const struct FLinearColor& NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSetMultiplayerColor");

	Params::CrCharacterPlayerBase_ServerSetMultiplayerColor Parms{};

	Parms.NewColor = std::move(NewColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSetOccupiedSpawnPoint
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACrCharacterSpawnPointBase*       InNewSpawnPoint                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerSetOccupiedSpawnPoint(class ACrCharacterSpawnPointBase* InNewSpawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSetOccupiedSpawnPoint");

	Params::CrCharacterPlayerBase_ServerSetOccupiedSpawnPoint Parms{};

	Parms.InNewSpawnPoint = InNewSpawnPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSetProfession
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// EProfessionType                         NewProfession                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerSetProfession(EProfessionType NewProfession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSetProfession");

	Params::CrCharacterPlayerBase_ServerSetProfession Parms{};

	Parms.NewProfession = NewProfession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSkipCurrentDialogue
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void ACrCharacterPlayerBase::ServerSkipCurrentDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSkipCurrentDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerStartBuildingDrone
// (Net, NetReliable, Native, Event, Protected, NetServer, HasDefaults)
// Parameters:
// class ACrPlayerControllerBase*          InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerStartBuildingDrone(class ACrPlayerControllerBase* InPc, const struct FVector& StartLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerStartBuildingDrone");

	Params::CrCharacterPlayerBase_ServerStartBuildingDrone Parms{};

	Parms.InPc = InPc;
	Parms.StartLocation = std::move(StartLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerStartHealing
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACrCharacterPlayerBase*           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerStartHealing(class ACrCharacterPlayerBase* Target, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerStartHealing");

	Params::CrCharacterPlayerBase_ServerStartHealing Parms{};

	Parms.Target = Target;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerStopBuildingDrone
// (Net, NetReliable, Native, Event, Protected, NetServer)

void ACrCharacterPlayerBase::ServerStopBuildingDrone()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerStopBuildingDrone");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerStopHealing
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACrCharacterPlayerBase*           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerStopHealing(class ACrCharacterPlayerBase* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerStopHealing");

	Params::CrCharacterPlayerBase_ServerStopHealing Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerSwitchCamera
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// bool                                    bFirstPersonView                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ServerSwitchCamera(bool bFirstPersonView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerSwitchCamera");

	Params::CrCharacterPlayerBase_ServerSwitchCamera Parms{};

	Parms.bFirstPersonView = bFirstPersonView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ServerTeleportToUnoccupiedSpawnPoint
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterPlayerBase::ServerTeleportToUnoccupiedSpawnPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ServerTeleportToUnoccupiedSpawnPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetBuildingToolLastParameters
// (Final, Native, Public)
// Parameters:
// class UCrBuildingData*                  InBuilding                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bDeconstruct                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetBuildingToolLastParameters(class UCrBuildingData* InBuilding, bool bDeconstruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetBuildingToolLastParameters");

	Params::CrCharacterPlayerBase_SetBuildingToolLastParameters Parms{};

	Parms.InBuilding = InBuilding;
	Parms.bDeconstruct = bDeconstruct;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetCharacterSelectedAndInitialized
// (Final, Native, Public)
// Parameters:
// bool                                    bNewInitialized                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetCharacterSelectedAndInitialized(bool bNewInitialized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetCharacterSelectedAndInitialized");

	Params::CrCharacterPlayerBase_SetCharacterSelectedAndInitialized Parms{};

	Parms.bNewInitialized = bNewInitialized;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetCosmeticTags
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     CosmeticTagsOverride                                   (Parm, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetCosmeticTags(const struct FGameplayTagContainer& CosmeticTagsOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetCosmeticTags");

	Params::CrCharacterPlayerBase_SetCosmeticTags Parms{};

	Parms.CosmeticTagsOverride = std::move(CosmeticTagsOverride);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetCurrentAimingTarget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetCurrentAimingTarget(class AActor* NewTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetCurrentAimingTarget");

	Params::CrCharacterPlayerBase_SetCurrentAimingTarget Parms{};

	Parms.NewTarget = NewTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetDeconstruct
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bInDeconstruct                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetDeconstruct(bool bInDeconstruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetDeconstruct");

	Params::CrCharacterPlayerBase_SetDeconstruct Parms{};

	Parms.bInDeconstruct = bInDeconstruct;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCharacterPlayerBase.SetdEncyclopediaChaptersInfoReadServer
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FGuid&                     EntryID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ChaptersRead                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Read                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetdEncyclopediaChaptersInfoReadServer(const struct FGuid& EntryID, uint8 ChaptersRead, bool Read)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetdEncyclopediaChaptersInfoReadServer");

	Params::CrCharacterPlayerBase_SetdEncyclopediaChaptersInfoReadServer Parms{};

	Parms.EntryID = std::move(EntryID);
	Parms.ChaptersRead = ChaptersRead;
	Parms.Read = Read;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetDialogueVoice
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDialogueVoice*                   NewVoice                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetDialogueVoice(class UDialogueVoice* NewVoice)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetDialogueVoice");

	Params::CrCharacterPlayerBase_SetDialogueVoice Parms{};

	Parms.NewVoice = NewVoice;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetFppLegsVisibility
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    NewVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetFppLegsVisibility(bool NewVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetFppLegsVisibility");

	Params::CrCharacterPlayerBase_SetFppLegsVisibility Parms{};

	Parms.NewVisible = NewVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetGivingUpTimeProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetGivingUpTimeProgress(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetGivingUpTimeProgress");

	Params::CrCharacterPlayerBase_SetGivingUpTimeProgress Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetOccupiedSpawnPoint
// (Final, Native, Public)
// Parameters:
// class ACrCharacterSpawnPointBase*       InNewSpawnPoint                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetOccupiedSpawnPoint(class ACrCharacterSpawnPointBase* InNewSpawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetOccupiedSpawnPoint");

	Params::CrCharacterPlayerBase_SetOccupiedSpawnPoint Parms{};

	Parms.InNewSpawnPoint = InNewSpawnPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetOnLadder
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsOnLadder                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACrBuildingActorBase*             LadderActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetOnLadder(bool bIsOnLadder, class ACrBuildingActorBase* LadderActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetOnLadder");

	Params::CrCharacterPlayerBase_SetOnLadder Parms{};

	Parms.bIsOnLadder = bIsOnLadder;
	Parms.LadderActor = LadderActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetOnWeaponCycledTimer
// (Final, Native, Public)
// Parameters:
// float                                   InWeaponCycleDuration                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetOnWeaponCycledTimer(float InWeaponCycleDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetOnWeaponCycledTimer");

	Params::CrCharacterPlayerBase_SetOnWeaponCycledTimer Parms{};

	Parms.InWeaponCycleDuration = InWeaponCycleDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetPlacementMode
// (Final, Native, Public)
// Parameters:
// bool                                    bTerrain                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetPlacementMode(bool bTerrain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetPlacementMode");

	Params::CrCharacterPlayerBase_SetPlacementMode Parms{};

	Parms.bTerrain = bTerrain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SetProfession
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EProfessionType                         NewProfession                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::SetProfession(EProfessionType NewProfession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetProfession");

	Params::CrCharacterPlayerBase_SetProfession Parms{};

	Parms.NewProfession = NewProfession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.SetSprintHeld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInSprintHeld                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::SetSprintHeld(bool bInSprintHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SetSprintHeld");

	Params::CrCharacterPlayerBase_SetSprintHeld Parms{};

	Parms.bInSprintHeld = bInSprintHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.ShowHitmark
// (BlueprintCosmetic, Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrHitmarkType                          HitmarkToShow                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::ShowHitmark(class AActor* TargetActor, ECrHitmarkType HitmarkToShow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ShowHitmark");

	Params::CrCharacterPlayerBase_ShowHitmark Parms{};

	Parms.TargetActor = TargetActor;
	Parms.HitmarkToShow = HitmarkToShow;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SkipCurrentDialogue
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::SkipCurrentDialogue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SkipCurrentDialogue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.SkipCurrentDialogueInternal
// (Native, Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::SkipCurrentDialogueInternal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "SkipCurrentDialogueInternal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.StartHealing
// (Final, Native, Public)
// Parameters:
// class ACrCharacterPlayerBase*           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::StartHealing(class ACrCharacterPlayerBase* Target, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "StartHealing");

	Params::CrCharacterPlayerBase_StartHealing Parms{};

	Parms.Target = Target;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.StopHealing
// (Final, Native, Public)
// Parameters:
// class ACrCharacterPlayerBase*           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::StopHealing(class ACrCharacterPlayerBase* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "StopHealing");

	Params::CrCharacterPlayerBase_StopHealing Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.TeleportToUnoccupiedSpawnPoint
// (Final, Native, Public)

void ACrCharacterPlayerBase::TeleportToUnoccupiedSpawnPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "TeleportToUnoccupiedSpawnPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.TryEquipWeaponSlotUntilSuccess
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FAuItemSlot&               InSlot                                                 (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Timeout                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::TryEquipWeaponSlotUntilSuccess(const struct FAuItemSlot& InSlot, float Timeout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "TryEquipWeaponSlotUntilSuccess");

	Params::CrCharacterPlayerBase_TryEquipWeaponSlotUntilSuccess Parms{};

	Parms.InSlot = std::move(InSlot);
	Parms.Timeout = Timeout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.UnEquipWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::UnEquipWeapon(bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "UnEquipWeapon");

	Params::CrCharacterPlayerBase_UnEquipWeapon Parms{};

	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.UnEquipWeaponOnZipline
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterPlayerBase::UnEquipWeaponOnZipline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "UnEquipWeaponOnZipline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.UpdateCharacterCollisionBasedOnDeadStatus
// (Native, Event, Public, BlueprintEvent)

void ACrCharacterPlayerBase::UpdateCharacterCollisionBasedOnDeadStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "UpdateCharacterCollisionBasedOnDeadStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.UpdateCharacterCosmeticsForCurrentProfession
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::UpdateCharacterCosmeticsForCurrentProfession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "UpdateCharacterCosmeticsForCurrentProfession");

	Params::CrCharacterPlayerBase_UpdateCharacterCosmeticsForCurrentProfession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.BP_GetRecoilComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrRecoilComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrRecoilComponent* ACrCharacterPlayerBase::BP_GetRecoilComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "BP_GetRecoilComponent");

	Params::CrCharacterPlayerBase_BP_GetRecoilComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.BP_GetWeaponComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrWeaponComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrWeaponComponent* ACrCharacterPlayerBase::BP_GetWeaponComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "BP_GetWeaponComponent");

	Params::CrCharacterPlayerBase_BP_GetWeaponComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.CanUnequipWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::CanUnequipWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "CanUnequipWeapon");

	Params::CrCharacterPlayerBase_CanUnequipWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetAbilitySystemComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAbilitySystemComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* ACrCharacterPlayerBase::GetAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetAbilitySystemComponent");

	Params::CrCharacterPlayerBase_GetAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetActiveGEWithDuration
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FCrActiveGEChangingMaxAttributesValue>*OutData                                                (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::GetActiveGEWithDuration(TArray<struct FCrActiveGEChangingMaxAttributesValue>* OutData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetActiveGEWithDuration");

	Params::CrCharacterPlayerBase_GetActiveGEWithDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);
}


// Function Chimera.CrCharacterPlayerBase.GetAttenuationFPP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundAttenuation*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundAttenuation* ACrCharacterPlayerBase::GetAttenuationFPP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetAttenuationFPP");

	Params::CrCharacterPlayerBase_GetAttenuationFPP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetAttenuationTPP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundAttenuation*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundAttenuation* ACrCharacterPlayerBase::GetAttenuationTPP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetAttenuationTPP");

	Params::CrCharacterPlayerBase_GetAttenuationTPP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCharacterSaveData
// (Final, Native, Public, Const)
// Parameters:
// struct FCrCharacterPlayerBaseSaveDataPerPlayerReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FCrCharacterPlayerBaseSaveDataPerPlayer ACrCharacterPlayerBase::GetCharacterSaveData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCharacterSaveData");

	Params::CrCharacterPlayerBase_GetCharacterSaveData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCharacterSurvivalData
// (Final, Native, Public, Const)
// Parameters:
// struct FCrCharacterPlayerSurvivalData   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCrCharacterPlayerSurvivalData ACrCharacterPlayerBase::GetCharacterSurvivalData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCharacterSurvivalData");

	Params::CrCharacterPlayerBase_GetCharacterSurvivalData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCrAbilitySystemComponent
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrAbilitySystemComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAbilitySystemComponent* ACrCharacterPlayerBase::GetCrAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCrAbilitySystemComponent");

	Params::CrCharacterPlayerBase_GetCrAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCrFlashlightComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrFlashlightComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrFlashlightComponent* ACrCharacterPlayerBase::GetCrFlashlightComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCrFlashlightComponent");

	Params::CrCharacterPlayerBase_GetCrFlashlightComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCrMovementComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrCharacterMovementComponent*    ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrCharacterMovementComponent* ACrCharacterPlayerBase::GetCrMovementComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCrMovementComponent");

	Params::CrCharacterPlayerBase_GetCrMovementComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCrPlayerDialogueComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrPlayerDialogueComponent*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrPlayerDialogueComponent* ACrCharacterPlayerBase::GetCrPlayerDialogueComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCrPlayerDialogueComponent");

	Params::CrCharacterPlayerBase_GetCrPlayerDialogueComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCurrentEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetCurrentEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCurrentEnergy");

	Params::CrCharacterPlayerBase_GetCurrentEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCurrentGrenadeCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetCurrentGrenadeCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCurrentGrenadeCharge");

	Params::CrCharacterPlayerBase_GetCurrentGrenadeCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCurrentMedToolCharge
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetCurrentMedToolCharge() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCurrentMedToolCharge");

	Params::CrCharacterPlayerBase_GetCurrentMedToolCharge Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCurrentReplicatedHarvesterHeatStack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FHarvesterRepHeatStackInfo ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

const struct FHarvesterRepHeatStackInfo ACrCharacterPlayerBase::GetCurrentReplicatedHarvesterHeatStack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCurrentReplicatedHarvesterHeatStack");

	Params::CrCharacterPlayerBase_GetCurrentReplicatedHarvesterHeatStack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetCurrentTemperature
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetCurrentTemperature() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetCurrentTemperature");

	Params::CrCharacterPlayerBase_GetCurrentTemperature Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetDialogueVoice
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDialogueVoice*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDialogueVoice* ACrCharacterPlayerBase::GetDialogueVoice() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetDialogueVoice");

	Params::CrCharacterPlayerBase_GetDialogueVoice Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetEquippedWeaponItemDataBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCrWeaponItemDataBase*      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCrWeaponItemDataBase* ACrCharacterPlayerBase::GetEquippedWeaponItemDataBase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetEquippedWeaponItemDataBase");

	Params::CrCharacterPlayerBase_GetEquippedWeaponItemDataBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetEquippedWeaponItemSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAuItemSlot                      ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuItemSlot ACrCharacterPlayerBase::GetEquippedWeaponItemSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetEquippedWeaponItemSlot");

	Params::CrCharacterPlayerBase_GetEquippedWeaponItemSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetFPPSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ACrCharacterPlayerBase::GetFPPSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetFPPSkeletalMesh");

	Params::CrCharacterPlayerBase_GetFPPSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetItemCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UAuItemDataBase*            InItem                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrCharacterPlayerBase::GetItemCount(const class UAuItemDataBase* InItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetItemCount");

	Params::CrCharacterPlayerBase_GetItemCount Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetMiningComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrMiningComponent*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrMiningComponent* ACrCharacterPlayerBase::GetMiningComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetMiningComponent");

	Params::CrCharacterPlayerBase_GetMiningComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetMiningLockingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrMiningLockingComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrMiningLockingComponent* ACrCharacterPlayerBase::GetMiningLockingComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetMiningLockingComponent");

	Params::CrCharacterPlayerBase_GetMiningLockingComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetPortrait
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FSlateBrush                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateBrush ACrCharacterPlayerBase::GetPortrait() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetPortrait");

	Params::CrCharacterPlayerBase_GetPortrait Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetProfession
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EProfessionType                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EProfessionType ACrCharacterPlayerBase::GetProfession() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetProfession");

	Params::CrCharacterPlayerBase_GetProfession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetProfessionAsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACrCharacterPlayerBase::GetProfessionAsString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetProfessionAsString");

	Params::CrCharacterPlayerBase_GetProfessionAsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetProfessionName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACrCharacterPlayerBase::GetProfessionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetProfessionName");

	Params::CrCharacterPlayerBase_GetProfessionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetProfessionsColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor ACrCharacterPlayerBase::GetProfessionsColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetProfessionsColor");

	Params::CrCharacterPlayerBase_GetProfessionsColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetReplicatedMaxWalkSpeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCharacterPlayerBase::GetReplicatedMaxWalkSpeed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetReplicatedMaxWalkSpeed");

	Params::CrCharacterPlayerBase_GetReplicatedMaxWalkSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.GetTPPSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* ACrCharacterPlayerBase::GetTPPSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "GetTPPSkeletalMesh");

	Params::CrCharacterPlayerBase_GetTPPSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.InformAboutBuildingToolUsed
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    bConstructed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCharacterPlayerBase::InformAboutBuildingToolUsed(bool bConstructed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "InformAboutBuildingToolUsed");

	Params::CrCharacterPlayerBase_InformAboutBuildingToolUsed Parms{};

	Parms.bConstructed = bConstructed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterPlayerBase.IsADSInputToggleSettingEnabled
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsADSInputToggleSettingEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsADSInputToggleSettingEnabled");

	Params::CrCharacterPlayerBase_IsADSInputToggleSettingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsAFK
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsAFK() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsAFK");

	Params::CrCharacterPlayerBase_IsAFK Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsIncapacitated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsIncapacitated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsIncapacitated");

	Params::CrCharacterPlayerBase_IsIncapacitated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsInInterior
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsInInterior() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsInInterior");

	Params::CrCharacterPlayerBase_IsInInterior Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsOnTopOfCustomBuildingWithEnergy
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsOnTopOfCustomBuildingWithEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsOnTopOfCustomBuildingWithEnergy");

	Params::CrCharacterPlayerBase_IsOnTopOfCustomBuildingWithEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsPlayingDialogue
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsPlayingDialogue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsPlayingDialogue");

	Params::CrCharacterPlayerBase_IsPlayingDialogue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.IsSprinting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::IsSprinting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "IsSprinting");

	Params::CrCharacterPlayerBase_IsSprinting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterPlayerBase.ShouldReloadSingleBulletPrintDebugInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCharacterPlayerBase::ShouldReloadSingleBulletPrintDebugInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterPlayerBase", "ShouldReloadSingleBulletPrintDebugInfo");

	Params::CrCharacterPlayerBase_ShouldReloadSingleBulletPrintDebugInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachinesSubsystem.GetMegamachineState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrMegamachineType                      InMegamachineType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrMegamachineState                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrMegamachineState UCrMegamachinesSubsystem::GetMegamachineState(ECrMegamachineType InMegamachineType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachinesSubsystem", "GetMegamachineState");

	Params::CrMegamachinesSubsystem_GetMegamachineState Parms{};

	Parms.InMegamachineType = InMegamachineType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachinesSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrMegamachinesSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachinesSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachinesSubsystem.SetMegamachineState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrMegamachineType                      InMegamachineType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrMegamachineState                     InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrMegamachinesSubsystem::SetMegamachineState(ECrMegamachineType InMegamachineType, ECrMegamachineState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachinesSubsystem", "SetMegamachineState");

	Params::CrMegamachinesSubsystem_SetMegamachineState Parms{};

	Parms.InMegamachineType = InMegamachineType;
	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAlienObeliskSpawner.BP_GetBaseSpawnSearchRadius
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrAlienObeliskSpawner::BP_GetBaseSpawnSearchRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAlienObeliskSpawner", "BP_GetBaseSpawnSearchRadius");

	Params::CrAlienObeliskSpawner_BP_GetBaseSpawnSearchRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInfectionAreaVolume.BP_OnForceHideInfectionCloud
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ForceHide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInfectionAreaVolume::BP_OnForceHideInfectionCloud(bool ForceHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "BP_OnForceHideInfectionCloud");

	Params::CrInfectionAreaVolume_BP_OnForceHideInfectionCloud Parms{};

	Parms.ForceHide = ForceHide;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrInfectionAreaVolume.Deactivate
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ACrInfectionAreaVolume::Deactivate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "Deactivate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrInfectionAreaVolume.FadeoutSubstageChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInfectionAreaVolume::FadeoutSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveFadeoutSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "FadeoutSubstageChanged");

	Params::CrInfectionAreaVolume_FadeoutSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionAreaVolume.GetForceHideInfectionCloud
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrInfectionAreaVolume::GetForceHideInfectionCloud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "GetForceHideInfectionCloud");

	Params::CrInfectionAreaVolume_GetForceHideInfectionCloud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInfectionAreaVolume.GrowbackSubstageChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInfectionAreaVolume::GrowbackSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveGrowbackSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "GrowbackSubstageChanged");

	Params::CrInfectionAreaVolume_GrowbackSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionAreaVolume.IsWaveStageBlockingInfection
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrInfectionAreaVolume::IsWaveStageBlockingInfection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "IsWaveStageBlockingInfection");

	Params::CrInfectionAreaVolume_IsWaveStageBlockingInfection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInfectionAreaVolume.OnInfectionBlockedByWave
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsBlocking                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInfectionAreaVolume::OnInfectionBlockedByWave(bool IsBlocking)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "OnInfectionBlockedByWave");

	Params::CrInfectionAreaVolume_OnInfectionBlockedByWave Parms{};

	Parms.IsBlocking = IsBlocking;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrInfectionAreaVolume.OnRep_WasDestroyed
// (Final, Native, Public)

void ACrInfectionAreaVolume::OnRep_WasDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "OnRep_WasDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionAreaVolume.ResetGuid
// (Final, Native, Public, BlueprintCallable)

void ACrInfectionAreaVolume::ResetGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "ResetGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionAreaVolume.SaveActorData
// (Final, Native, Public, BlueprintCallable)

void ACrInfectionAreaVolume::SaveActorData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "SaveActorData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionAreaVolume.UpdateDestroyedStateVisuals
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrInfectionAreaVolume::UpdateDestroyedStateVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "UpdateDestroyedStateVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionAreaVolume.AreAllInfectionActorsDestroyed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrInfectionAreaVolume::AreAllInfectionActorsDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "AreAllInfectionActorsDestroyed");

	Params::CrInfectionAreaVolume_AreAllInfectionActorsDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInfectionAreaVolume.GetGuid
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid ACrInfectionAreaVolume::GetGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionAreaVolume", "GetGuid");

	Params::CrInfectionAreaVolume_GetGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAmbientSoundSubsystem.PauseAllMultisamples
// (Final, Native, Public, BlueprintCallable)

void UCrAmbientSoundSubsystem::PauseAllMultisamples()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAmbientSoundSubsystem", "PauseAllMultisamples");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAmbientSoundSubsystem.ResumeAllMultisamples
// (Final, Native, Public, BlueprintCallable)

void UCrAmbientSoundSubsystem::ResumeAllMultisamples()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAmbientSoundSubsystem", "ResumeAllMultisamples");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.CalculateMeshHeight
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::CalculateMeshHeight(class USkeletalMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "CalculateMeshHeight");

	Params::CrBuildingActorBase_CalculateMeshHeight Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.DestroyBuildingMeshComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::DestroyBuildingMeshComponent(class UMeshComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "DestroyBuildingMeshComponent");

	Params::CrBuildingActorBase_DestroyBuildingMeshComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.DestructBuilding
// (Native, Public, BlueprintCallable)
// Parameters:
// class ACrPlayerControllerBase*          InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrBuildingActorBase::DestructBuilding(class ACrPlayerControllerBase* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "DestructBuilding");

	Params::CrBuildingActorBase_DestructBuilding Parms{};

	Parms.InPc = InPc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.DisableBuilding
// (Native, Public, BlueprintCallable)

void ACrBuildingActorBase::DisableBuilding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "DisableBuilding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.EnableBuilding
// (Native, Public, BlueprintCallable)

void ACrBuildingActorBase::EnableBuilding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "EnableBuilding");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.FinishTurnOffBuildingEffect
// (Final, Native, Public)

void ACrBuildingActorBase::FinishTurnOffBuildingEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "FinishTurnOffBuildingEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.NativeOnBuildingStateChanged
// (Native, Public)
// Parameters:
// ECrBuildingState                        InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::NativeOnBuildingStateChanged(ECrBuildingState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "NativeOnBuildingStateChanged");

	Params::CrBuildingActorBase_NativeOnBuildingStateChanged Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.OnBuildingMaterialsReady
// (Final, Native, Public)

void ACrBuildingActorBase::OnBuildingMaterialsReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnBuildingMaterialsReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.OnBuildingStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// ECrBuildingState                        InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::OnBuildingStateChanged(ECrBuildingState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnBuildingStateChanged");

	Params::CrBuildingActorBase_OnBuildingStateChanged Parms{};

	Parms.InState = InState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBuildingActorBase.OnBuildingStateFlagChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// ECrBuildingMalfunctionFlags             Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSet                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::OnBuildingStateFlagChanged(ECrBuildingMalfunctionFlags Flag, bool bSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnBuildingStateFlagChanged");

	Params::CrBuildingActorBase_OnBuildingStateFlagChanged Parms{};

	Parms.Flag = Flag;
	Parms.bSet = bSet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBuildingActorBase.OnDamageTaken
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   PrevHealth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CurrentHealth                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::OnDamageTaken(float PrevHealth, float CurrentHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnDamageTaken");

	Params::CrBuildingActorBase_OnDamageTaken Parms{};

	Parms.PrevHealth = PrevHealth;
	Parms.CurrentHealth = CurrentHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.OnFinishedBuildingInteract
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::OnFinishedBuildingInteract(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnFinishedBuildingInteract");

	Params::CrBuildingActorBase_OnFinishedBuildingInteract Parms{};

	Parms.InPc = InPc;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBuildingActorBase.OnInteract
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::OnInteract(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnInteract");

	Params::CrBuildingActorBase_OnInteract Parms{};

	Parms.InPc = InPc;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBuildingActorBase.OnNormalizedInfectionChanged
// (Native, Public)
// Parameters:
// float                                   NewInfection                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::OnNormalizedInfectionChanged(float NewInfection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnNormalizedInfectionChanged");

	Params::CrBuildingActorBase_OnNormalizedInfectionChanged Parms{};

	Parms.NewInfection = NewInfection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.OnPrepareForGame
// (Event, Public, BlueprintEvent)

void ACrBuildingActorBase::OnPrepareForGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnPrepareForGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrBuildingActorBase.OnPrepareForPooling
// (Event, Public, BlueprintEvent)

void ACrBuildingActorBase::OnPrepareForPooling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnPrepareForPooling");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrBuildingActorBase.OnUIOpened
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bOpened                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::OnUIOpened(bool bOpened)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "OnUIOpened");

	Params::CrBuildingActorBase_OnUIOpened Parms{};

	Parms.bOpened = bOpened;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBuildingActorBase.PlayBuildingEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrBuildingActorBase::PlayBuildingEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "PlayBuildingEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.PostPlayBuildingEffect
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bWasBuildingEffectPlayed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::PostPlayBuildingEffect(bool bWasBuildingEffectPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "PostPlayBuildingEffect");

	Params::CrBuildingActorBase_PostPlayBuildingEffect Parms{};

	Parms.bWasBuildingEffectPlayed = bWasBuildingEffectPlayed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBuildingActorBase.PrepareTurnOffBuildingEffect
// (Final, Native, Public)

void ACrBuildingActorBase::PrepareTurnOffBuildingEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "PrepareTurnOffBuildingEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.SetCustomPrimitiveDataFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::SetCustomPrimitiveDataFloat(int32 Index_0, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "SetCustomPrimitiveDataFloat");

	Params::CrBuildingActorBase_SetCustomPrimitiveDataFloat Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.SetCustomPrimitiveDataVector3
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingActorBase::SetCustomPrimitiveDataVector3(int32 Index_0, const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "SetCustomPrimitiveDataVector3");

	Params::CrBuildingActorBase_SetCustomPrimitiveDataVector3 Parms{};

	Parms.Index_0 = Index_0;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.SetupFoundationAndBuildingConnection
// (Final, Native, Protected)

void ACrBuildingActorBase::SetupFoundationAndBuildingConnection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "SetupFoundationAndBuildingConnection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.SetupMainMesh
// (Final, Native, Private)

void ACrBuildingActorBase::SetupMainMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "SetupMainMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingActorBase.SetupSkeletalMesh
// (Event, Public, BlueprintEvent)

void ACrBuildingActorBase::SetupSkeletalMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "SetupSkeletalMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrBuildingActorBase.GetBuildingID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECrBuildingID                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrBuildingID ACrBuildingActorBase::GetBuildingID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetBuildingID");

	Params::CrBuildingActorBase_GetBuildingID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetBuildingPotentialPower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetBuildingPotentialPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetBuildingPotentialPower");

	Params::CrBuildingActorBase_GetBuildingPotentialPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetBuildingPower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetBuildingPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetBuildingPower");

	Params::CrBuildingActorBase_GetBuildingPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetBuildingState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECrBuildingState                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrBuildingState ACrBuildingActorBase::GetBuildingState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetBuildingState");

	Params::CrBuildingActorBase_GetBuildingState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetBuildingStateFlag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECrBuildingMalfunctionFlags             Flag                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrBuildingActorBase::GetBuildingStateFlag(ECrBuildingMalfunctionFlags Flag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetBuildingStateFlag");

	Params::CrBuildingActorBase_GetBuildingStateFlag Parms{};

	Parms.Flag = Flag;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetCurrentInfection
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetCurrentInfection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetCurrentInfection");

	Params::CrBuildingActorBase_GetCurrentInfection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetCurrentTemperature
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetCurrentTemperature() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetCurrentTemperature");

	Params::CrBuildingActorBase_GetCurrentTemperature Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetGridAddPower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetGridAddPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetGridAddPower");

	Params::CrBuildingActorBase_GetGridAddPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetGridConnectionStatus
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECrBuildingGridConnectionStatus         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrBuildingGridConnectionStatus ACrBuildingActorBase::GetGridConnectionStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetGridConnectionStatus");

	Params::CrBuildingActorBase_GetGridConnectionStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetGridPotentialAddPower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetGridPotentialAddPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetGridPotentialAddPower");

	Params::CrBuildingActorBase_GetGridPotentialAddPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetGridPotentialRemovePower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetGridPotentialRemovePower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetGridPotentialRemovePower");

	Params::CrBuildingActorBase_GetGridPotentialRemovePower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetGridPower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetGridPower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetGridPower");

	Params::CrBuildingActorBase_GetGridPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetGridRemovePower
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrBuildingActorBase::GetGridRemovePower() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetGridRemovePower");

	Params::CrBuildingActorBase_GetGridRemovePower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.GetIndicatedForDeconstruction
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrBuildingActorBase::GetIndicatedForDeconstruction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "GetIndicatedForDeconstruction");

	Params::CrBuildingActorBase_GetIndicatedForDeconstruction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.IsBuildingDisabled
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrBuildingActorBase::IsBuildingDisabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "IsBuildingDisabled");

	Params::CrBuildingActorBase_IsBuildingDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.IsBuildingInfectionActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrBuildingActorBase::IsBuildingInfectionActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "IsBuildingInfectionActive");

	Params::CrBuildingActorBase_IsBuildingInfectionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingActorBase.IsBuildingTurnedOn
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrBuildingActorBase::IsBuildingTurnedOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingActorBase", "IsBuildingTurnedOn");

	Params::CrBuildingActorBase_IsBuildingTurnedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCrafter.OnItemCraftingComplete
// (Event, Public, BlueprintEvent)

void ACrCrafter::OnItemCraftingComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCrafter", "OnItemCraftingComplete");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrCrafter.GetCraftingAnimOffset
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCrafter::GetCraftingAnimOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCrafter", "GetCraftingAnimOffset");

	Params::CrCrafter_GetCraftingAnimOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCrafter.GetCraftingAnimOffsetForMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCrafter::GetCraftingAnimOffsetForMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCrafter", "GetCraftingAnimOffsetForMaterial");

	Params::CrCrafter_GetCraftingAnimOffsetForMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCrafter.GetItemCraftingProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCrafter::GetItemCraftingProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCrafter", "GetItemCraftingProgress");

	Params::CrCrafter_GetItemCraftingProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBaseCoreSubsystem.GetCheatShowBaseCoreRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrBaseCoreSubsystem::GetCheatShowBaseCoreRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreSubsystem", "GetCheatShowBaseCoreRange");

	Params::CrBaseCoreSubsystem_GetCheatShowBaseCoreRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBaseCoreSubsystem.OnBaseCoreDeconstructed
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBaseCoreSubsystem::OnBaseCoreDeconstructed(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreSubsystem", "OnBaseCoreDeconstructed");

	Params::CrBaseCoreSubsystem_OnBaseCoreDeconstructed Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreSubsystem.OnBaseCoreInfectionSphereChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrBaseCoreData&           BaseCoreData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrBaseCoreSubsystem::OnBaseCoreInfectionSphereChanged(const struct FCrBaseCoreData& BaseCoreData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreSubsystem", "OnBaseCoreInfectionSphereChanged");

	Params::CrBaseCoreSubsystem_OnBaseCoreInfectionSphereChanged Parms{};

	Parms.BaseCoreData = std::move(BaseCoreData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreSubsystem.OnBaseCoreUpgraded
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBaseCoreSubsystem::OnBaseCoreUpgraded(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreSubsystem", "OnBaseCoreUpgraded");

	Params::CrBaseCoreSubsystem_OnBaseCoreUpgraded Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWatermarkSubsystem.GetWatermarkString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrWatermarkSubsystem::GetWatermarkString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWatermarkSubsystem", "GetWatermarkString");

	Params::CrWatermarkSubsystem_GetWatermarkString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAnimHelperBlueprintFunctionLibrary.BP_Montage_GetSectionLengthByIndex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimMontage*               Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrAnimHelperBlueprintFunctionLibrary::BP_Montage_GetSectionLengthByIndex(const class UAnimMontage* Montage, int32 SectionIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAnimHelperBlueprintFunctionLibrary", "BP_Montage_GetSectionLengthByIndex");

	Params::CrAnimHelperBlueprintFunctionLibrary_BP_Montage_GetSectionLengthByIndex Parms{};

	Parms.Montage = Montage;
	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAnimHelperBlueprintFunctionLibrary.BP_Montage_GetSectionLengthByName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimMontage*               Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InSectionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrAnimHelperBlueprintFunctionLibrary::BP_Montage_GetSectionLengthByName(const class UAnimMontage* Montage, class FName InSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAnimHelperBlueprintFunctionLibrary", "BP_Montage_GetSectionLengthByName");

	Params::CrAnimHelperBlueprintFunctionLibrary_BP_Montage_GetSectionLengthByName Parms{};

	Parms.Montage = Montage;
	Parms.InSectionName = InSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAnimHelperBlueprintFunctionLibrary.BP_Montage_GetSectionStartAndEndTime
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimMontage*               Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SectionIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutStartTime                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutEndTime                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAnimHelperBlueprintFunctionLibrary::BP_Montage_GetSectionStartAndEndTime(const class UAnimMontage* Montage, int32 SectionIndex, float* OutStartTime, float* OutEndTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAnimHelperBlueprintFunctionLibrary", "BP_Montage_GetSectionStartAndEndTime");

	Params::CrAnimHelperBlueprintFunctionLibrary_BP_Montage_GetSectionStartAndEndTime Parms{};

	Parms.Montage = Montage;
	Parms.SectionIndex = SectionIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStartTime != nullptr)
		*OutStartTime = Parms.OutStartTime;

	if (OutEndTime != nullptr)
		*OutEndTime = Parms.OutEndTime;
}


// Function Chimera.CrAnimHelperBlueprintFunctionLibrary.BP_Montage_GetSectionTimeLeftFromPos
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAnimMontage*               Montage                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrAnimHelperBlueprintFunctionLibrary::BP_Montage_GetSectionTimeLeftFromPos(const class UAnimMontage* Montage, float Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAnimHelperBlueprintFunctionLibrary", "BP_Montage_GetSectionTimeLeftFromPos");

	Params::CrAnimHelperBlueprintFunctionLibrary_BP_Montage_GetSectionTimeLeftFromPos Parms{};

	Parms.Montage = Montage;
	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAnimInstance.K2_InitializeWithAbilitySystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAnimInstance::K2_InitializeWithAbilitySystem(class UAbilitySystemComponent* ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAnimInstance", "K2_InitializeWithAbilitySystem");

	Params::CrAnimInstance_K2_InitializeWithAbilitySystem Parms{};

	Parms.ASC = ASC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCraftingRecipeOwner.OnContextualEventExecuted
// (Final, Native, Private)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContextName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContextValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCraftingRecipeOwner::OnContextualEventExecuted(class AActor* Target, class FName ContextName, class FName ContextValue, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCraftingRecipeOwner", "OnContextualEventExecuted");

	Params::CrCraftingRecipeOwner_OnContextualEventExecuted Parms{};

	Parms.Target = Target;
	Parms.ContextName = ContextName;
	Parms.ContextValue = ContextValue;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCraftingRecipeOwner.OnGameStateSetEvent
// (Final, Native, Private)
// Parameters:
// class AGameStateBase*                   GameState                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCraftingRecipeOwner::OnGameStateSetEvent(class AGameStateBase* GameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCraftingRecipeOwner", "OnGameStateSetEvent");

	Params::CrCraftingRecipeOwner_OnGameStateSetEvent Parms{};

	Parms.GameState = GameState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCraftingRecipeOwner.OnPreSaveStart
// (Final, Native, Private)

void ACrCraftingRecipeOwner::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCraftingRecipeOwner", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCraftingRecipeOwner.OnRep_PickedUpItems
// (Final, Native, Private)

void ACrCraftingRecipeOwner::OnRep_PickedUpItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCraftingRecipeOwner", "OnRep_PickedUpItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCraftingRecipeOwner.OnSaveLoaded
// (Final, Native, Private)

void ACrCraftingRecipeOwner::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCraftingRecipeOwner", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.HandleChargingProgressChanged
// (Final, Native, Protected)
// Parameters:
// const struct FCrMassEntityReplicationHelper&InAntenna                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InChargingProgress                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAntena::HandleChargingProgressChanged(const struct FCrMassEntityReplicationHelper& InAntenna, float InChargingProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "HandleChargingProgressChanged");

	Params::CrAntena_HandleChargingProgressChanged Parms{};

	Parms.InAntenna = std::move(InAntenna);
	Parms.InChargingProgress = InChargingProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.HandleStateChanged
// (Final, Native, Protected)
// Parameters:
// const struct FCrMassEntityReplicationHelper&InAntenna                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrAntennaState                         InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAntena::HandleStateChanged(const struct FCrMassEntityReplicationHelper& InAntenna, ECrAntennaState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "HandleStateChanged");

	Params::CrAntena_HandleStateChanged Parms{};

	Parms.InAntenna = std::move(InAntenna);
	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.OnActivated
// (Native, Event, Protected, BlueprintEvent)

void ACrAntena::OnActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "OnActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.OnBeginPlayAsActivated
// (Native, Event, Protected, BlueprintEvent)

void ACrAntena::OnBeginPlayAsActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "OnBeginPlayAsActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.OnChargingCompleted
// (Native, Event, Protected, BlueprintEvent)

void ACrAntena::OnChargingCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "OnChargingCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.OnChargingProgressUpdate
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAntena::OnChargingProgressUpdate(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "OnChargingProgressUpdate");

	Params::CrAntena_OnChargingProgressUpdate Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.OnChargingStarted
// (Native, Event, Protected, BlueprintEvent)

void ACrAntena::OnChargingStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "OnChargingStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.OnInfected
// (Native, Event, Protected, BlueprintEvent)

void ACrAntena::OnInfected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "OnInfected");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.OnInfectionRemoved
// (Native, Event, Protected, BlueprintEvent)

void ACrAntena::OnInfectionRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "OnInfectionRemoved");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.OnInfectionTaken
// (Native, Event, Protected, BlueprintEvent)

void ACrAntena::OnInfectionTaken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "OnInfectionTaken");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntena.PlayInteractionSuccessfulSound
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrAntena::PlayInteractionSuccessfulSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "PlayInteractionSuccessfulSound");

	Params::CrAntena_PlayInteractionSuccessfulSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrAntena.PlayInteractionUnSuccessfulSound
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrAntena::PlayInteractionUnSuccessfulSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "PlayInteractionUnSuccessfulSound");

	Params::CrAntena_PlayInteractionUnSuccessfulSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrAntena.SetUI
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// ECrAntennaState                         InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAntena::SetUI(ECrAntennaState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntena", "SetUI");

	Params::CrAntena_SetUI Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntennasOwner.OnPreSaveStart
// (Final, Native, Private)

void ACrAntennasOwner::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntennasOwner", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntennasOwner.OnSaveLoaded
// (Final, Native, Private)

void ACrAntennasOwner::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntennasOwner", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAntennasOwner.OnUnlockedFeaturesChanged
// (Final, Native, Public)
// Parameters:
// const TArray<ECrCorporationUnlockedFeatures>&UnlockedFeatures                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACrAntennasOwner::OnUnlockedFeaturesChanged(const TArray<ECrCorporationUnlockedFeatures>& UnlockedFeatures)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntennasOwner", "OnUnlockedFeaturesChanged");

	Params::CrAntennasOwner_OnUnlockedFeaturesChanged Parms{};

	Parms.UnlockedFeatures = std::move(UnlockedFeatures);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCustomBuilding.AreSocketsSnapped
// (Final, Native, Static, Public)
// Parameters:
// class FName                             ThisSocket                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ThatSocket                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ThisMesh                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             ThatMesh                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCustomBuilding::AreSocketsSnapped(class FName ThisSocket, class FName ThatSocket, class UStaticMeshComponent* ThisMesh, class UStaticMeshComponent* ThatMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrCustomBuilding", "AreSocketsSnapped");

	Params::CrCustomBuilding_AreSocketsSnapped Parms{};

	Parms.ThisSocket = ThisSocket;
	Parms.ThatSocket = ThatSocket;
	Parms.ThisMesh = ThisMesh;
	Parms.ThatMesh = ThatMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomBuilding.AreSocketsSnappedWithoutComponents
// (Final, Native, Static, Public, HasDefaults)
// Parameters:
// class UStaticMeshSocket*                ThisSocket                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshSocket*                ThatSocket                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      ThisMesh                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      ThatMesh                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                ThisMeshWorldTransform                                 (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                ThatMeshWorldTransform                                 (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCustomBuilding::AreSocketsSnappedWithoutComponents(class UStaticMeshSocket* ThisSocket, class UStaticMeshSocket* ThatSocket, class UStaticMesh* ThisMesh, class UStaticMesh* ThatMesh, const struct FTransform& ThisMeshWorldTransform, const struct FTransform& ThatMeshWorldTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrCustomBuilding", "AreSocketsSnappedWithoutComponents");

	Params::CrCustomBuilding_AreSocketsSnappedWithoutComponents Parms{};

	Parms.ThisSocket = ThisSocket;
	Parms.ThatSocket = ThatSocket;
	Parms.ThisMesh = ThisMesh;
	Parms.ThatMesh = ThatMesh;
	Parms.ThisMeshWorldTransform = std::move(ThisMeshWorldTransform);
	Parms.ThatMeshWorldTransform = std::move(ThatMeshWorldTransform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomBuilding.GetPrefixes
// (Final, Native, Static, Public)
// Parameters:
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> ACrCustomBuilding::GetPrefixes(class UStaticMesh* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrCustomBuilding", "GetPrefixes");

	Params::CrCustomBuilding_GetPrefixes Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomBuilding.HasAnyCustomConnections
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCustomBuilding::HasAnyCustomConnections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomBuilding", "HasAnyCustomConnections");

	Params::CrCustomBuilding_HasAnyCustomConnections Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomBuilding.IsAnyPlayerInside
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCustomBuilding::IsAnyPlayerInside()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomBuilding", "IsAnyPlayerInside");

	Params::CrCustomBuilding_IsAnyPlayerInside Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomBuilding.IsTest
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCustomBuilding::IsTest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomBuilding", "IsTest");

	Params::CrCustomBuilding_IsTest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomBuilding.IsTouchingGround
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCustomBuilding::IsTouchingGround()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomBuilding", "IsTouchingGround");

	Params::CrCustomBuilding_IsTouchingGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomBuilding.GetStabilityCost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCustomBuilding::GetStabilityCost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomBuilding", "GetStabilityCost");

	Params::CrCustomBuilding_GetStabilityCost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomBuilding.GetStrength
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrCustomBuilding::GetStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomBuilding", "GetStrength");

	Params::CrCustomBuilding_GetStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomDoor.GetRule
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EDoorState                              State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACrCustomDoor::GetRule(EDoorState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomDoor", "GetRule");

	Params::CrCustomDoor_GetRule Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomDoor.OnOpenStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bInOpen                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCustomDoor::OnOpenStateChanged(bool bInOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomDoor", "OnOpenStateChanged");

	Params::CrCustomDoor_OnOpenStateChanged Parms{};

	Parms.bInOpen = bInOpen;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCustomDoor.PlayInteractionUnSuccessfulSound
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// EDoorState                              DoorState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCustomDoor::PlayInteractionUnSuccessfulSound(EDoorState DoorState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomDoor", "PlayInteractionUnSuccessfulSound");

	Params::CrCustomDoor_PlayInteractionUnSuccessfulSound Parms{};

	Parms.DoorState = DoorState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCustomDoor.GetAirlockHabitatExteriorComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class UShapeComponent*            ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UShapeComponent* ACrCustomDoor::GetAirlockHabitatExteriorComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomDoor", "GetAirlockHabitatExteriorComponent");

	Params::CrCustomDoor_GetAirlockHabitatExteriorComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomDoor.GetAirlockInteriorComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// const class UShapeComponent*            ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UShapeComponent* ACrCustomDoor::GetAirlockInteriorComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomDoor", "GetAirlockInteriorComponent");

	Params::CrCustomDoor_GetAirlockInteriorComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAntennaSubsystem.RegisterSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrAISpawner*                     InSpawner                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAntennaSubsystem::RegisterSpawner(class ACrAISpawner* InSpawner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAntennaSubsystem", "RegisterSpawner");

	Params::CrAntennaSubsystem_RegisterSpawner Parms{};

	Parms.InSpawner = InSpawner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAPHelperActorCustom.CheckDynamicHelper
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FCrDynamicHelperData&      Data                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 AcceptedPoints                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 RejectedPoints                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   FirstLineNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AllNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAPHelperActorCustom::CheckDynamicHelper(const struct FCrDynamicHelperData& Data, TArray<struct FVector>* AcceptedPoints, TArray<struct FVector>* RejectedPoints, int32 FirstLineNum, int32 AllNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAPHelperActorCustom", "CheckDynamicHelper");

	Params::CrAPHelperActorCustom_CheckDynamicHelper Parms{};

	Parms.Data = std::move(Data);
	Parms.FirstLineNum = FirstLineNum;
	Parms.AllNum = AllNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AcceptedPoints != nullptr)
		*AcceptedPoints = std::move(Parms.AcceptedPoints);

	if (RejectedPoints != nullptr)
		*RejectedPoints = std::move(Parms.RejectedPoints);
}


// Function Chimera.CrAPHelperActorCustom.OnRep_DynamicData
// (Final, Native, Protected)

void ACrAPHelperActorCustom::OnRep_DynamicData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAPHelperActorCustom", "OnRep_DynamicData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAPHelperActorCustom.ServerSetDynamicPositions
// (Net, Native, Event, Protected, NetServer)
// Parameters:
// const struct FCrDynamicHelperData&      Data                                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bInDynamic                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAuAPlacementConditionResult            PlacementResult                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FirstLineNum                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AllNum                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAPHelperActorCustom::ServerSetDynamicPositions(const struct FCrDynamicHelperData& Data, bool bInDynamic, EAuAPlacementConditionResult PlacementResult, int32 FirstLineNum, int32 AllNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAPHelperActorCustom", "ServerSetDynamicPositions");

	Params::CrAPHelperActorCustom_ServerSetDynamicPositions Parms{};

	Parms.Data = std::move(Data);
	Parms.bInDynamic = bInDynamic;
	Parms.PlacementResult = PlacementResult;
	Parms.FirstLineNum = FirstLineNum;
	Parms.AllNum = AllNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreMassHighResActor.OnMiningWeakSpotDepletedCosmeticsStart
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FTransform&                CosmeticTransform                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreMassHighResActor::OnMiningWeakSpotDepletedCosmeticsStart(const struct FTransform& CosmeticTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreMassHighResActor", "OnMiningWeakSpotDepletedCosmeticsStart");

	Params::CrOreMassHighResActor_OnMiningWeakSpotDepletedCosmeticsStart Parms{};

	Parms.CosmeticTransform = std::move(CosmeticTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrOreMassHighResActor.OnResourceDepletedCosmeticsStart
// (Event, Public, BlueprintEvent)

void ACrOreMassHighResActor::OnResourceDepletedCosmeticsStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreMassHighResActor", "OnResourceDepletedCosmeticsStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrOreMassHighResActor.OnResourceReplenishedCosmeticsStart
// (Event, Public, BlueprintEvent)

void ACrOreMassHighResActor::OnResourceReplenishedCosmeticsStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreMassHighResActor", "OnResourceReplenishedCosmeticsStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrMassGatherableCropActorBase.GatherCropResource
// (Native, Public)
// Parameters:
// struct FCrMinedResource                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCrMinedResource ACrMassGatherableCropActorBase::GatherCropResource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassGatherableCropActorBase", "GatherCropResource");

	Params::CrMassGatherableCropActorBase_GatherCropResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassGatherableCropActorBase.OnCropDepletedCosmeticsStart
// (Event, Protected, BlueprintEvent)

void ACrMassGatherableCropActorBase::OnCropDepletedCosmeticsStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassGatherableCropActorBase", "OnCropDepletedCosmeticsStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrMassGatherableCropActorBase.OnCropReplenishedCosmeticsStart
// (Event, Protected, BlueprintEvent)

void ACrMassGatherableCropActorBase::OnCropReplenishedCosmeticsStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassGatherableCropActorBase", "OnCropReplenishedCosmeticsStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrMassGatherableCropActorBase.GetCropResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrItemDataBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrItemDataBase* ACrMassGatherableCropActorBase::GetCropResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassGatherableCropActorBase", "GetCropResource");

	Params::CrMassGatherableCropActorBase_GetCropResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassGatherableCropActorBase.GetCurrentCropResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrMassGatherableCropActorBase::GetCurrentCropResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassGatherableCropActorBase", "GetCurrentCropResourceCount");

	Params::CrMassGatherableCropActorBase_GetCurrentCropResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassGatherableCropActorBase.GetMaxCropResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrMassGatherableCropActorBase::GetMaxCropResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassGatherableCropActorBase", "GetMaxCropResourceCount");

	Params::CrMassGatherableCropActorBase_GetMaxCropResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassGatherableCropActorBase.IsCropDepleted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMassGatherableCropActorBase::IsCropDepleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassGatherableCropActorBase", "IsCropDepleted");

	Params::CrMassGatherableCropActorBase_IsCropDepleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CustomScalabilitySettings.GetCharactersTPPShadowDistance
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomScalabilitySettings::GetCharactersTPPShadowDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CustomScalabilitySettings", "GetCharactersTPPShadowDistance");

	Params::CustomScalabilitySettings_GetCharactersTPPShadowDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponPrimitiveCompInterface.GetAttachParentSocketName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ICrWeaponPrimitiveCompInterface::GetAttachParentSocketName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrWeaponPrimitiveCompInterface", "GetAttachParentSocketName");

	Params::CrWeaponPrimitiveCompInterface_GetAttachParentSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponPrimitiveCompInterface.GetPartIdentifierTag
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ICrWeaponPrimitiveCompInterface::GetPartIdentifierTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrWeaponPrimitiveCompInterface", "GetPartIdentifierTag");

	Params::CrWeaponPrimitiveCompInterface_GetPartIdentifierTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponPrimitiveCompInterface.GetSlotTag
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ICrWeaponPrimitiveCompInterface::GetSlotTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrWeaponPrimitiveCompInterface", "GetSlotTag");

	Params::CrWeaponPrimitiveCompInterface_GetSlotTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCustomPlaceCustom.SpawnOnStart
// (Final, Native, Public)
// Parameters:
// const class UAuActorPlacementData*      InPlacementData                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCustomPlaceCustom::SpawnOnStart(const class UAuActorPlacementData* InPlacementData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCustomPlaceCustom", "SpawnOnStart");

	Params::CrCustomPlaceCustom_SpawnOnStart Parms{};

	Parms.InPlacementData = InPlacementData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAPHelperActorCustomSpline.SetWalkwayConnectorMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrAPHelperActorCustomSpline::SetWalkwayConnectorMesh(class UStaticMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAPHelperActorCustomSpline", "SetWalkwayConnectorMesh");

	Params::CrAPHelperActorCustomSpline_SetWalkwayConnectorMesh Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAPHelperActorZipline.OnConnectionsModified
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FVector>&           NewAcceptedLocations                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           NewObstructedLocations                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           NewBlockedLocations                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACrAPHelperActorZipline::OnConnectionsModified(const TArray<struct FVector>& NewAcceptedLocations, const TArray<struct FVector>& NewObstructedLocations, const TArray<struct FVector>& NewBlockedLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAPHelperActorZipline", "OnConnectionsModified");

	Params::CrAPHelperActorZipline_OnConnectionsModified Parms{};

	Parms.NewAcceptedLocations = std::move(NewAcceptedLocations);
	Parms.NewObstructedLocations = std::move(NewObstructedLocations);
	Parms.NewBlockedLocations = std::move(NewBlockedLocations);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrDeathReactionComponent.FinishDying
// (Final, Native, Public, BlueprintCallable)

void UCrDeathReactionComponent::FinishDying()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "FinishDying");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDeathReactionComponent.MulticastOnDeathEvent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDeathReactionComponent::MulticastOnDeathEvent(const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "MulticastOnDeathEvent");

	Params::CrDeathReactionComponent_MulticastOnDeathEvent Parms{};

	Parms.DamageTag = std::move(DamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDeathReactionComponent.MulticastOnIncapacitatedEvent
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDeathReactionComponent::MulticastOnIncapacitatedEvent(const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "MulticastOnIncapacitatedEvent");

	Params::CrDeathReactionComponent_MulticastOnIncapacitatedEvent Parms{};

	Parms.DamageTag = std::move(DamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDeathReactionComponent.OnDeathBPEvent
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDeathReactionComponent::OnDeathBPEvent(const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "OnDeathBPEvent");

	Params::CrDeathReactionComponent_OnDeathBPEvent Parms{};

	Parms.DamageTag = std::move(DamageTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrDeathReactionComponent.OnDeathEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDeathReactionComponent::OnDeathEvent(const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "OnDeathEvent");

	Params::CrDeathReactionComponent_OnDeathEvent Parms{};

	Parms.DamageTag = std::move(DamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDeathReactionComponent.OnIncapacitatedBPEvent
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDeathReactionComponent::OnIncapacitatedBPEvent(const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "OnIncapacitatedBPEvent");

	Params::CrDeathReactionComponent_OnIncapacitatedBPEvent Parms{};

	Parms.DamageTag = std::move(DamageTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrDeathReactionComponent.OnIncapacitatedEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDeathReactionComponent::OnIncapacitatedEvent(const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "OnIncapacitatedEvent");

	Params::CrDeathReactionComponent_OnIncapacitatedEvent Parms{};

	Parms.DamageTag = std::move(DamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDeathReactionComponent.ServerOnDeathEvent
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDeathReactionComponent::ServerOnDeathEvent(const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "ServerOnDeathEvent");

	Params::CrDeathReactionComponent_ServerOnDeathEvent Parms{};

	Parms.DamageTag = std::move(DamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDeathReactionComponent.ServerOnIncapacitatedEvent
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDeathReactionComponent::ServerOnIncapacitatedEvent(const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDeathReactionComponent", "ServerOnIncapacitatedEvent");

	Params::CrDeathReactionComponent_ServerOnIncapacitatedEvent Parms{};

	Parms.DamageTag = std::move(DamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDataLayerEventSubsystem.ActivateDataLayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataLayerAsset*                  DataLayerAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDataLayerEventSubsystem::ActivateDataLayer(class UDataLayerAsset* DataLayerAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDataLayerEventSubsystem", "ActivateDataLayer");

	Params::CrDataLayerEventSubsystem_ActivateDataLayer Parms{};

	Parms.DataLayerAsset = DataLayerAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDataLayerEventSubsystem.DeactivateDataLayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataLayerAsset*                  DataLayerAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDataLayerEventSubsystem::DeactivateDataLayer(class UDataLayerAsset* DataLayerAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDataLayerEventSubsystem", "DeactivateDataLayer");

	Params::CrDataLayerEventSubsystem_DeactivateDataLayer Parms{};

	Parms.DataLayerAsset = DataLayerAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDataLayerEventSubsystem.IsDataLayerActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UDataLayerAsset*                  DataLayerAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrDataLayerEventSubsystem::IsDataLayerActive(class UDataLayerAsset* DataLayerAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDataLayerEventSubsystem", "IsDataLayerActive");

	Params::CrDataLayerEventSubsystem_IsDataLayerActive Parms{};

	Parms.DataLayerAsset = DataLayerAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAPOreSocket.EquipItemChanged
// (Final, Native, Private)

void ACrAPOreSocket::EquipItemChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAPOreSocket", "EquipItemChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCutsceneActor.HandleCutsceneCompleted
// (Final, Native, Private)

void ACrCutsceneActor::HandleCutsceneCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCutsceneActor", "HandleCutsceneCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCutsceneActor.HandleCutsceneSkippedd
// (Final, Native, Private)

void ACrCutsceneActor::HandleCutsceneSkippedd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCutsceneActor", "HandleCutsceneSkippedd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCutsceneActor.HandleCutsceneStarted
// (Final, Native, Private)

void ACrCutsceneActor::HandleCutsceneStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCutsceneActor", "HandleCutsceneStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCutsceneActor.PlayCutscene
// (Final, Native, Public, BlueprintCallable)

void ACrCutsceneActor::PlayCutscene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCutsceneActor", "PlayCutscene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCutsceneActor.SkipCutscene
// (Final, Native, Public, BlueprintCallable)

void ACrCutsceneActor::SkipCutscene()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCutsceneActor", "SkipCutscene");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAsyncTaskAttributeChanged.ListenForAttributeChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayAttribute&        Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAsyncTaskAttributeChanged*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAsyncTaskAttributeChanged* UCrAsyncTaskAttributeChanged::ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAsyncTaskAttributeChanged", "ListenForAttributeChange");

	Params::CrAsyncTaskAttributeChanged_ListenForAttributeChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAsyncTaskAttributeChanged.ListenForAttributesChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FGameplayAttribute>&Attributes                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UCrAsyncTaskAttributeChanged*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAsyncTaskAttributeChanged* UCrAsyncTaskAttributeChanged::ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent, const TArray<struct FGameplayAttribute>& Attributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAsyncTaskAttributeChanged", "ListenForAttributesChange");

	Params::CrAsyncTaskAttributeChanged_ListenForAttributesChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Attributes = std::move(Attributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAsyncTaskAttributeChanged.EndTask
// (Final, Native, Public, BlueprintCallable)

void UCrAsyncTaskAttributeChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAsyncTaskAttributeChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAsyncTaskEffectStackChanged.ListenForGameplayEffectStackChange
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAsyncTaskEffectStackChanged*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAsyncTaskEffectStackChanged* UCrAsyncTaskEffectStackChanged::ListenForGameplayEffectStackChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAsyncTaskEffectStackChanged", "ListenForGameplayEffectStackChange");

	Params::CrAsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.EffectGameplayTag = std::move(EffectGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAsyncTaskEffectStackChanged.EndTask
// (Final, Native, Private, BlueprintCallable)

void UCrAsyncTaskEffectStackChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAsyncTaskEffectStackChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInteractiveDoor.MulticastInteract
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInteractiveDoor::MulticastInteract(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractiveDoor", "MulticastInteract");

	Params::CrInteractiveDoor_MulticastInteract Parms{};

	Parms.InPc = InPc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInteractiveDoor.OnInteract
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInteractiveDoor::OnInteract(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractiveDoor", "OnInteract");

	Params::CrInteractiveDoor_OnInteract Parms{};

	Parms.InPc = InPc;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrInteractiveDoor.OnRep_IsOpen
// (Final, Native, Protected)

void ACrInteractiveDoor::OnRep_IsOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractiveDoor", "OnRep_IsOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAsyncTaskGameplayTag.ListenForTagChanged
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAsyncTaskGameplayTag*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAsyncTaskGameplayTag* UCrAsyncTaskGameplayTag::ListenForTagChanged(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAsyncTaskGameplayTag", "ListenForTagChanged");

	Params::CrAsyncTaskGameplayTag_ListenForTagChanged Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAsyncTaskGameplayTag.ListenForTagRemoved
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAsyncTaskGameplayTag*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAsyncTaskGameplayTag* UCrAsyncTaskGameplayTag::ListenForTagRemoved(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAsyncTaskGameplayTag", "ListenForTagRemoved");

	Params::CrAsyncTaskGameplayTag_ListenForTagRemoved Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAsyncTaskGameplayTag.EndTask
// (Final, Native, Public, BlueprintCallable)

void UCrAsyncTaskGameplayTag::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAsyncTaskGameplayTag", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.GameFeatureAction_AddLevelInstances.OnLevelLoaded
// (Final, Native, Private)

void UGameFeatureAction_AddLevelInstances::OnLevelLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameFeatureAction_AddLevelInstances", "OnLevelLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrLogisticsRequestSubsystem.OnPreSaveStart
// (Final, Native, Protected)

void UCrLogisticsRequestSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrLogisticsRequestSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrLogisticsRequestSubsystem.OnSaveLoaded
// (Final, Native, Protected)

void UCrLogisticsRequestSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrLogisticsRequestSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAttributeObserverComponent.OnPlayerProfessionChanging
// (Final, Native, Private)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EProfessionType                         NewProfession                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAttributeObserverComponent::OnPlayerProfessionChanging(class ACharacter* Character, EProfessionType NewProfession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAttributeObserverComponent", "OnPlayerProfessionChanging");

	Params::CrAttributeObserverComponent_OnPlayerProfessionChanging Parms{};

	Parms.Character = Character;
	Parms.NewProfession = NewProfession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.GasOverlapComponent.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UGasOverlapComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GasOverlapComponent", "OnBeginOverlap");

	Params::GasOverlapComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.GasOverlapComponent.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGasOverlapComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GasOverlapComponent", "OnEndOverlap");

	Params::GasOverlapComponent_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAT_WaitReloadSingleBulletWeapon.WaitReloadSingleBulletWeapon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InEffectTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InIntroSectionDuration                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLoopDuration                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InAfterLoopWindupDuration                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InOutSectionDuration                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InReloadInterruptionTag                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAT_WaitReloadSingleBulletWeapon*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAT_WaitReloadSingleBulletWeapon* UCrAT_WaitReloadSingleBulletWeapon::WaitReloadSingleBulletWeapon(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FGameplayTag& InEffectTag, float InIntroSectionDuration, float InLoopDuration, float InAfterLoopWindupDuration, float InOutSectionDuration, const struct FGameplayTag& InReloadInterruptionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAT_WaitReloadSingleBulletWeapon", "WaitReloadSingleBulletWeapon");

	Params::CrAT_WaitReloadSingleBulletWeapon_WaitReloadSingleBulletWeapon Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InEffectTag = std::move(InEffectTag);
	Parms.InIntroSectionDuration = InIntroSectionDuration;
	Parms.InLoopDuration = InLoopDuration;
	Parms.InAfterLoopWindupDuration = InAfterLoopWindupDuration;
	Parms.InOutSectionDuration = InOutSectionDuration;
	Parms.InReloadInterruptionTag = std::move(InReloadInterruptionTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologBase.OnNativeInteract
// (Native, Event, Public, BlueprintEvent)

void ACrAudiologBase::OnNativeInteract()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologBase", "OnNativeInteract");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAudiologBase.OnRepWasPlayed
// (Final, Native, Public)

void ACrAudiologBase::OnRepWasPlayed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologBase", "OnRepWasPlayed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAudiologBase.ResetGuid
// (Final, Native, Public, BlueprintCallable)

void ACrAudiologBase::ResetGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologBase", "ResetGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAudiologBase.UpdateActorVisuals
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bInWasPlayed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrAudiologBase::UpdateActorVisuals(bool bInWasPlayed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologBase", "UpdateActorVisuals");

	Params::CrAudiologBase_UpdateActorVisuals Parms{};

	Parms.bInWasPlayed = bInWasPlayed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologBase.GetGuid
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid ACrAudiologBase::GetGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologBase", "GetGuid");

	Params::CrAudiologBase_GetGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologBase.GetInteractionText
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ACrAudiologBase::GetInteractionText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologBase", "GetInteractionText");

	Params::CrAudiologBase_GetInteractionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologsSubsystem.GetAudilogStatementForProgress
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  IndexFound                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  StatementProgress                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrAudiologsSubsystem::GetAudilogStatementForProgress(float Progress, int32* IndexFound, float* StatementProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologsSubsystem", "GetAudilogStatementForProgress");

	Params::CrAudiologsSubsystem_GetAudilogStatementForProgress Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IndexFound != nullptr)
		*IndexFound = Parms.IndexFound;

	if (StatementProgress != nullptr)
		*StatementProgress = Parms.StatementProgress;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologsSubsystem.GetAudilogTextForPosition
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   StatementProgress                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxLength                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  IndexFound                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCrAudiologsSubsystem::GetAudilogTextForPosition(float StatementProgress, float MaxLength, int32* IndexFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologsSubsystem", "GetAudilogTextForPosition");

	Params::CrAudiologsSubsystem_GetAudilogTextForPosition Parms{};

	Parms.StatementProgress = StatementProgress;
	Parms.MaxLength = MaxLength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IndexFound != nullptr)
		*IndexFound = Parms.IndexFound;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologsSubsystem.GetCurrentlyPlayingAudiologHandle
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FDataTableRowHandle*             OutHandle                                              (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrAudiologsSubsystem::GetCurrentlyPlayingAudiologHandle(struct FDataTableRowHandle* OutHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologsSubsystem", "GetCurrentlyPlayingAudiologHandle");

	Params::CrAudiologsSubsystem_GetCurrentlyPlayingAudiologHandle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHandle != nullptr)
		*OutHandle = std::move(Parms.OutHandle);

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologsSubsystem.GetCurrentlyPlayingAudiologProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrAudiologsSubsystem::GetCurrentlyPlayingAudiologProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologsSubsystem", "GetCurrentlyPlayingAudiologProgress");

	Params::CrAudiologsSubsystem_GetCurrentlyPlayingAudiologProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologsSubsystem.PauseAudiolog
// (Final, Native, Public, BlueprintCallable)

void UCrAudiologsSubsystem::PauseAudiolog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologsSubsystem", "PauseAudiolog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAudiologsSubsystem.PlayAudiolog
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FDataTableRowHandle&       AudilogDataTableHandle                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGuid&                     Guid                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrAudiologsSubsystem::PlayAudiolog(const struct FDataTableRowHandle& AudilogDataTableHandle, const struct FGuid& Guid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologsSubsystem", "PlayAudiolog");

	Params::CrAudiologsSubsystem_PlayAudiolog Parms{};

	Parms.AudilogDataTableHandle = std::move(AudilogDataTableHandle);
	Parms.Guid = std::move(Guid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAudiologsSubsystem.ResumeAudiolog
// (Final, Native, Public, BlueprintCallable)

void UCrAudiologsSubsystem::ResumeAudiolog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologsSubsystem", "ResumeAudiolog");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAudiologsSubsystem.StopAudiolog
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrAudiologsSubsystem::StopAudiolog()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAudiologsSubsystem", "StopAudiolog");

	Params::CrAudiologsSubsystem_StopAudiolog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBaseAttackStateSubsystem.OnAttackedCoreInfectionChanged
// (Final, Native, Protected)
// Parameters:
// const struct FMassEntityHandle&         EntityHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SignalName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBaseAttackStateSubsystem::OnAttackedCoreInfectionChanged(const struct FMassEntityHandle& EntityHandle, class FName SignalName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseAttackStateSubsystem", "OnAttackedCoreInfectionChanged");

	Params::CrBaseAttackStateSubsystem_OnAttackedCoreInfectionChanged Parms{};

	Parms.EntityHandle = std::move(EntityHandle);
	Parms.SignalName = SignalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseAttackStateSubsystem.OnAttackFinished
// (Final, Native, Public)
// Parameters:
// const struct FMassEntityHandle&         SpawnerEntity                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    FinishedSuccessful                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBaseAttackStateSubsystem::OnAttackFinished(const struct FMassEntityHandle& SpawnerEntity, bool FinishedSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseAttackStateSubsystem", "OnAttackFinished");

	Params::CrBaseAttackStateSubsystem_OnAttackFinished Parms{};

	Parms.SpawnerEntity = std::move(SpawnerEntity);
	Parms.FinishedSuccessful = FinishedSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCore.BP_OnActiveCoolingChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ActiveCooling                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::BP_OnActiveCoolingChanged(bool ActiveCooling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "BP_OnActiveCoolingChanged");

	Params::CrBaseCore_BP_OnActiveCoolingChanged Parms{};

	Parms.ActiveCooling = ActiveCooling;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBaseCore.BP_OnBaseCoreInfectionActorDestroyed
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// bool                                    LastActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ActorLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::BP_OnBaseCoreInfectionActorDestroyed(bool LastActor, const struct FVector& ActorLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "BP_OnBaseCoreInfectionActorDestroyed");

	Params::CrBaseCore_BP_OnBaseCoreInfectionActorDestroyed Parms{};

	Parms.LastActor = LastActor;
	Parms.ActorLocation = std::move(ActorLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBaseCore.BP_OnBeingAttackedStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bUnderAttack                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::BP_OnBeingAttackedStateChanged(bool bUnderAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "BP_OnBeingAttackedStateChanged");

	Params::CrBaseCore_BP_OnBeingAttackedStateChanged Parms{};

	Parms.bUnderAttack = bUnderAttack;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBaseCore.BP_OnInfectedChanged
// (Event, Protected, BlueprintEvent)

void ACrBaseCore::BP_OnInfectedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "BP_OnInfectedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrBaseCore.BP_OnInfectionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Infection                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InfectionActive                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::BP_OnInfectionChanged(float Infection, bool InfectionActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "BP_OnInfectionChanged");

	Params::CrBaseCore_BP_OnInfectionChanged Parms{};

	Parms.Infection = Infection;
	Parms.InfectionActive = InfectionActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBaseCore.BP_OnUpgreadLevelChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// uint8                                   NewUpgreadLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::BP_OnUpgreadLevelChanged(uint8 NewUpgreadLevel, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "BP_OnUpgreadLevelChanged");

	Params::CrBaseCore_BP_OnUpgreadLevelChanged Parms{};

	Parms.NewUpgreadLevel = NewUpgreadLevel;
	Parms.Immediately = Immediately;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBaseCore.BP_UpdateBaseCoreArea
// (Event, Protected, BlueprintEvent)

void ACrBaseCore::BP_UpdateBaseCoreArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "BP_UpdateBaseCoreArea");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrBaseCore.OnAttackedCoreChanged
// (Final, Native, Protected)
// Parameters:
// const struct FMassEntityHandle&         Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::OnAttackedCoreChanged(const struct FMassEntityHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "OnAttackedCoreChanged");

	Params::CrBaseCore_OnAttackedCoreChanged Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCore.OnBaseCoreChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrBaseCoreData&           Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACrBaseCore::OnBaseCoreChanged(const struct FCrBaseCoreData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "OnBaseCoreChanged");

	Params::CrBaseCore_OnBaseCoreChanged Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCore.OnBaseCoreInfectionActorDestroyed
// (Final, Native, Private, HasOutParams, HasDefaults)
// Parameters:
// bool                                    LastActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ActorLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::OnBaseCoreInfectionActorDestroyed(bool LastActor, const struct FVector& ActorLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "OnBaseCoreInfectionActorDestroyed");

	Params::CrBaseCore_OnBaseCoreInfectionActorDestroyed Parms{};

	Parms.LastActor = LastActor;
	Parms.ActorLocation = std::move(ActorLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCore.OnPlayerControlStateChanged
// (Final, Native, Protected)
// Parameters:
// ECrPlayerControlState                   State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::OnPlayerControlStateChanged(ECrPlayerControlState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "OnPlayerControlStateChanged");

	Params::CrBaseCore_OnPlayerControlStateChanged Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCore.OnTemperatureSignal
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         EntityHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SignalName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::OnTemperatureSignal(const struct FMassEntityHandle& EntityHandle, class FName SignalName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "OnTemperatureSignal");

	Params::CrBaseCore_OnTemperatureSignal Parms{};

	Parms.EntityHandle = std::move(EntityHandle);
	Parms.SignalName = SignalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCore.SetBaseCoreAreaVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Visible                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCore::SetBaseCoreAreaVisibility(bool Visible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "SetBaseCoreAreaVisibility");

	Params::CrBaseCore_SetBaseCoreAreaVisibility Parms{};

	Parms.Visible = Visible;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrBaseCore.GetCoreAreaSize
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACrBaseCore::GetCoreAreaSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCore", "GetCoreAreaSize");

	Params::CrBaseCore_GetCoreAreaSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBaseCoreReplicationHelper.LoadBaseCoreSaveData
// (Final, Native, Public)

void ACrBaseCoreReplicationHelper::LoadBaseCoreSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "LoadBaseCoreSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnBaseCoreBaseAttackEndedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrBaseCoreReplicationHelper::OnBaseCoreBaseAttackEndedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnBaseCoreBaseAttackEndedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnBaseCoreBaseAttackStartedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrBaseCoreReplicationHelper::OnBaseCoreBaseAttackStartedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnBaseCoreBaseAttackStartedMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnBaseCoreDeconstructedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FVector&                   BaseCoreLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCoreReplicationHelper::OnBaseCoreDeconstructedMulticast(const struct FVector& BaseCoreLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnBaseCoreDeconstructedMulticast");

	Params::CrBaseCoreReplicationHelper_OnBaseCoreDeconstructedMulticast Parms{};

	Parms.BaseCoreLocation = std::move(BaseCoreLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnBaseCoreUpgradedMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public, HasDefaults)
// Parameters:
// const struct FVector&                   BaseCoreLocation                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBaseCoreReplicationHelper::OnBaseCoreUpgradedMulticast(const struct FVector& BaseCoreLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnBaseCoreUpgradedMulticast");

	Params::CrBaseCoreReplicationHelper_OnBaseCoreUpgradedMulticast Parms{};

	Parms.BaseCoreLocation = std::move(BaseCoreLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnRep_BaseCoreAwaitingForBaseAttackAfterUpgrade
// (Final, Native, Private)

void ACrBaseCoreReplicationHelper::OnRep_BaseCoreAwaitingForBaseAttackAfterUpgrade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnRep_BaseCoreAwaitingForBaseAttackAfterUpgrade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnRep_CurrentBaseCoreBaseAttackTarget
// (Final, Native, Private)

void ACrBaseCoreReplicationHelper::OnRep_CurrentBaseCoreBaseAttackTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnRep_CurrentBaseCoreBaseAttackTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnRep_HUDAlienActivityAlienSignature
// (Final, Native, Private)

void ACrBaseCoreReplicationHelper::OnRep_HUDAlienActivityAlienSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnRep_HUDAlienActivityAlienSignature");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnRep_HUDAlienActivityCoreIntegrity
// (Final, Native, Private)

void ACrBaseCoreReplicationHelper::OnRep_HUDAlienActivityCoreIntegrity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnRep_HUDAlienActivityCoreIntegrity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.OnRep_HUDAlienActivityType
// (Final, Native, Private)

void ACrBaseCoreReplicationHelper::OnRep_HUDAlienActivityType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "OnRep_HUDAlienActivityType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBaseCoreReplicationHelper.SaveBaseCoreSaveData
// (Final, Native, Public)

void ACrBaseCoreReplicationHelper::SaveBaseCoreSaveData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBaseCoreReplicationHelper", "SaveBaseCoreSaveData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWaveTimerActor.MulticastOnEnviroWaveFinished
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrWaveTimerActor::MulticastOnEnviroWaveFinished(EEnviroWave WaveType, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWaveTimerActor", "MulticastOnEnviroWaveFinished");

	Params::CrWaveTimerActor_MulticastOnEnviroWaveFinished Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWaveTimerActor.MulticastOnEnviroWaveStarted
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEnviroWave                             InWaveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        InWaveStage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     InWaveSettings                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InWaveProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWaveTimerActor::MulticastOnEnviroWaveStarted(EEnviroWave InWaveType, EEnviroWaveStage InWaveStage, const struct FCrEnviroWaveSettings& InWaveSettings, float InWaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWaveTimerActor", "MulticastOnEnviroWaveStarted");

	Params::CrWaveTimerActor_MulticastOnEnviroWaveStarted Parms{};

	Parms.InWaveType = InWaveType;
	Parms.InWaveStage = InWaveStage;
	Parms.InWaveSettings = std::move(InWaveSettings);
	Parms.InWaveProgress = InWaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWaveTimerActor.OnEnviroWaveFinished
// (Native, Protected, HasOutParams)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrWaveTimerActor::OnEnviroWaveFinished(EEnviroWave WaveType, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWaveTimerActor", "OnEnviroWaveFinished");

	Params::CrWaveTimerActor_OnEnviroWaveFinished Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWaveTimerActor.OnEnviroWaveStarted
// (Native, Protected, HasOutParams)
// Parameters:
// EEnviroWave                             InWaveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        InWaveStage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     InWaveSettings                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InWaveProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWaveTimerActor::OnEnviroWaveStarted(EEnviroWave InWaveType, EEnviroWaveStage InWaveStage, const struct FCrEnviroWaveSettings& InWaveSettings, float InWaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWaveTimerActor", "OnEnviroWaveStarted");

	Params::CrWaveTimerActor_OnEnviroWaveStarted Parms{};

	Parms.InWaveType = InWaveType;
	Parms.InWaveStage = InWaveStage;
	Parms.InWaveSettings = std::move(InWaveSettings);
	Parms.InWaveProgress = InWaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWaveTimerActor.OnPreSaveStart
// (Final, Native, Private)

void ACrWaveTimerActor::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWaveTimerActor", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWaveTimerActor.OnRep_Pause
// (Final, Native, Private)

void ACrWaveTimerActor::OnRep_Pause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWaveTimerActor", "OnRep_Pause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWaveTimerActor.OnRep_Phase
// (Final, Native, Private)

void ACrWaveTimerActor::OnRep_Phase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWaveTimerActor", "OnRep_Phase");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWaveTimerActor.OnRep_Time
// (Final, Native, Private)

void ACrWaveTimerActor::OnRep_Time()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWaveTimerActor", "OnRep_Time");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInteractionComponent.CanInteract
// (Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrInteractionComponent::CanInteract(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractionComponent", "CanInteract");

	Params::CrInteractionComponent_CanInteract Parms{};

	Parms.InPc = InPc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractionComponent.GetInteractionAdditionalText
// (Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCrInteractionComponent::GetInteractionAdditionalText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractionComponent", "GetInteractionAdditionalText");

	Params::CrInteractionComponent_GetInteractionAdditionalText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractionComponent.GetInteractionDisplayName
// (Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UCrInteractionComponent::GetInteractionDisplayName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractionComponent", "GetInteractionDisplayName");

	Params::CrInteractionComponent_GetInteractionDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBindableProgressBar.SetValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBindableProgressBar::SetValue(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBindableProgressBar", "SetValue");

	Params::CrBindableProgressBar_SetValue Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBindableProgressBar.GetValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrBindableProgressBar::GetValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBindableProgressBar", "GetValue");

	Params::CrBindableProgressBar_GetValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBpMaterialUtilities.GetMaterialInstanceStaticSwitchParameterValueLegacy
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   SwitchFound                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrBpMaterialUtilities::GetMaterialInstanceStaticSwitchParameterValueLegacy(class UMaterialInterface* Instance, const class FName ParameterName, bool* SwitchFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBpMaterialUtilities", "GetMaterialInstanceStaticSwitchParameterValueLegacy");

	Params::CrBpMaterialUtilities_GetMaterialInstanceStaticSwitchParameterValueLegacy Parms{};

	Parms.Instance = Instance;
	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SwitchFound != nullptr)
		*SwitchFound = Parms.SwitchFound;

	return Parms.ReturnValue;
}


// Function Chimera.CrBpMaterialUtilities.LinearColorToInt32
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FLinearColor&              Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrBpMaterialUtilities::LinearColorToInt32(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBpMaterialUtilities", "LinearColorToInt32");

	Params::CrBpMaterialUtilities_LinearColorToInt32 Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBpMaterialUtilities.SetBuildingLinearColorPacked
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              Component                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBpMaterialUtilities::SetBuildingLinearColorPacked(class UPrimitiveComponent* Component, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBpMaterialUtilities", "SetBuildingLinearColorPacked");

	Params::CrBpMaterialUtilities_SetBuildingLinearColorPacked Parms{};

	Parms.Component = Component;
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBpMaterialUtilities.SetMaterialInstanceScalarParameterValueLegacy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstanceConstant*        Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBpMaterialUtilities::SetMaterialInstanceScalarParameterValueLegacy(class UMaterialInstanceConstant* Instance, const class FName ParameterName, const float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBpMaterialUtilities", "SetMaterialInstanceScalarParameterValueLegacy");

	Params::CrBpMaterialUtilities_SetMaterialInstanceScalarParameterValueLegacy Parms{};

	Parms.Instance = Instance;
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBpMaterialUtilities.SetMaterialInstanceStaticSwitchParameterValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBpMaterialUtilities::SetMaterialInstanceStaticSwitchParameterValue(class UMaterialInstance* Instance, class FName ParameterName, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBpMaterialUtilities", "SetMaterialInstanceStaticSwitchParameterValue");

	Params::CrBpMaterialUtilities_SetMaterialInstanceStaticSwitchParameterValue Parms{};

	Parms.Instance = Instance;
	Parms.ParameterName = ParameterName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingData.GetTagsOptions
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCrBuildingData::GetTagsOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingData", "GetTagsOptions");

	Params::CrBuildingData_GetTagsOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingFunctionLibrary.AddTemperatureToActorBuildings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USphereComponent*                 InSphere                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingFunctionLibrary::AddTemperatureToActorBuildings(class USphereComponent* InSphere, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBuildingFunctionLibrary", "AddTemperatureToActorBuildings");

	Params::CrBuildingFunctionLibrary_AddTemperatureToActorBuildings Parms{};

	Parms.InSphere = InSphere;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingFunctionLibrary.AddTemperatureToISMBuildings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USphereComponent*                 InSphere                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrBuildingFunctionLibrary::AddTemperatureToISMBuildings(class USphereComponent* InSphere, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBuildingFunctionLibrary", "AddTemperatureToISMBuildings");

	Params::CrBuildingFunctionLibrary_AddTemperatureToISMBuildings Parms{};

	Parms.InSphere = InSphere;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrBuildingFunctionLibrary.GetBuildingPayloadData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAuAPPayloadDataHandle&    InHandle                                               (Parm, NativeAccessSpecifierPublic)
// struct FCrBuildingPayloadData           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCrBuildingPayloadData UCrBuildingFunctionLibrary::GetBuildingPayloadData(const struct FAuAPPayloadDataHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBuildingFunctionLibrary", "GetBuildingPayloadData");

	Params::CrBuildingFunctionLibrary_GetBuildingPayloadData Parms{};

	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingFunctionLibrary.MakePayloadHandle
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UAuActorPlacementData*      InPlacementData                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrBuildingBeginPlayData&  BuildingBeginPlayData                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAuAPPayloadDataHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuAPPayloadDataHandle UCrBuildingFunctionLibrary::MakePayloadHandle(const class UAuActorPlacementData* InPlacementData, const struct FCrBuildingBeginPlayData& BuildingBeginPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrBuildingFunctionLibrary", "MakePayloadHandle");

	Params::CrBuildingFunctionLibrary_MakePayloadHandle Parms{};

	Parms.InPlacementData = InPlacementData;
	Parms.BuildingBeginPlayData = std::move(BuildingBeginPlayData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDestroyableActor.OnDamageTakenFromGas
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   InDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDestroyableActor::OnDamageTakenFromGas(class AActor* InInstigator, const struct FHitResult& HitResult, float InDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDestroyableActor", "OnDamageTakenFromGas");

	Params::CrDestroyableActor_OnDamageTakenFromGas Parms{};

	Parms.InInstigator = InInstigator;
	Parms.HitResult = std::move(HitResult);
	Parms.InDamage = InDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDestroyableActor.OnDiedFromGas
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              DamageTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDestroyableActor::OnDiedFromGas(class AActor* InInstigator, const struct FHitResult& HitResult, const struct FGameplayTag& DamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDestroyableActor", "OnDiedFromGas");

	Params::CrDestroyableActor_OnDiedFromGas Parms{};

	Parms.InInstigator = InInstigator;
	Parms.HitResult = std::move(HitResult);
	Parms.DamageTag = std::move(DamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDestroyableActor.OnRep_EntranceCollision
// (Final, Native, Public)

void ACrDestroyableActor::OnRep_EntranceCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDestroyableActor", "OnRep_EntranceCollision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDestroyableActor.SetCollisionForEntrance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bCollEnabled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDestroyableActor::SetCollisionForEntrance(bool bCollEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDestroyableActor", "SetCollisionForEntrance");

	Params::CrDestroyableActor_SetCollisionForEntrance Parms{};

	Parms.bCollEnabled = bCollEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrIvy.CallIvyHide
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrIvy::CallIvyHide(float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrIvy", "CallIvyHide");

	Params::CrIvy_CallIvyHide Parms{};

	Parms.InDuration = InDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrIvy.CallIvyHideInstant
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   InDuration                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrIvy::CallIvyHideInstant(float InDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrIvy", "CallIvyHideInstant");

	Params::CrIvy_CallIvyHideInstant Parms{};

	Parms.InDuration = InDuration;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrIvy.CallIvyUnhide
// (Event, Public, BlueprintEvent)

void ACrIvy::CallIvyUnhide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrIvy", "CallIvyUnhide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrIvy.SetIvyProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InProgress                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrIvy::SetIvyProgress(float InProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrIvy", "SetIvyProgress");

	Params::CrIvy_SetIvyProgress Parms{};

	Parms.InProgress = InProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrIvy.SetState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EIvyState                               InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrIvy::SetState(EIvyState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrIvy", "SetState");

	Params::CrIvy_SetState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrLocalPlayer.OnCompletedAudioDeviceSwap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FSwapAudioOutputResult&    SwapResult                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrLocalPlayer::OnCompletedAudioDeviceSwap(const struct FSwapAudioOutputResult& SwapResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrLocalPlayer", "OnCompletedAudioDeviceSwap");

	Params::CrLocalPlayer_OnCompletedAudioDeviceSwap Parms{};

	Parms.SwapResult = std::move(SwapResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrLocalPlayer.GetLocalSettings
// (Final, Native, Public, Const)
// Parameters:
// class UCrGameUserSettings*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrGameUserSettings* UCrLocalPlayer::GetLocalSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrLocalPlayer", "GetLocalSettings");

	Params::CrLocalPlayer_GetLocalSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrLocalPlayer.GetSharedSettings
// (Final, Native, Public, Const)
// Parameters:
// class UCrSettingsShared*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrSettingsShared* UCrLocalPlayer::GetSharedSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrLocalPlayer", "GetSharedSettings");

	Params::CrLocalPlayer_GetSharedSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrBuildingSplineActorBase.OnSplineReady
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class USplineComponent*                 InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrBuildingSplineActorBase::OnSplineReady(class USplineComponent* InSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrBuildingSplineActorBase", "OnSplineReady");

	Params::CrBuildingSplineActorBase_OnSplineReady Parms{};

	Parms.InSpline = InSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCameraEffectsComponent.OnPlayerControllerReady
// (Final, Native, Protected)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCameraEffectsComponent::OnPlayerControllerReady(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCameraEffectsComponent", "OnPlayerControllerReady");

	Params::CrCameraEffectsComponent_OnPlayerControllerReady Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCameraGameplayEffect.ActivateCameraGameplayEffectEffect
// (Final, Native, Public, BlueprintCallable)

void UCrCameraGameplayEffect::ActivateCameraGameplayEffectEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCameraGameplayEffect", "ActivateCameraGameplayEffectEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCameraGameplayEffect.DeactivateCameraGameplayEffectEffect
// (Final, Native, Public, BlueprintCallable)

void UCrCameraGameplayEffect::DeactivateCameraGameplayEffectEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCameraGameplayEffect", "DeactivateCameraGameplayEffectEffect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCameraGameplayEffect.GetTimeFromLastActivation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrCameraGameplayEffect::GetTimeFromLastActivation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCameraGameplayEffect", "GetTimeFromLastActivation");

	Params::CrCameraGameplayEffect_GetTimeFromLastActivation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCameraGameplayEffect.OnInitialized
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      GameplayEffect                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  OwnerRootComponent                                     (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCameraGameplayEffect::OnInitialized(class UAbilitySystemComponent* AbilitySystemComponent, TSubclassOf<class UGameplayEffect> GameplayEffect, class USceneComponent* OwnerRootComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCameraGameplayEffect", "OnInitialized");

	Params::CrCameraGameplayEffect_OnInitialized Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.GameplayEffect = GameplayEffect;
	Parms.OwnerRootComponent = OwnerRootComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCharacterDroneBase.OnRep_Location
// (Final, Native, Private)

void ACrCharacterDroneBase::OnRep_Location()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterDroneBase", "OnRep_Location");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterDroneBase.OnRep_Rotation
// (Final, Native, Private)

void ACrCharacterDroneBase::OnRep_Rotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterDroneBase", "OnRep_Rotation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterDroneBase.ReturnToPlayer
// (Final, Native, Public, BlueprintCallable)

void ACrCharacterDroneBase::ReturnToPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterDroneBase", "ReturnToPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterDroneBase.ServerReturnToPlayer
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrCharacterDroneBase::ServerReturnToPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterDroneBase", "ServerReturnToPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterDroneBase.ServerSetDroneTransform
// (Net, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACrCharacterDroneBase::ServerSetDroneTransform(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterDroneBase", "ServerSetDroneTransform");

	Params::CrCharacterDroneBase_ServerSetDroneTransform Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointSubsystem.GetDefaultSpawnPointForPlayerController
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PC                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACrCharacterSpawnPointBase*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACrCharacterSpawnPointBase* UCrCharacterSpawnPointSubsystem::GetDefaultSpawnPointForPlayerController(class APlayerController* PC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointSubsystem", "GetDefaultSpawnPointForPlayerController");

	Params::CrCharacterSpawnPointSubsystem_GetDefaultSpawnPointForPlayerController Parms{};

	Parms.PC = PC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCharacterSpawnPointSubsystem.OnBuildingSpawnPointStateChanged
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Signal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterSpawnPointSubsystem::OnBuildingSpawnPointStateChanged(const struct FMassEntityHandle& InHandle, class FName Signal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointSubsystem", "OnBuildingSpawnPointStateChanged");

	Params::CrCharacterSpawnPointSubsystem_OnBuildingSpawnPointStateChanged Parms{};

	Parms.InHandle = std::move(InHandle);
	Parms.Signal = Signal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCharacterSpawnPointSubsystem.RegisterDefaultSpawnPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrCharacterSpawnPointBase*       InSpawnPoint                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCharacterSpawnPointSubsystem::RegisterDefaultSpawnPoint(class ACrCharacterSpawnPointBase* InSpawnPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCharacterSpawnPointSubsystem", "RegisterDefaultSpawnPoint");

	Params::CrCharacterSpawnPointSubsystem_RegisterDefaultSpawnPoint Parms{};

	Parms.InSpawnPoint = InSpawnPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrElectricityConnectionHelper.NativeOverlapBeginEvent
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrElectricityConnectionHelper::NativeOverlapBeginEvent(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrElectricityConnectionHelper", "NativeOverlapBeginEvent");

	Params::CrElectricityConnectionHelper_NativeOverlapBeginEvent Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContaminationActor.BP_OnDamageProtectionChanged
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrContaminationActor::BP_OnDamageProtectionChanged(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "BP_OnDamageProtectionChanged");

	Params::CrContaminationActor_BP_OnDamageProtectionChanged Parms{};

	Parms.IsActive = IsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrContaminationActor.InitAbilitySystem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bForceComponentsCreation                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrContaminationActor::InitAbilitySystem(bool bForceComponentsCreation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "InitAbilitySystem");

	Params::CrContaminationActor_InitAbilitySystem Parms{};

	Parms.bForceComponentsCreation = bForceComponentsCreation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContaminationActor.K2_OnDamageTaken
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           InInstigator                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   InDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrContaminationActor::K2_OnDamageTaken(class AActor* InInstigator, const struct FHitResult& HitResult, float InDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "K2_OnDamageTaken");

	Params::CrContaminationActor_K2_OnDamageTaken Parms{};

	Parms.InInstigator = InInstigator;
	Parms.HitResult = std::move(HitResult);
	Parms.InDamage = InDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContaminationActor.OnGrowthProgress
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrContaminationActor::OnGrowthProgress(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "OnGrowthProgress");

	Params::CrContaminationActor_OnGrowthProgress Parms{};

	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrContaminationActor.OnRep_IsSpawnerActive
// (Final, Native, Protected)

void ACrContaminationActor::OnRep_IsSpawnerActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "OnRep_IsSpawnerActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContaminationActor.OnSetSpawnerActive
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrContaminationActor::OnSetSpawnerActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "OnSetSpawnerActive");

	Params::CrContaminationActor_OnSetSpawnerActive Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrContaminationActor.OnSpawnRequested
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrContaminationActor::OnSpawnRequested(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "OnSpawnRequested");

	Params::CrContaminationActor_OnSpawnRequested Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrContaminationActor.OnSpawnTriggerOverlap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrContaminationActor::OnSpawnTriggerOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "OnSpawnTriggerOverlap");

	Params::CrContaminationActor_OnSpawnTriggerOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContaminationActor.SetInfectionNormalized
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InInfection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrContaminationActor::SetInfectionNormalized(float InInfection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "SetInfectionNormalized");

	Params::CrContaminationActor_SetInfectionNormalized Parms{};

	Parms.InInfection = InInfection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContaminationActor.SetIsSpawnerActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInIsSpawnerActive                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrContaminationActor::SetIsSpawnerActive(bool bInIsSpawnerActive, bool bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "SetIsSpawnerActive");

	Params::CrContaminationActor_SetIsSpawnerActive Parms{};

	Parms.bInIsSpawnerActive = bInIsSpawnerActive;
	Parms.bForce = bForce;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContaminationActor.SpawnEnemies
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     InAiType                                               (Parm, NativeAccessSpecifierPublic)

void ACrContaminationActor::SpawnEnemies(const struct FVector& Location, const struct FGameplayTagContainer& InAiType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "SpawnEnemies");

	Params::CrContaminationActor_SpawnEnemies Parms{};

	Parms.Location = std::move(Location);
	Parms.InAiType = std::move(InAiType);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContaminationActor.GetDamageProtectionActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrContaminationActor::GetDamageProtectionActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "GetDamageProtectionActive");

	Params::CrContaminationActor_GetDamageProtectionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrContaminationActor.GetHealthValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrContaminationActor::GetHealthValue() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "GetHealthValue");

	Params::CrContaminationActor_GetHealthValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrContaminationActor.GetInfection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrContaminationActor::GetInfection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContaminationActor", "GetInfection");

	Params::CrContaminationActor_GetInfection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrContextEffectsInterface.AnimMotionEffect
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const class FName                       bone                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              MotionEffect                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  StaticMeshComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  RotationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const class UAnimSequenceBase*          AnimationSequence                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bHitSuccess                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Contexts                                               (Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   VFXScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioPitch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrContextEffectsInterface::AnimMotionEffect(const class FName bone, const struct FGameplayTag& MotionEffect, class USceneComponent* StaticMeshComponent, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const class UAnimSequenceBase* AnimationSequence, const bool bHitSuccess, const struct FHitResult& HitResult, const struct FGameplayTagContainer& Contexts, const struct FVector& VFXScale, float AudioVolume, float AudioPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrContextEffectsInterface", "AnimMotionEffect");

	Params::CrContextEffectsInterface_AnimMotionEffect Parms{};

	Parms.bone = bone;
	Parms.MotionEffect = std::move(MotionEffect);
	Parms.StaticMeshComponent = StaticMeshComponent;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.AnimationSequence = AnimationSequence;
	Parms.bHitSuccess = bHitSuccess;
	Parms.HitResult = std::move(HitResult);
	Parms.Contexts = std::move(Contexts);
	Parms.VFXScale = std::move(VFXScale);
	Parms.AudioVolume = AudioVolume;
	Parms.AudioPitch = AudioPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContextEffectsLibrary.GetEffects
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Effect                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Context                                                (ConstParm, Parm, NativeAccessSpecifierPublic)
// TArray<class USoundBase*>*              Sounds                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UNiagaraSystem*>*          NiagaraSystems                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCrContextEffectsLibrary::GetEffects(const struct FGameplayTag& Effect, const struct FGameplayTagContainer& Context, TArray<class USoundBase*>* Sounds, TArray<class UNiagaraSystem*>* NiagaraSystems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectsLibrary", "GetEffects");

	Params::CrContextEffectsLibrary_GetEffects Parms{};

	Parms.Effect = std::move(Effect);
	Parms.Context = std::move(Context);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Sounds != nullptr)
		*Sounds = std::move(Parms.Sounds);

	if (NiagaraSystems != nullptr)
		*NiagaraSystems = std::move(Parms.NiagaraSystems);
}


// Function Chimera.CrContextEffectsLibrary.LoadEffects
// (Final, Native, Public, BlueprintCallable)

void UCrContextEffectsLibrary::LoadEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectsLibrary", "LoadEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBordersReplActor.MulticastRadiationLevelChanged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// int32                                   CurrentRadiationLevel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewRadiationLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrRadiationBordersReplActor::MulticastRadiationLevelChanged(int32 CurrentRadiationLevel, int32 NewRadiationLevel, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBordersReplActor", "MulticastRadiationLevelChanged");

	Params::CrRadiationBordersReplActor_MulticastRadiationLevelChanged Parms{};

	Parms.CurrentRadiationLevel = CurrentRadiationLevel;
	Parms.NewRadiationLevel = NewRadiationLevel;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContextEffectsSubsystem.GetContextFromSurfaceType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EPhysicalSurface                        PhysicalSurface                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag*                    Context                                                (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrContextEffectsSubsystem::GetContextFromSurfaceType(EPhysicalSurface PhysicalSurface, struct FGameplayTag* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectsSubsystem", "GetContextFromSurfaceType");

	Params::CrContextEffectsSubsystem_GetContextFromSurfaceType Parms{};

	Parms.PhysicalSurface = PhysicalSurface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Context != nullptr)
		*Context = std::move(Parms.Context);

	return Parms.ReturnValue;
}


// Function Chimera.CrContextEffectsSubsystem.LoadAndAddContextEffectsLibraries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<TSoftObjectPtr<class UCrContextEffectsLibrary>>&ContextEffectsLibraries                                (Parm, UObjectWrapper, NativeAccessSpecifierPublic)

void UCrContextEffectsSubsystem::LoadAndAddContextEffectsLibraries(class AActor* OwningActor, const TSet<TSoftObjectPtr<class UCrContextEffectsLibrary>>& ContextEffectsLibraries)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectsSubsystem", "LoadAndAddContextEffectsLibraries");

	Params::CrContextEffectsSubsystem_LoadAndAddContextEffectsLibraries Parms{};

	Parms.OwningActor = OwningActor;
	Parms.ContextEffectsLibraries = std::move(ContextEffectsLibraries);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrContextEffectsSubsystem.SpawnContextEffects
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     SpawningActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  AttachToComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       AttachPoint                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  RotationOffset                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Effect                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer&     Contexts                                               (Parm, NativeAccessSpecifierPublic)
// TArray<class UAudioComponent*>*         AudioOut                                               (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UNiagaraComponent*>*       NiagaraOut                                             (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FVector&                   VFXScale                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioVolume                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AudioPitch                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrContextEffectsSubsystem::SpawnContextEffects(const class AActor* SpawningActor, class USceneComponent* AttachToComponent, const class FName AttachPoint, const struct FVector& LocationOffset, const struct FRotator& RotationOffset, const struct FGameplayTag& Effect, const struct FGameplayTagContainer& Contexts, TArray<class UAudioComponent*>* AudioOut, TArray<class UNiagaraComponent*>* NiagaraOut, const struct FVector& VFXScale, float AudioVolume, float AudioPitch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectsSubsystem", "SpawnContextEffects");

	Params::CrContextEffectsSubsystem_SpawnContextEffects Parms{};

	Parms.SpawningActor = SpawningActor;
	Parms.AttachToComponent = AttachToComponent;
	Parms.AttachPoint = AttachPoint;
	Parms.LocationOffset = std::move(LocationOffset);
	Parms.RotationOffset = std::move(RotationOffset);
	Parms.Effect = std::move(Effect);
	Parms.Contexts = std::move(Contexts);
	Parms.VFXScale = std::move(VFXScale);
	Parms.AudioVolume = AudioVolume;
	Parms.AudioPitch = AudioPitch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AudioOut != nullptr)
		*AudioOut = std::move(Parms.AudioOut);

	if (NiagaraOut != nullptr)
		*NiagaraOut = std::move(Parms.NiagaraOut);
}


// Function Chimera.CrContextEffectsSubsystem.UnloadAndRemoveContextEffectsLibraries
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OwningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrContextEffectsSubsystem::UnloadAndRemoveContextEffectsLibraries(class AActor* OwningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrContextEffectsSubsystem", "UnloadAndRemoveContextEffectsLibraries");

	Params::CrContextEffectsSubsystem_UnloadAndRemoveContextEffectsLibraries Parms{};

	Parms.OwningActor = OwningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCooler.GetHeaterCoolerState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// ECrMassHeaterCoolerState                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrMassHeaterCoolerState ACrCooler::GetHeaterCoolerState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCooler", "GetHeaterCoolerState");

	Params::CrCooler_GetHeaterCoolerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCooler.OnHeaterCoolerConnectionsChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<class FName>&              ConnectedSockets                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACrCooler::OnHeaterCoolerConnectionsChanged(const TArray<class FName>& ConnectedSockets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCooler", "OnHeaterCoolerConnectionsChanged");

	Params::CrCooler_OnHeaterCoolerConnectionsChanged Parms{};

	Parms.ConnectedSockets = std::move(ConnectedSockets);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCooler.OnHeaterCoolerInventoryChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   UsedSpaceNormalized                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCooler::OnHeaterCoolerInventoryChanged(float UsedSpaceNormalized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCooler", "OnHeaterCoolerInventoryChanged");

	Params::CrCooler_OnHeaterCoolerInventoryChanged Parms{};

	Parms.UsedSpaceNormalized = UsedSpaceNormalized;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCooler.OnHeaterCoolerStateChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// ECrMassHeaterCoolerState                State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCooler::OnHeaterCoolerStateChanged(ECrMassHeaterCoolerState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCooler", "OnHeaterCoolerStateChanged");

	Params::CrCooler_OnHeaterCoolerStateChanged Parms{};

	Parms.State = State;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrCorporationsOwner.DebugLockFeature
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrCorporationUnlockedFeatures          InFeature                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCorporationsOwner::DebugLockFeature(ECrCorporationUnlockedFeatures InFeature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "DebugLockFeature");

	Params::CrCorporationsOwner_DebugLockFeature Parms{};

	Parms.InFeature = InFeature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.DebugSetUnlockedInventorySlots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InUnlockedInventorySlots                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCorporationsOwner::DebugSetUnlockedInventorySlots(int32 InUnlockedInventorySlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "DebugSetUnlockedInventorySlots");

	Params::CrCorporationsOwner_DebugSetUnlockedInventorySlots Parms{};

	Parms.InUnlockedInventorySlots = InUnlockedInventorySlots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.DebugUnlockFeature
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrCorporationUnlockedFeatures          InFeature                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCorporationsOwner::DebugUnlockFeature(ECrCorporationUnlockedFeatures InFeature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "DebugUnlockFeature");

	Params::CrCorporationsOwner_DebugUnlockFeature Parms{};

	Parms.InFeature = InFeature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.OnPreSaveStart
// (Final, Native, Private)

void ACrCorporationsOwner::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.OnRep_DataPoints
// (Final, Native, Private)

void ACrCorporationsOwner::OnRep_DataPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "OnRep_DataPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.OnRep_StartingCorporationMaxedOut
// (Final, Native, Private)

void ACrCorporationsOwner::OnRep_StartingCorporationMaxedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "OnRep_StartingCorporationMaxedOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.OnRep_UnlockedFeatures
// (Final, Native, Private)

void ACrCorporationsOwner::OnRep_UnlockedFeatures()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "OnRep_UnlockedFeatures");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.OnRep_UnlockedInventorySlots
// (Final, Native, Private)

void ACrCorporationsOwner::OnRep_UnlockedInventorySlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "OnRep_UnlockedInventorySlots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.OnSaveLoaded
// (Final, Native, Private)

void ACrCorporationsOwner::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.OnTutorialCompleted
// (Final, Native, Public)
// Parameters:
// bool                                    InNotify                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrCorporationsOwner::OnTutorialCompleted(bool InNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "OnTutorialCompleted");

	Params::CrCorporationsOwner_OnTutorialCompleted Parms{};

	Parms.InNotify = InNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorporationsOwner.GetUnlockedInventorySlotsNumber
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrCorporationsOwner::GetUnlockedInventorySlotsNumber() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "GetUnlockedInventorySlotsNumber");

	Params::CrCorporationsOwner_GetUnlockedInventorySlotsNumber Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCorporationsOwner.IsFeatureUnlocked
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECrCorporationUnlockedFeatures          InFeature                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrCorporationsOwner::IsFeatureUnlocked(ECrCorporationUnlockedFeatures InFeature) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorporationsOwner", "IsFeatureUnlocked");

	Params::CrCorporationsOwner_IsFeatureUnlocked Parms{};

	Parms.InFeature = InFeature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCorrosionAttributeSet.OnRep_CurrentCorrosion
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentCorrosion                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrCorrosionAttributeSet::OnRep_CurrentCorrosion(const struct FGameplayAttributeData& OldCurrentCorrosion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorrosionAttributeSet", "OnRep_CurrentCorrosion");

	Params::CrCorrosionAttributeSet_OnRep_CurrentCorrosion Parms{};

	Parms.OldCurrentCorrosion = std::move(OldCurrentCorrosion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorrosionAttributeSet.OnRep_MaxCorrosion
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxCorrosion                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrCorrosionAttributeSet::OnRep_MaxCorrosion(const struct FGameplayAttributeData& OldMaxCorrosion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorrosionAttributeSet", "OnRep_MaxCorrosion");

	Params::CrCorrosionAttributeSet_OnRep_MaxCorrosion Parms{};

	Parms.OldMaxCorrosion = std::move(OldMaxCorrosion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCorrosionAttributeSet.OnRep_MinCorrosion
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinCorrosion                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrCorrosionAttributeSet::OnRep_MinCorrosion(const struct FGameplayAttributeData& OldMinCorrosion)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCorrosionAttributeSet", "OnRep_MinCorrosion");

	Params::CrCorrosionAttributeSet_OnRep_MinCorrosion Parms{};

	Parms.OldMinCorrosion = std::move(OldMinCorrosion);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.BP_DebugAddItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UAuItemDataBase>      InItem                                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::BP_DebugAddItem(TSubclassOf<class UAuItemDataBase> InItem, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "BP_DebugAddItem");

	Params::CrInventoryComponent_BP_DebugAddItem Parms{};

	Parms.InItem = InItem;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.BP_RemoveItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UAuItemDataBase*            InItem                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::BP_RemoveItem(const class UAuItemDataBase* InItem, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "BP_RemoveItem");

	Params::CrInventoryComponent_BP_RemoveItem Parms{};

	Parms.InItem = InItem;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.FindDroppedItemChestStorageInCloseProximity
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UAuItemDataBase*            WantedItemData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DetectionRadius                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrBuildingItemStorageComponent** OutStorageComponent                                    (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrInventoryComponent::FindDroppedItemChestStorageInCloseProximity(const class UAuItemDataBase* WantedItemData, float DetectionRadius, class UCrBuildingItemStorageComponent** OutStorageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "FindDroppedItemChestStorageInCloseProximity");

	Params::CrInventoryComponent_FindDroppedItemChestStorageInCloseProximity Parms{};

	Parms.WantedItemData = WantedItemData;
	Parms.DetectionRadius = DetectionRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStorageComponent != nullptr)
		*OutStorageComponent = Parms.OutStorageComponent;

	return Parms.ReturnValue;
}


// Function Chimera.CrInventoryComponent.OnRep_Slots
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TArray<struct FCrInventorySlot>&  OldSlots                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCrInventoryComponent::OnRep_Slots(const TArray<struct FCrInventorySlot>& OldSlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "OnRep_Slots");

	Params::CrInventoryComponent_OnRep_Slots Parms{};

	Parms.OldSlots = std::move(OldSlots);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerAddItemFromInventory
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 FromSlot                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrSlotId&                 ToSlot                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrInventoryComponent*            FromComponent                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerAddItemFromInventory(const struct FCrSlotId& FromSlot, const struct FCrSlotId& ToSlot, class UCrInventoryComponent* FromComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerAddItemFromInventory");

	Params::CrInventoryComponent_ServerAddItemFromInventory Parms{};

	Parms.FromSlot = std::move(FromSlot);
	Parms.ToSlot = std::move(ToSlot);
	Parms.FromComponent = FromComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerAddItemFromStorage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 FromSlot                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrSlotId&                 ToSlot                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&InStorageComponent                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerAddItemFromStorage(const struct FCrSlotId& FromSlot, const struct FCrSlotId& ToSlot, const struct FCrMassComponentReplicationHelper& InStorageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerAddItemFromStorage");

	Params::CrInventoryComponent_ServerAddItemFromStorage Parms{};

	Parms.FromSlot = std::move(FromSlot);
	Parms.ToSlot = std::move(ToSlot);
	Parms.InStorageComponent = std::move(InStorageComponent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerAddItemToStorage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 FromSlot                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrSlotId&                 ToSlot                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&InStorageComponent                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerAddItemToStorage(const struct FCrSlotId& FromSlot, const struct FCrSlotId& ToSlot, const struct FCrMassComponentReplicationHelper& InStorageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerAddItemToStorage");

	Params::CrInventoryComponent_ServerAddItemToStorage Parms{};

	Parms.FromSlot = std::move(FromSlot);
	Parms.ToSlot = std::move(ToSlot);
	Parms.InStorageComponent = std::move(InStorageComponent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerAddNewItemToInventorySlot
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 InSlot                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAuItemDataBase*            InItem                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerAddNewItemToInventorySlot(const struct FCrSlotId& InSlot, const class UAuItemDataBase* InItem, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerAddNewItemToInventorySlot");

	Params::CrInventoryComponent_ServerAddNewItemToInventorySlot Parms{};

	Parms.InSlot = std::move(InSlot);
	Parms.InItem = InItem;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerDebugAddItem
// (Net, Native, Event, Public, NetServer)
// Parameters:
// const class UAuItemDataBase*            InItem                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerDebugAddItem(const class UAuItemDataBase* InItem, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerDebugAddItem");

	Params::CrInventoryComponent_ServerDebugAddItem Parms{};

	Parms.InItem = InItem;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerDropItemAtLocation
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FAuItemId&                 InItemId                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InLocation                                             (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerDropItemAtLocation(const struct FAuItemId& InItemId, const struct FVector& InLocation, bool bRemove, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerDropItemAtLocation");

	Params::CrInventoryComponent_ServerDropItemAtLocation Parms{};

	Parms.InItemId = std::move(InItemId);
	Parms.InLocation = std::move(InLocation);
	Parms.bRemove = bRemove;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerDropItemToStorage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FAuItemId&                 InItemId                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&Storage                                                (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bRemove                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerDropItemToStorage(const struct FAuItemId& InItemId, const struct FCrMassComponentReplicationHelper& Storage, bool bRemove, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerDropItemToStorage");

	Params::CrInventoryComponent_ServerDropItemToStorage Parms{};

	Parms.InItemId = std::move(InItemId);
	Parms.Storage = std::move(Storage);
	Parms.bRemove = bRemove;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerMergeItems
// (Net, NetReliable, Native, Event, Public, NetServer)

void UCrInventoryComponent::ServerMergeItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerMergeItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerMoveItemBetweenSlots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 InFromSlot                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrSlotId&                 InToSlot                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerMoveItemBetweenSlots(const struct FCrSlotId& InFromSlot, const struct FCrSlotId& InToSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerMoveItemBetweenSlots");

	Params::CrInventoryComponent_ServerMoveItemBetweenSlots Parms{};

	Parms.InFromSlot = std::move(InFromSlot);
	Parms.InToSlot = std::move(InToSlot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerMoveItemsBetweenSlotsInStorage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 FromSlot                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrSlotId&                 ToSlot                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&InStorageComponent                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerMoveItemsBetweenSlotsInStorage(const struct FCrSlotId& FromSlot, const struct FCrSlotId& ToSlot, const struct FCrMassComponentReplicationHelper& InStorageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerMoveItemsBetweenSlotsInStorage");

	Params::CrInventoryComponent_ServerMoveItemsBetweenSlotsInStorage Parms{};

	Parms.FromSlot = std::move(FromSlot);
	Parms.ToSlot = std::move(ToSlot);
	Parms.InStorageComponent = std::move(InStorageComponent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerMoveItemToInventory
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 InSlot                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAuItemDataBase*            ItemType                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuItemId&                 ItemId                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrBuildingItemStorageComponent*  From                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerMoveItemToInventory(const struct FCrSlotId& InSlot, const class UAuItemDataBase* ItemType, const struct FAuItemId& ItemId, int32 Amount, class UCrBuildingItemStorageComponent* From)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerMoveItemToInventory");

	Params::CrInventoryComponent_ServerMoveItemToInventory Parms{};

	Parms.InSlot = std::move(InSlot);
	Parms.ItemType = ItemType;
	Parms.ItemId = std::move(ItemId);
	Parms.Amount = Amount;
	Parms.From = From;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerPickAllFrom
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassComponentReplicationHelper&InStorageComponent                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerPickAllFrom(const struct FCrMassComponentReplicationHelper& InStorageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerPickAllFrom");

	Params::CrInventoryComponent_ServerPickAllFrom Parms{};

	Parms.InStorageComponent = std::move(InStorageComponent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerResizeInventory
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// int32                                   Columns                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Rows                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerResizeInventory(int32 Columns, int32 Rows)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerResizeInventory");

	Params::CrInventoryComponent_ServerResizeInventory Parms{};

	Parms.Columns = Columns;
	Parms.Rows = Rows;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerSort
// (Net, NetReliable, Native, Event, Public, NetServer)

void UCrInventoryComponent::ServerSort()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerSort");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerTransferAllTo
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassComponentReplicationHelper&InStorageComponent                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerTransferAllTo(const struct FCrMassComponentReplicationHelper& InStorageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerTransferAllTo");

	Params::CrInventoryComponent_ServerTransferAllTo Parms{};

	Parms.InStorageComponent = std::move(InStorageComponent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.ServerTransferAllToInventory
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassComponentReplicationHelper&InStorageComponent                                     (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrInventoryComponent::ServerTransferAllToInventory(const struct FCrMassComponentReplicationHelper& InStorageComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "ServerTransferAllToInventory");

	Params::CrInventoryComponent_ServerTransferAllToInventory Parms{};

	Parms.InStorageComponent = std::move(InStorageComponent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInventoryComponent.BP_GetItemAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UAuItemDataBase*            InItem                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrInventoryComponent::BP_GetItemAmount(const class UAuItemDataBase* InItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "BP_GetItemAmount");

	Params::CrInventoryComponent_BP_GetItemAmount Parms{};

	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInventoryComponent.BP_GetItemClassAmount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UClass*                           InItemClass                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrInventoryComponent::BP_GetItemClassAmount(class UClass* InItemClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInventoryComponent", "BP_GetItemClassAmount");

	Params::CrInventoryComponent_BP_GetItemClassAmount Parms{};

	Parms.InItemClass = InItemClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrItemReceiverBuilding.OnItemsReceived
// (Event, Public, BlueprintEvent)

void ACrItemReceiverBuilding::OnItemsReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrItemReceiverBuilding", "OnItemsReceived");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrDamageFeedbackComponent.OnGEAppliedToSelf
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UAbilitySystemComponent*          TargetASC                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayEffectSpec&       Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FActiveGameplayEffectHandle&Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDamageFeedbackComponent::OnGEAppliedToSelf(class UAbilitySystemComponent* TargetASC, const struct FGameplayEffectSpec& Spec, const struct FActiveGameplayEffectHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDamageFeedbackComponent", "OnGEAppliedToSelf");

	Params::CrDamageFeedbackComponent_OnGEAppliedToSelf Parms{};

	Parms.TargetASC = TargetASC;
	Parms.Spec = std::move(Spec);
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDataLayerEventInterface.OnDataLayerActivate
// (Native, Public)
// Parameters:
// bool                                    FromLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrDataLayerEventInterface::OnDataLayerActivate(bool FromLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrDataLayerEventInterface", "OnDataLayerActivate");

	Params::CrDataLayerEventInterface_OnDataLayerActivate Parms{};

	Parms.FromLoad = FromLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDataLayerEventInterface.OnDataLayerActivate_Exec
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    FromLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrDataLayerEventInterface::OnDataLayerActivate_Exec(bool FromLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrDataLayerEventInterface", "OnDataLayerActivate_Exec");

	Params::CrDataLayerEventInterface_OnDataLayerActivate_Exec Parms{};

	Parms.FromLoad = FromLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDataLayerEventInterface.OnDataLayerDeactivate
// (Native, Public)
// Parameters:
// bool                                    FromLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrDataLayerEventInterface::OnDataLayerDeactivate(bool FromLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrDataLayerEventInterface", "OnDataLayerDeactivate");

	Params::CrDataLayerEventInterface_OnDataLayerDeactivate Parms{};

	Parms.FromLoad = FromLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDataLayerEventInterface.OnDataLayerDeactivate_Exec
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    FromLoad                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrDataLayerEventInterface::OnDataLayerDeactivate_Exec(bool FromLoad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrDataLayerEventInterface", "OnDataLayerDeactivate_Exec");

	Params::CrDataLayerEventInterface_OnDataLayerDeactivate_Exec Parms{};

	Parms.FromLoad = FromLoad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDedicatedServerSettingsComp.AdminConnect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrDedicatedServerSettingsComp::AdminConnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "AdminConnect");

	Params::CrDedicatedServerSettingsComp_AdminConnect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.CheckPassword
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InPassword                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrDedicatedServerSettingsComp::CheckPassword(const class FString& InPassword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "CheckPassword");

	Params::CrDedicatedServerSettingsComp_CheckPassword Parms{};

	Parms.InPassword = std::move(InPassword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.GetPlayerPasswordPresent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InToken                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrDedicatedServerSettingsComp::GetPlayerPasswordPresent(const class FString& InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "GetPlayerPasswordPresent");

	Params::CrDedicatedServerSettingsComp_GetPlayerPasswordPresent Parms{};

	Parms.InToken = std::move(InToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.GetSavedSessions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InToken                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrDedicatedServerSettingsComp::GetSavedSessions(const class FString& InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "GetSavedSessions");

	Params::CrDedicatedServerSettingsComp_GetSavedSessions Parms{};

	Parms.InToken = std::move(InToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.GetSessionSaves
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InSessionName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InToken                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrDedicatedServerSettingsComp::GetSessionSaves(const class FString& InSessionName, const class FString& InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "GetSessionSaves");

	Params::CrDedicatedServerSettingsComp_GetSessionSaves Parms{};

	Parms.InSessionName = std::move(InSessionName);
	Parms.InToken = std::move(InToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.IsPasswordSet
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrDedicatedServerSettingsComp::IsPasswordSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "IsPasswordSet");

	Params::CrDedicatedServerSettingsComp_IsPasswordSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.LoadMainMap
// (Final, Native, Public, BlueprintCallable)

void UCrDedicatedServerSettingsComp::LoadMainMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "LoadMainMap");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDedicatedServerSettingsComp.LoadSessionSave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InSessionName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InSaveGameName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InToken                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrDedicatedServerSettingsComp::LoadSessionSave(const class FString& InSessionName, const class FString& InSaveGameName, const class FString& InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "LoadSessionSave");

	Params::CrDedicatedServerSettingsComp_LoadSessionSave Parms{};

	Parms.InSessionName = std::move(InSessionName);
	Parms.InSaveGameName = std::move(InSaveGameName);
	Parms.InToken = std::move(InToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.SetPassword
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InPassword                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrDedicatedServerSettingsComp::SetPassword(const class FString& InPassword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "SetPassword");

	Params::CrDedicatedServerSettingsComp_SetPassword Parms{};

	Parms.InPassword = std::move(InPassword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.SetPlayerPassword
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InPassword                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrDedicatedServerSettingsComp::SetPlayerPassword(const class FString& InPassword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "SetPlayerPassword");

	Params::CrDedicatedServerSettingsComp_SetPlayerPassword Parms{};

	Parms.InPassword = std::move(InPassword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.SetSaveGameInternal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Interval                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDedicatedServerSettingsComp::SetSaveGameInternal(int32 Interval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "SetSaveGameInternal");

	Params::CrDedicatedServerSettingsComp_SetSaveGameInternal Parms{};

	Parms.Interval = Interval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDedicatedServerSettingsComp.SetStartNewGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InStart                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrDedicatedServerSettingsComp::SetStartNewGame(bool InStart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "SetStartNewGame");

	Params::CrDedicatedServerSettingsComp_SetStartNewGame Parms{};

	Parms.InStart = InStart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDedicatedServerSettingsComp.StartNewSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    NewSessionName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InToken                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrDedicatedServerSettingsComp::StartNewSession(const class FString& NewSessionName, const class FString& InToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "StartNewSession");

	Params::CrDedicatedServerSettingsComp_StartNewSession Parms{};

	Parms.NewSessionName = std::move(NewSessionName);
	Parms.InToken = std::move(InToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDedicatedServerSettingsComp.TestMethod
// (Final, Native, Public, BlueprintCallable)

void UCrDedicatedServerSettingsComp::TestMethod()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDedicatedServerSettingsComp", "TestMethod");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiActionBool.Create_CrAiActionBool
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionBool>      ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewInputVariable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionBool*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionBool* UCrAiActionBool::Create_CrAiActionBool(TSubclassOf<class UCrAiActionBool> ActionType, float NewMaxLifetimeS, bool NewInputVariable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionBool", "Create_CrAiActionBool");

	Params::CrAiActionBool_Create_CrAiActionBool Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewInputVariable = NewInputVariable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDefenseTurretBase.BP_OnInventoryChanged
// (Event, Protected, BlueprintEvent)

void ACrDefenseTurretBase::BP_OnInventoryChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDefenseTurretBase", "BP_OnInventoryChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrDefenseTurretBase.GetAmmoInInventoryCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrDefenseTurretBase::GetAmmoInInventoryCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDefenseTurretBase", "GetAmmoInInventoryCount");

	Params::CrDefenseTurretBase_GetAmmoInInventoryCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDefenseTurretBase.GetMuzzleTransformInWorldSpace
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ACrDefenseTurretBase::GetMuzzleTransformInWorldSpace() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDefenseTurretBase", "GetMuzzleTransformInWorldSpace");

	Params::CrDefenseTurretBase_GetMuzzleTransformInWorldSpace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDefenseTurretBase.HasAmmo
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrDefenseTurretBase::HasAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDefenseTurretBase", "HasAmmo");

	Params::CrDefenseTurretBase_HasAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrRadiationAttributeSet.OnRep_CurrentRadiation
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentRadiation                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrRadiationAttributeSet::OnRep_CurrentRadiation(const struct FGameplayAttributeData& OldCurrentRadiation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationAttributeSet", "OnRep_CurrentRadiation");

	Params::CrRadiationAttributeSet_OnRep_CurrentRadiation Parms{};

	Parms.OldCurrentRadiation = std::move(OldCurrentRadiation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationAttributeSet.OnRep_MaxRadiation
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxRadiation                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrRadiationAttributeSet::OnRep_MaxRadiation(const struct FGameplayAttributeData& OldMaxRadiation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationAttributeSet", "OnRep_MaxRadiation");

	Params::CrRadiationAttributeSet_OnRep_MaxRadiation Parms{};

	Parms.OldMaxRadiation = std::move(OldMaxRadiation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationAttributeSet.OnRep_MinRadiation
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinRadiation                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrRadiationAttributeSet::OnRep_MinRadiation(const struct FGameplayAttributeData& OldMinRadiation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationAttributeSet", "OnRep_MinRadiation");

	Params::CrRadiationAttributeSet_OnRep_MinRadiation Parms{};

	Parms.OldMinRadiation = std::move(OldMinRadiation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDrainAttributeSet.OnRep_CurrentDrain
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentDrain                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrDrainAttributeSet::OnRep_CurrentDrain(const struct FGameplayAttributeData& OldCurrentDrain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDrainAttributeSet", "OnRep_CurrentDrain");

	Params::CrDrainAttributeSet_OnRep_CurrentDrain Parms{};

	Parms.OldCurrentDrain = std::move(OldCurrentDrain);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDrainAttributeSet.OnRep_MaxDrain
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxDrain                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrDrainAttributeSet::OnRep_MaxDrain(const struct FGameplayAttributeData& OldMaxDrain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDrainAttributeSet", "OnRep_MaxDrain");

	Params::CrDrainAttributeSet_OnRep_MaxDrain Parms{};

	Parms.OldMaxDrain = std::move(OldMaxDrain);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDrainAttributeSet.OnRep_MinDrain
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinDrain                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrDrainAttributeSet::OnRep_MinDrain(const struct FGameplayAttributeData& OldMinDrain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDrainAttributeSet", "OnRep_MinDrain");

	Params::CrDrainAttributeSet_OnRep_MinDrain Parms{};

	Parms.OldMinDrain = std::move(OldMinDrain);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerStateBase.ClientSendAndOverrideUniqueNetIdOnServerFromLocalValue
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACrPlayerStateBase::ClientSendAndOverrideUniqueNetIdOnServerFromLocalValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerStateBase", "ClientSendAndOverrideUniqueNetIdOnServerFromLocalValue");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerStateBase.GetUniqueNetId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FUniqueNetIdRepl                 ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FUniqueNetIdRepl ACrPlayerStateBase::GetUniqueNetId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerStateBase", "GetUniqueNetId");

	Params::CrPlayerStateBase_GetUniqueNetId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerStateBase.GetUniqueNetIdAsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACrPlayerStateBase::GetUniqueNetIdAsString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerStateBase", "GetUniqueNetIdAsString");

	Params::CrPlayerStateBase_GetUniqueNetIdAsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerStateBase.ServerSendUniqueNetIdToOverrideOnServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FUniqueNetIdRepl&          UniqueNetId                                            (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUniqueNetIdRepl&          OldUniqueNetId                                         (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerStateBase::ServerSendUniqueNetIdToOverrideOnServer(const struct FUniqueNetIdRepl& UniqueNetId, const struct FUniqueNetIdRepl& OldUniqueNetId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerStateBase", "ServerSendUniqueNetIdToOverrideOnServer");

	Params::CrPlayerStateBase_ServerSendUniqueNetIdToOverrideOnServer Parms{};

	Parms.UniqueNetId = std::move(UniqueNetId);
	Parms.OldUniqueNetId = std::move(OldUniqueNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameplayAbility.ChangeActivationGroup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrAbilityActivationGroup               NewGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameplayAbility::ChangeActivationGroup(ECrAbilityActivationGroup NewGroup)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "ChangeActivationGroup");

	Params::CrGameplayAbility_ChangeActivationGroup Parms{};

	Parms.NewGroup = NewGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameplayAbility.K2_OnAbilityAdded
// (Event, Protected, BlueprintEvent)

void UCrGameplayAbility::K2_OnAbilityAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "K2_OnAbilityAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGameplayAbility.K2_OnAbilityRemoved
// (Event, Protected, BlueprintEvent)

void UCrGameplayAbility::K2_OnAbilityRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "K2_OnAbilityRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGameplayAbility.K2_OnPawnAvatarSet
// (Event, Protected, BlueprintEvent)

void UCrGameplayAbility::K2_OnPawnAvatarSet()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "K2_OnPawnAvatarSet");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGameplayAbility.MontagePairJumpToSection
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameplayAbility::MontagePairJumpToSection(class FName SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "MontagePairJumpToSection");

	Params::CrGameplayAbility_MontagePairJumpToSection Parms{};

	Parms.SectionName = SectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameplayAbility.CanChangeActivationGroup
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// ECrAbilityActivationGroup               NewGroup                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameplayAbility::CanChangeActivationGroup(ECrAbilityActivationGroup NewGroup) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "CanChangeActivationGroup");

	Params::CrGameplayAbility_CanChangeActivationGroup Parms{};

	Parms.NewGroup = NewGroup;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameplayAbility.GetControllerFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* UCrGameplayAbility::GetControllerFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "GetControllerFromActorInfo");

	Params::CrGameplayAbility_GetControllerFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameplayAbility.GetCrAbilitySystemComponentFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrAbilitySystemComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAbilitySystemComponent* UCrGameplayAbility::GetCrAbilitySystemComponentFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "GetCrAbilitySystemComponentFromActorInfo");

	Params::CrGameplayAbility_GetCrAbilitySystemComponentFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameplayAbility.GetCrCharacterFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACrCharacterBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACrCharacterBase* UCrGameplayAbility::GetCrCharacterFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "GetCrCharacterFromActorInfo");

	Params::CrGameplayAbility_GetCrCharacterFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameplayAbility.GetCrPlayerControllerFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACrPlayerControllerBase*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACrPlayerControllerBase* UCrGameplayAbility::GetCrPlayerControllerFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "GetCrPlayerControllerFromActorInfo");

	Params::CrGameplayAbility_GetCrPlayerControllerFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameplayAbility.GetHeroComponentFromActorInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrHeroComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrHeroComponent* UCrGameplayAbility::GetHeroComponentFromActorInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "GetHeroComponentFromActorInfo");

	Params::CrGameplayAbility_GetHeroComponentFromActorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameplayAbility.ScriptOnAbilityFailedToActivate
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FGameplayTagContainer&     FailedReason                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGameplayAbility::ScriptOnAbilityFailedToActivate(const struct FGameplayTagContainer& FailedReason) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameplayAbility", "ScriptOnAbilityFailedToActivate");

	Params::CrGameplayAbility_ScriptOnAbilityFailedToActivate Parms{};

	Parms.FailedReason = std::move(FailedReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrSystemAbility.IsActivable
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Avatar                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACrPlayerControllerBase*          User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSystemAbility::IsActivable(class AActor* Avatar, class ACrPlayerControllerBase* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSystemAbility", "IsActivable");

	Params::CrSystemAbility_IsActivable Parms{};

	Parms.Avatar = Avatar;
	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSystemAbility.IsVisible
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           Avatar                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACrPlayerControllerBase*          User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSystemAbility::IsVisible(class AActor* Avatar, class ACrPlayerControllerBase* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSystemAbility", "IsVisible");

	Params::CrSystemAbility_IsVisible Parms{};

	Parms.Avatar = Avatar;
	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDroneBase.OnCarriedItemChanged
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FAuSimpleItem&             Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDroneBase::OnCarriedItemChanged(const struct FAuSimpleItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDroneBase", "OnCarriedItemChanged");

	Params::CrDroneBase_OnCarriedItemChanged Parms{};

	Parms.Item = std::move(Item);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrDroneBase.OnPickUpRequested
// (Event, Public, BlueprintEvent)

void ACrDroneBase::OnPickUpRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDroneBase", "OnPickUpRequested");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrDroneBase.OnPrepareForGame
// (Event, Public, BlueprintEvent)

void ACrDroneBase::OnPrepareForGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDroneBase", "OnPrepareForGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrDroneBase.OnPrepareForPooling
// (Event, Public, BlueprintEvent)

void ACrDroneBase::OnPrepareForPooling()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDroneBase", "OnPrepareForPooling");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrDroneBase.OnRequestInvalidStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bAborted                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDroneBase::OnRequestInvalidStateChanged(bool bAborted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDroneBase", "OnRequestInvalidStateChanged");

	Params::CrDroneBase_OnRequestInvalidStateChanged Parms{};

	Parms.bAborted = bAborted;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrDroneBase.GetCargoComponent
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ACrDroneBase::GetCargoComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDroneBase", "GetCargoComponent");

	Params::CrDroneBase_GetCargoComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrDroneBase.GetItemRotZ
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrDroneBase::GetItemRotZ() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDroneBase", "GetItemRotZ");

	Params::CrDroneBase_GetItemRotZ Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDroneBase.GetItemScale
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ACrDroneBase::GetItemScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDroneBase", "GetItemScale");

	Params::CrDroneBase_GetItemScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrJinglePlaybackContext.OnFinished
// (Final, Native, Private)

void UCrJinglePlaybackContext::OnFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrJinglePlaybackContext", "OnFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDronePathPointConnection.OnDestroyConnectedActor
// (Final, Native, Public)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDronePathPointConnection::OnDestroyConnectedActor(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnection", "OnDestroyConnectedActor");

	Params::CrDronePathPointConnection_OnDestroyConnectedActor Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDronePathPointConnection.OnSetItemFilter
// (Event, Public, BlueprintEvent)

void ACrDronePathPointConnection::OnSetItemFilter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnection", "OnSetItemFilter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrDronePathPointConnection.SetColorTint
// (Event, Public, BlueprintEvent)
// Parameters:
// const int32                             Color                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PrimitiveDataIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDronePathPointConnection::SetColorTint(const int32 Color, int32 PrimitiveDataIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnection", "SetColorTint");

	Params::CrDronePathPointConnection_SetColorTint Parms{};

	Parms.Color = Color;
	Parms.PrimitiveDataIndex = PrimitiveDataIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrDronePathPointConnection.SetMaterialToSpline
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               Material                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaterialIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDronePathPointConnection::SetMaterialToSpline(class UMaterialInterface* Material, int32 MaterialIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnection", "SetMaterialToSpline");

	Params::CrDronePathPointConnection_SetMaterialToSpline Parms{};

	Parms.Material = Material;
	Parms.MaterialIndex = MaterialIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDronePathPointConnection.GetFilter
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UAuItemDataBase*            ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAuItemDataBase* ACrDronePathPointConnection::GetFilter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnection", "GetFilter");

	Params::CrDronePathPointConnection_GetFilter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGrenadeChargeAttributeSet.OnRep_CurrentGrenadeCharge
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentCharge                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGrenadeChargeAttributeSet::OnRep_CurrentGrenadeCharge(const struct FGameplayAttributeData& OldCurrentCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGrenadeChargeAttributeSet", "OnRep_CurrentGrenadeCharge");

	Params::CrGrenadeChargeAttributeSet_OnRep_CurrentGrenadeCharge Parms{};

	Parms.OldCurrentCharge = std::move(OldCurrentCharge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGrenadeChargeAttributeSet.OnRep_MaxGrenadeCharge
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxCharge                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGrenadeChargeAttributeSet::OnRep_MaxGrenadeCharge(const struct FGameplayAttributeData& OldMaxCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGrenadeChargeAttributeSet", "OnRep_MaxGrenadeCharge");

	Params::CrGrenadeChargeAttributeSet_OnRep_MaxGrenadeCharge Parms{};

	Parms.OldMaxCharge = std::move(OldMaxCharge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGrenadeChargeAttributeSet.OnRep_MinGrenadeCharge
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinCharge                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGrenadeChargeAttributeSet::OnRep_MinGrenadeCharge(const struct FGameplayAttributeData& OldMinCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGrenadeChargeAttributeSet", "OnRep_MinGrenadeCharge");

	Params::CrGrenadeChargeAttributeSet_OnRep_MinGrenadeCharge Parms{};

	Parms.OldMinCharge = std::move(OldMinCharge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrResourceRedistributor.UpdateFilter
// (Event, Public, BlueprintEvent)
// Parameters:
// const class UAuItemDataBase*            ItemFilter                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrResourceRedistributor::UpdateFilter(const class UAuItemDataBase* ItemFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrResourceRedistributor", "UpdateFilter");

	Params::CrResourceRedistributor_UpdateFilter Parms{};

	Parms.ItemFilter = ItemFilter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrResourceRedistributor.UpdateItemCount
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCount                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrResourceRedistributor::UpdateItemCount(int32 Count, int32 MaxCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrResourceRedistributor", "UpdateItemCount");

	Params::CrResourceRedistributor_UpdateItemCount Parms{};

	Parms.Count = Count;
	Parms.MaxCount = MaxCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrDronePathPointConnectionMassSpawner.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrDronePathPointConnectionMassSpawner::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnectionMassSpawner", "OnBeginOverlap");

	Params::CrDronePathPointConnectionMassSpawner_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDronePathPointConnectionMassSpawner.TryConnect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USphereComponent*                 Start                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USphereComponent*                 End                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrDronePathPointConnectionMassSpawner::TryConnect(class USphereComponent* Start, class USphereComponent* End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnectionMassSpawner", "TryConnect");

	Params::CrDronePathPointConnectionMassSpawner_TryConnect Parms{};

	Parms.Start = Start;
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrDronePathPointConnectionMassSpawner.TryFindOverlaps
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrDronePathPointConnectionMassSpawner::TryFindOverlaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnectionMassSpawner", "TryFindOverlaps");

	Params::CrDronePathPointConnectionMassSpawner_TryFindOverlaps Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDronePathPointConnectionMassSpawner.GetEndCollider
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USphereComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USphereComponent* ACrDronePathPointConnectionMassSpawner::GetEndCollider() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnectionMassSpawner", "GetEndCollider");

	Params::CrDronePathPointConnectionMassSpawner_GetEndCollider Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrDronePathPointConnectionMassSpawner.GetStartCollider
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// class USphereComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USphereComponent* ACrDronePathPointConnectionMassSpawner::GetStartCollider() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnectionMassSpawner", "GetStartCollider");

	Params::CrDronePathPointConnectionMassSpawner_GetStartCollider Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Chimera.CrDronePathPointConnectionMassSpawner.GetValidSocketTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACrBuildingActorBase*             Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USphereComponent*                 Sphere                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ACrDronePathPointConnectionMassSpawner::GetValidSocketTransform(class ACrBuildingActorBase* Actor, class USphereComponent* Sphere) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrDronePathPointConnectionMassSpawner", "GetValidSocketTransform");

	Params::CrDronePathPointConnectionMassSpawner_GetValidSocketTransform Parms{};

	Parms.Actor = Actor;
	Parms.Sphere = Sphere;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrDroneSystemBPF.GetDefaultObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UObject>              ObjectClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UCrDroneSystemBPF::GetDefaultObject(TSubclassOf<class UObject> ObjectClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrDroneSystemBPF", "GetDefaultObject");

	Params::CrDroneSystemBPF_GetDefaultObject Parms{};

	Parms.ObjectClass = ObjectClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrStandaloneInfectionSpawnSubsystem.OnFadeoutSubstageChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrStandaloneInfectionSpawnSubsystem::OnFadeoutSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveFadeoutSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionSpawnSubsystem", "OnFadeoutSubstageChanged");

	Params::CrStandaloneInfectionSpawnSubsystem_OnFadeoutSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStandaloneInfectionSpawnSubsystem.OnGrowbackSubstageChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrStandaloneInfectionSpawnSubsystem::OnGrowbackSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveGrowbackSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionSpawnSubsystem", "OnGrowbackSubstageChanged");

	Params::CrStandaloneInfectionSpawnSubsystem_OnGrowbackSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHydrationAttributeSet.OnRep_CurrentHydration
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentHydration                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHydrationAttributeSet::OnRep_CurrentHydration(const struct FGameplayAttributeData& OldCurrentHydration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHydrationAttributeSet", "OnRep_CurrentHydration");

	Params::CrHydrationAttributeSet_OnRep_CurrentHydration Parms{};

	Parms.OldCurrentHydration = std::move(OldCurrentHydration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHydrationAttributeSet.OnRep_MaxHydration
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxHydration                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHydrationAttributeSet::OnRep_MaxHydration(const struct FGameplayAttributeData& OldMaxHydration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHydrationAttributeSet", "OnRep_MaxHydration");

	Params::CrHydrationAttributeSet_OnRep_MaxHydration Parms{};

	Parms.OldMaxHydration = std::move(OldMaxHydration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHydrationAttributeSet.OnRep_MinHydration
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinHydration                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHydrationAttributeSet::OnRep_MinHydration(const struct FGameplayAttributeData& OldMinHydration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHydrationAttributeSet", "OnRep_MinHydration");

	Params::CrHydrationAttributeSet_OnRep_MinHydration Parms{};

	Parms.OldMinHydration = std::move(OldMinHydration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPC_MainMenu.ClientJoinSessionAutomatized
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    SessionId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDedicated                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RestURL                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPC_MainMenu::ClientJoinSessionAutomatized(const class FString& SessionId, bool bIsDedicated, const class FString& RestURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPC_MainMenu", "ClientJoinSessionAutomatized");

	Params::CrPC_MainMenu_ClientJoinSessionAutomatized Parms{};

	Parms.SessionId = std::move(SessionId);
	Parms.bIsDedicated = bIsDedicated;
	Parms.RestURL = std::move(RestURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPC_MainMenu.ServerCreateSessionAutomatized
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    SessionId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDedicated                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    RestURL                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPC_MainMenu::ServerCreateSessionAutomatized(const class FString& SessionId, bool bIsDedicated, const class FString& RestURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPC_MainMenu", "ServerCreateSessionAutomatized");

	Params::CrPC_MainMenu_ServerCreateSessionAutomatized Parms{};

	Parms.SessionId = std::move(SessionId);
	Parms.bIsDedicated = bIsDedicated;
	Parms.RestURL = std::move(RestURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPC_MainMenu.SetHostAutomationServerURL
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    NewHostURL                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPC_MainMenu::SetHostAutomationServerURL(const class FString& NewHostURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPC_MainMenu", "SetHostAutomationServerURL");

	Params::CrPC_MainMenu_SetHostAutomationServerURL Parms{};

	Parms.NewHostURL = std::move(NewHostURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPC_MainMenu.SetOwningAutomationServerURL
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    NewOwningURL                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPC_MainMenu::SetOwningAutomationServerURL(const class FString& NewOwningURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPC_MainMenu", "SetOwningAutomationServerURL");

	Params::CrPC_MainMenu_SetOwningAutomationServerURL Parms{};

	Parms.NewOwningURL = std::move(NewOwningURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRifleTurretBase.CosmeticDryFire
// (Event, Public, BlueprintEvent)

void ACrRifleTurretBase::CosmeticDryFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRifleTurretBase", "CosmeticDryFire");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrRifleTurretBase.CosmeticHit
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                InHit                                                  (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrRifleTurretBase::CosmeticHit(const struct FHitResult& InHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRifleTurretBase", "CosmeticHit");

	Params::CrRifleTurretBase_CosmeticHit Parms{};

	Parms.InHit = std::move(InHit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrRifleTurretBase.CosmeticTurretMalfunctionEnded
// (Event, Public, BlueprintEvent)

void ACrRifleTurretBase::CosmeticTurretMalfunctionEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRifleTurretBase", "CosmeticTurretMalfunctionEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrRifleTurretBase.CosmeticTurretMalfunctionStarted
// (Event, Public, BlueprintEvent)

void ACrRifleTurretBase::CosmeticTurretMalfunctionStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRifleTurretBase", "CosmeticTurretMalfunctionStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrRifleTurretBase.UpdateCosmeticsBasedOnAttackDirection
// (Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   OutCurrentAttackDirection                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrRifleTurretBase::UpdateCosmeticsBasedOnAttackDirection(const struct FVector& OutCurrentAttackDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRifleTurretBase", "UpdateCosmeticsBasedOnAttackDirection");

	Params::CrRifleTurretBase_UpdateCosmeticsBasedOnAttackDirection Parms{};

	Parms.OutCurrentAttackDirection = std::move(OutCurrentAttackDirection);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrRifleTurretBase.GetImpactHitNiagaraSystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* ACrRifleTurretBase::GetImpactHitNiagaraSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRifleTurretBase", "GetImpactHitNiagaraSystem");

	Params::CrRifleTurretBase_GetImpactHitNiagaraSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrRifleTurretBase.GetShootSound
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USoundBase*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USoundBase* ACrRifleTurretBase::GetShootSound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRifleTurretBase", "GetShootSound");

	Params::CrRifleTurretBase_GetShootSound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrRifleTurretBase.GetShootTracerNiagaraSystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNiagaraSystem*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNiagaraSystem* ACrRifleTurretBase::GetShootTracerNiagaraSystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRifleTurretBase", "GetShootTracerNiagaraSystem");

	Params::CrRifleTurretBase_GetShootTracerNiagaraSystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrElectricityGraphSubsystem.GetElectricityForSubgraphsInRadius
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrElectricityGraphSubsystem::GetElectricityForSubgraphsInRadius(const struct FVector& Center, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrElectricityGraphSubsystem", "GetElectricityForSubgraphsInRadius");

	Params::CrElectricityGraphSubsystem_GetElectricityForSubgraphsInRadius Parms{};

	Parms.Center = std::move(Center);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrElectricityGraphSubsystem.GetElectricityInBounds
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FBox&                      Bounds                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bOnlyPoweredGrid                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrElectricityGraphSubsystem::GetElectricityInBounds(const struct FBox& Bounds, bool bOnlyPoweredGrid) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrElectricityGraphSubsystem", "GetElectricityInBounds");

	Params::CrElectricityGraphSubsystem_GetElectricityInBounds Parms{};

	Parms.Bounds = std::move(Bounds);
	Parms.bOnlyPoweredGrid = bOnlyPoweredGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrElectricityGraphSubsystem.GetElectricityInRadius
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Center                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrElectricityGraphSubsystem::GetElectricityInRadius(const struct FVector& Center, float Radius) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrElectricityGraphSubsystem", "GetElectricityInRadius");

	Params::CrElectricityGraphSubsystem_GetElectricityInRadius Parms{};

	Parms.Center = std::move(Center);
	Parms.Radius = Radius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGlobalAbilitiesSubsystem.ApplyAbilityToAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGlobalAbilitiesSubsystem::ApplyAbilityToAll(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGlobalAbilitiesSubsystem", "ApplyAbilityToAll");

	Params::CrGlobalAbilitiesSubsystem_ApplyAbilityToAll Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGlobalAbilitiesSubsystem.ApplyEffectToAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      Effect                                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGlobalAbilitiesSubsystem::ApplyEffectToAll(TSubclassOf<class UGameplayEffect> Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGlobalAbilitiesSubsystem", "ApplyEffectToAll");

	Params::CrGlobalAbilitiesSubsystem_ApplyEffectToAll Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGlobalAbilitiesSubsystem.RemoveAbilityFromAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayAbility>     Ability                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGlobalAbilitiesSubsystem::RemoveAbilityFromAll(TSubclassOf<class UGameplayAbility> Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGlobalAbilitiesSubsystem", "RemoveAbilityFromAll");

	Params::CrGlobalAbilitiesSubsystem_RemoveAbilityFromAll Parms{};

	Parms.Ability = Ability;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGlobalAbilitiesSubsystem.RemoveEffectFromAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      Effect                                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGlobalAbilitiesSubsystem::RemoveEffectFromAll(TSubclassOf<class UGameplayEffect> Effect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGlobalAbilitiesSubsystem", "RemoveEffectFromAll");

	Params::CrGlobalAbilitiesSubsystem_RemoveEffectFromAll Parms{};

	Parms.Effect = Effect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEncyclopediaReplicationHelper.GetCategoryOptions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ACrEncyclopediaReplicationHelper::GetCategoryOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrEncyclopediaReplicationHelper", "GetCategoryOptions");

	Params::CrEncyclopediaReplicationHelper_GetCategoryOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEncyclopediaReplicationHelper.GetEntryAuyhors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ACrEncyclopediaReplicationHelper::GetEntryAuyhors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrEncyclopediaReplicationHelper", "GetEntryAuyhors");

	Params::CrEncyclopediaReplicationHelper_GetEntryAuyhors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEncyclopediaReplicationHelper.GetSubcategoryOptions
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ACrEncyclopediaReplicationHelper::GetSubcategoryOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrEncyclopediaReplicationHelper", "GetSubcategoryOptions");

	Params::CrEncyclopediaReplicationHelper_GetSubcategoryOptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEncyclopediaReplicationHelper.MulticastOnNewEncyclopediaEntry
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FCrEncyclopediaEntryStatus&EntryStatus                                            (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void ACrEncyclopediaReplicationHelper::MulticastOnNewEncyclopediaEntry(const struct FCrEncyclopediaEntryStatus& EntryStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEncyclopediaReplicationHelper", "MulticastOnNewEncyclopediaEntry");

	Params::CrEncyclopediaReplicationHelper_MulticastOnNewEncyclopediaEntry Parms{};

	Parms.EntryStatus = std::move(EntryStatus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEncyclopediaSubsystem.OnContextualEventExecuted
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContextName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContextValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEncyclopediaSubsystem::OnContextualEventExecuted(class AActor* Target, class FName ContextName, class FName ContextValue, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEncyclopediaSubsystem", "OnContextualEventExecuted");

	Params::CrEncyclopediaSubsystem_OnContextualEventExecuted Parms{};

	Parms.Target = Target;
	Parms.ContextName = ContextName;
	Parms.ContextValue = ContextValue;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnergyAttributeSet.OnRep_CurrentEnergy
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentEnergy                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrEnergyAttributeSet::OnRep_CurrentEnergy(const struct FGameplayAttributeData& OldCurrentEnergy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnergyAttributeSet", "OnRep_CurrentEnergy");

	Params::CrEnergyAttributeSet_OnRep_CurrentEnergy Parms{};

	Parms.OldCurrentEnergy = std::move(OldCurrentEnergy);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnergyAttributeSet.OnRep_MaxEnergy
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxEnergy                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrEnergyAttributeSet::OnRep_MaxEnergy(const struct FGameplayAttributeData& OldMaxEnergy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnergyAttributeSet", "OnRep_MaxEnergy");

	Params::CrEnergyAttributeSet_OnRep_MaxEnergy Parms{};

	Parms.OldMaxEnergy = std::move(OldMaxEnergy);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnergyAttributeSet.OnRep_MinEnergy
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinEnergy                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrEnergyAttributeSet::OnRep_MinEnergy(const struct FGameplayAttributeData& OldMinEnergy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnergyAttributeSet", "OnRep_MinEnergy");

	Params::CrEnergyAttributeSet_OnRep_MinEnergy Parms{};

	Parms.OldMinEnergy = std::move(OldMinEnergy);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnergyLogicComponent.OnOwningCharacterMovementModeChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PrevMovementMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnergyLogicComponent::OnOwningCharacterMovementModeChanged(class ACharacter* Character, EMovementMode PrevMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnergyLogicComponent", "OnOwningCharacterMovementModeChanged");

	Params::CrEnergyLogicComponent_OnOwningCharacterMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PrevMovementMode = PrevMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnergyLogicComponent.GetCurrentEnergy
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrEnergyLogicComponent::GetCurrentEnergy() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnergyLogicComponent", "GetCurrentEnergy");

	Params::CrEnergyLogicComponent_GetCurrentEnergy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAbilityTask_PlayMontage.CreatePlayMontageAndWaitProxy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     TppMontageToPlay_0                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     FppMontageToPlay_0                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Rate_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds_0                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSection_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAbilityTask_PlayMontage*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAbilityTask_PlayMontage* UCrAbilityTask_PlayMontage::CreatePlayMontageAndWaitProxy(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class UAnimMontage* TppMontageToPlay_0, class UAnimMontage* FppMontageToPlay_0, float Rate_0, bool bStopWhenAbilityEnds_0, class FName StartSection_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAbilityTask_PlayMontage", "CreatePlayMontageAndWaitProxy");

	Params::CrAbilityTask_PlayMontage_CreatePlayMontageAndWaitProxy Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.TppMontageToPlay_0 = TppMontageToPlay_0;
	Parms.FppMontageToPlay_0 = FppMontageToPlay_0;
	Parms.Rate_0 = Rate_0;
	Parms.bStopWhenAbilityEnds_0 = bStopWhenAbilityEnds_0;
	Parms.StartSection_0 = StartSection_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAbilityTask_PlayMontage.CreatePlayMontagePairAndWaitProxy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMontagePair&            MontagePair                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Rate_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds_0                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSection_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAbilityTask_PlayMontage*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAbilityTask_PlayMontage* UCrAbilityTask_PlayMontage::CreatePlayMontagePairAndWaitProxy(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FCrMontagePair& MontagePair, float Rate_0, bool bStopWhenAbilityEnds_0, class FName StartSection_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAbilityTask_PlayMontage", "CreatePlayMontagePairAndWaitProxy");

	Params::CrAbilityTask_PlayMontage_CreatePlayMontagePairAndWaitProxy Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.MontagePair = std::move(MontagePair);
	Parms.Rate_0 = Rate_0;
	Parms.bStopWhenAbilityEnds_0 = bStopWhenAbilityEnds_0;
	Parms.StartSection_0 = StartSection_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAbilityTask_PlayMontage.OnAbilityCancelled
// (Final, Native, Public)

void UCrAbilityTask_PlayMontage::OnAbilityCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityTask_PlayMontage", "OnAbilityCancelled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityTask_PlayMontage.OnFPPMontageBlendOut
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAbilityTask_PlayMontage::OnFPPMontageBlendOut_0(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityTask_PlayMontage", "OnFPPMontageBlendOut");

	Params::CrAbilityTask_PlayMontage_OnFPPMontageBlendOut_0 Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityTask_PlayMontage.OnMontageEnded
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAbilityTask_PlayMontage::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityTask_PlayMontage", "OnMontageEnded");

	Params::CrAbilityTask_PlayMontage_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityTask_PlayMontage.OnNotifyBeginReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCrAbilityTask_PlayMontage::OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityTask_PlayMontage", "OnNotifyBeginReceived");

	Params::CrAbilityTask_PlayMontage_OnNotifyBeginReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityTask_PlayMontage.OnNotifyEndReceived
// (Final, Native, Public, HasOutParams)
// Parameters:
// class FName                             NotifyName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBranchingPointNotifyPayload&BranchingPointNotifyPayload                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCrAbilityTask_PlayMontage::OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityTask_PlayMontage", "OnNotifyEndReceived");

	Params::CrAbilityTask_PlayMontage_OnNotifyEndReceived Parms{};

	Parms.NotifyName = NotifyName;
	Parms.BranchingPointNotifyPayload = std::move(BranchingPointNotifyPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAbilityTask_PlayMontage.OnTPPMontageBlendOut
// (Final, Native, Public)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAbilityTask_PlayMontage::OnTPPMontageBlendOut(class UAnimMontage* Montage, bool bInterrupted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAbilityTask_PlayMontage", "OnTPPMontageBlendOut");

	Params::CrAbilityTask_PlayMontage_OnTPPMontageBlendOut Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsActor.OnEnviroWaveCanceled
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsActor::OnEnviroWaveCanceled(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsActor", "OnEnviroWaveCanceled");

	Params::CrEnviroWaveVisualsActor_OnEnviroWaveCanceled Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsActor.OnEnviroWaveFinished
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsActor::OnEnviroWaveFinished(EEnviroWave WaveType, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsActor", "OnEnviroWaveFinished");

	Params::CrEnviroWaveVisualsActor_OnEnviroWaveFinished Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsActor.OnEnviroWaveForced
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   WaveProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsActor::OnEnviroWaveForced(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings, float WaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsActor", "OnEnviroWaveForced");

	Params::CrEnviroWaveVisualsActor_OnEnviroWaveForced Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);
	Parms.WaveProgress = WaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsActor.OnEnviroWavePaused
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   WaveProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsActor::OnEnviroWavePaused(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings, float WaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsActor", "OnEnviroWavePaused");

	Params::CrEnviroWaveVisualsActor_OnEnviroWavePaused Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);
	Parms.WaveProgress = WaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsActor.OnEnviroWaveStarted
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   WaveProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsActor::OnEnviroWaveStarted(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings, float WaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsActor", "OnEnviroWaveStarted");

	Params::CrEnviroWaveVisualsActor_OnEnviroWaveStarted Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);
	Parms.WaveProgress = WaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsActor.OnEnviroWaveTick
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   WaveProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsActor::OnEnviroWaveTick(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings, float WaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsActor", "OnEnviroWaveTick");

	Params::CrEnviroWaveVisualsActor_OnEnviroWaveTick Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);
	Parms.WaveProgress = WaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroSkyboxActor.AssignSkyboxColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroSkyboxActor::AssignSkyboxColor(class FName Name_0, const struct FLinearColor& Value, float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroSkyboxActor", "AssignSkyboxColor");

	Params::CrEnviroSkyboxActor_AssignSkyboxColor Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroSkyboxActor.AssignSkyboxScalar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroSkyboxActor::AssignSkyboxScalar(class FName Name_0, float Value, float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroSkyboxActor", "AssignSkyboxScalar");

	Params::CrEnviroSkyboxActor_AssignSkyboxScalar Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = Value;
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroSkyboxActor.AssignSkyboxVector
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroSkyboxActor::AssignSkyboxVector(class FName Name_0, const struct FVector& Value, float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroSkyboxActor", "AssignSkyboxVector");

	Params::CrEnviroSkyboxActor_AssignSkyboxVector Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroSkyboxActor.AssignSkyboxVector4
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector4&                  Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Weight                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroSkyboxActor::AssignSkyboxVector4(class FName Name_0, const struct FVector4& Value, float Weight)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroSkyboxActor", "AssignSkyboxVector4");

	Params::CrEnviroSkyboxActor_AssignSkyboxVector4 Parms{};

	Parms.Name_0 = Name_0;
	Parms.Value = std::move(Value);
	Parms.Weight = Weight;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroSkyboxActor.EveryFrameEvent
// (Event, Public, BlueprintEvent)

void ACrEnviroSkyboxActor::EveryFrameEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroSkyboxActor", "EveryFrameEvent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrEnviroSkyboxActor.MakeSkyboxMaterialInstance
// (Final, Native, Public, BlueprintCallable)

void ACrEnviroSkyboxActor::MakeSkyboxMaterialInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroSkyboxActor", "MakeSkyboxMaterialInstance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroSkyboxActor.UpdateCosmoBreachPos
// (Final, Native, Public, BlueprintCallable)

void ACrEnviroSkyboxActor::UpdateCosmoBreachPos()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroSkyboxActor", "UpdateCosmoBreachPos");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFrontendStateComponent.OnUserInitialized
// (Final, Native, Private)
// Parameters:
// const class UCommonUserInfo*            UserInfo                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Error                                                  (Parm, NativeAccessSpecifierPublic)
// ECommonUserPrivilege                    RequestedPrivilege                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommonUserOnlineContext                OnlineContext                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrFrontendStateComponent::OnUserInitialized(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestedPrivilege, ECommonUserOnlineContext OnlineContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFrontendStateComponent", "OnUserInitialized");

	Params::CrFrontendStateComponent_OnUserInitialized Parms{};

	Parms.UserInfo = UserInfo;
	Parms.bSuccess = bSuccess;
	Parms.Error = std::move(Error);
	Parms.RequestedPrivilege = RequestedPrivilege;
	Parms.OnlineContext = OnlineContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveAmbientSoundSubsystem.OnEnviroWaveFinished
// (Final, Native, Public)

void UCrEnviroWaveAmbientSoundSubsystem::OnEnviroWaveFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveAmbientSoundSubsystem", "OnEnviroWaveFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveAmbientSoundSubsystem.OnEnviroWaveStarted
// (Final, Native, Public)

void UCrEnviroWaveAmbientSoundSubsystem::OnEnviroWaveStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveAmbientSoundSubsystem", "OnEnviroWaveStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSaveSubsystem.CloseSessionConfirmationWidget
// (Final, Native, Public, BlueprintCallable)

void UCrSaveSubsystem::CloseSessionConfirmationWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "CloseSessionConfirmationWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSaveSubsystem.DoesAnySaveExist
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSaveSubsystem::DoesAnySaveExist()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "DoesAnySaveExist");

	Params::CrSaveSubsystem_DoesAnySaveExist Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSaveSubsystem.ExecuteSave
// (Final, Native, Public, BlueprintCallable)

void UCrSaveSubsystem::ExecuteSave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "ExecuteSave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSaveSubsystem.LoadGame
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInCoopGame                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSaveSubsystem::LoadGame(const class FString& Name_0, bool bInCoopGame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "LoadGame");

	Params::CrSaveSubsystem_LoadGame Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.bInCoopGame = bInCoopGame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSaveSubsystem.RequestSaveGameToServer
// (Final, Native, Public, BlueprintCallable)

void UCrSaveSubsystem::RequestSaveGameToServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "RequestSaveGameToServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSaveSubsystem.SaveGame
// (Final, Native, Public, BlueprintCallable)

void UCrSaveSubsystem::SaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "SaveGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSaveSubsystem.ShowSessionConfirmationWidget
// (Final, Native, Public, BlueprintCallable)

void UCrSaveSubsystem::ShowSessionConfirmationWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "ShowSessionConfirmationWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSaveSubsystem.GetCurrentSessionCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrSaveSubsystem::GetCurrentSessionCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "GetCurrentSessionCount");

	Params::CrSaveSubsystem_GetCurrentSessionCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSaveSubsystem.GetMaxSessionCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrSaveSubsystem::GetMaxSessionCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSaveSubsystem", "GetMaxSessionCount");

	Params::CrSaveSubsystem_GetMaxSessionCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveCurvesFunctionLibrary.EvaluateFloatCurve
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<EEnviroWave, struct FCrEnviroWaveCurveFloatMap>&Curves                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWave*                            OutWaveType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage*                       OutWaveStage                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutProgress                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrEnviroWaveCurvesFunctionLibrary::EvaluateFloatCurve(const TMap<EEnviroWave, struct FCrEnviroWaveCurveFloatMap>& Curves, EEnviroWave WaveType, EEnviroWaveStage WaveStage, float Progress, EEnviroWave* OutWaveType, EEnviroWaveStage* OutWaveStage, float* OutProgress, float DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrEnviroWaveCurvesFunctionLibrary", "EvaluateFloatCurve");

	Params::CrEnviroWaveCurvesFunctionLibrary_EvaluateFloatCurve Parms{};

	Parms.Curves = std::move(Curves);
	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.Progress = Progress;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWaveType != nullptr)
		*OutWaveType = Parms.OutWaveType;

	if (OutWaveStage != nullptr)
		*OutWaveStage = Parms.OutWaveStage;

	if (OutProgress != nullptr)
		*OutProgress = Parms.OutProgress;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveCurvesFunctionLibrary.EvaluateLinearColorCurve
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<EEnviroWave, struct FCrEnviroWaveCurveLinearColorMap>&Curves                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWave*                            OutWaveType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage*                       OutWaveStage                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutProgress                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UCrEnviroWaveCurvesFunctionLibrary::EvaluateLinearColorCurve(const TMap<EEnviroWave, struct FCrEnviroWaveCurveLinearColorMap>& Curves, EEnviroWave WaveType, EEnviroWaveStage WaveStage, float Progress, EEnviroWave* OutWaveType, EEnviroWaveStage* OutWaveStage, float* OutProgress, const struct FLinearColor& DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrEnviroWaveCurvesFunctionLibrary", "EvaluateLinearColorCurve");

	Params::CrEnviroWaveCurvesFunctionLibrary_EvaluateLinearColorCurve Parms{};

	Parms.Curves = std::move(Curves);
	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.Progress = Progress;
	Parms.DefaultValue = std::move(DefaultValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWaveType != nullptr)
		*OutWaveType = Parms.OutWaveType;

	if (OutWaveStage != nullptr)
		*OutWaveStage = Parms.OutWaveStage;

	if (OutProgress != nullptr)
		*OutProgress = Parms.OutProgress;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveCurvesFunctionLibrary.EvaluateTableCurve
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<EEnviroWave, struct FCrEnviroWaveCurveTableMap>&Curves                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FName&                      TableName                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWave*                            OutWaveType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage*                       OutWaveStage                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutProgress                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrEnviroWaveCurvesFunctionLibrary::EvaluateTableCurve(const TMap<EEnviroWave, struct FCrEnviroWaveCurveTableMap>& Curves, const class FName& TableName, EEnviroWave WaveType, EEnviroWaveStage WaveStage, float Progress, EEnviroWave* OutWaveType, EEnviroWaveStage* OutWaveStage, float* OutProgress, float DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrEnviroWaveCurvesFunctionLibrary", "EvaluateTableCurve");

	Params::CrEnviroWaveCurvesFunctionLibrary_EvaluateTableCurve Parms{};

	Parms.Curves = std::move(Curves);
	Parms.TableName = TableName;
	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.Progress = Progress;
	Parms.DefaultValue = DefaultValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWaveType != nullptr)
		*OutWaveType = Parms.OutWaveType;

	if (OutWaveStage != nullptr)
		*OutWaveStage = Parms.OutWaveStage;

	if (OutProgress != nullptr)
		*OutProgress = Parms.OutProgress;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveCurvesFunctionLibrary.EvaluateVectorCurve
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const TMap<EEnviroWave, struct FCrEnviroWaveCurveVectorMap>&Curves                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWave*                            OutWaveType                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage*                       OutWaveStage                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutProgress                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   DefaultValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCrEnviroWaveCurvesFunctionLibrary::EvaluateVectorCurve(const TMap<EEnviroWave, struct FCrEnviroWaveCurveVectorMap>& Curves, EEnviroWave WaveType, EEnviroWaveStage WaveStage, float Progress, EEnviroWave* OutWaveType, EEnviroWaveStage* OutWaveStage, float* OutProgress, const struct FVector& DefaultValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrEnviroWaveCurvesFunctionLibrary", "EvaluateVectorCurve");

	Params::CrEnviroWaveCurvesFunctionLibrary_EvaluateVectorCurve Parms{};

	Parms.Curves = std::move(Curves);
	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.Progress = Progress;
	Parms.DefaultValue = std::move(DefaultValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWaveType != nullptr)
		*OutWaveType = Parms.OutWaveType;

	if (OutWaveStage != nullptr)
		*OutWaveStage = Parms.OutWaveStage;

	if (OutProgress != nullptr)
		*OutProgress = Parms.OutProgress;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveEffectsSubsystem.OnFadeoutSubstageChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnviroWaveEffectsSubsystem::OnFadeoutSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveFadeoutSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveEffectsSubsystem", "OnFadeoutSubstageChanged");

	Params::CrEnviroWaveEffectsSubsystem_OnFadeoutSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveEffectsSubsystem.OnGrowbackSubstageChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnviroWaveEffectsSubsystem::OnGrowbackSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveGrowbackSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveEffectsSubsystem", "OnGrowbackSubstageChanged");

	Params::CrEnviroWaveEffectsSubsystem_OnGrowbackSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveEffectsSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrEnviroWaveEffectsSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveEffectsSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveEffectsSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrEnviroWaveEffectsSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveEffectsSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersRepActor.OnRepGlobalGatherablePCGSeed
// (Final, Native, Private)

void ACrGatherableSpawnersRepActor::OnRepGlobalGatherablePCGSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersRepActor", "OnRepGlobalGatherablePCGSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveMaterialMapComponent.ChangeMaterialState
// (Native, Public, BlueprintCallable)
// Parameters:
// ECrEnviroWaveMaterialState              WantedMaterialState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnviroWaveMaterialMapComponent::ChangeMaterialState(ECrEnviroWaveMaterialState WantedMaterialState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveMaterialMapComponent", "ChangeMaterialState");

	Params::CrEnviroWaveMaterialMapComponent_ChangeMaterialState Parms{};

	Parms.WantedMaterialState = WantedMaterialState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInputConfig.FindAbilityInputActionForTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLogNotFound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* UCrInputConfig::FindAbilityInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInputConfig", "FindAbilityInputActionForTag");

	Params::CrInputConfig_FindAbilityInputActionForTag Parms{};

	Parms.InputTag = std::move(InputTag);
	Parms.bLogNotFound = bLogNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInputConfig.FindNativeInputActionForTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              InputTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bLogNotFound                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* UCrInputConfig::FindNativeInputActionForTag(const struct FGameplayTag& InputTag, bool bLogNotFound) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInputConfig", "FindNativeInputActionForTag");

	Params::CrInputConfig_FindNativeInputActionForTag Parms{};

	Parms.InputTag = std::move(InputTag);
	Parms.bLogNotFound = bLogNotFound;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveRegion.DisableEnviroWaveVolume
// (Final, Native, Public, BlueprintCallable)

void ACrEnviroWaveRegion::DisableEnviroWaveVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveRegion", "DisableEnviroWaveVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveRegion.EnableEnviroWaveVolume
// (Final, Native, Public, BlueprintCallable)

void ACrEnviroWaveRegion::EnableEnviroWaveVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveRegion", "EnableEnviroWaveVolume");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerMapMenuDataComponent.OnMapMenuMarkerFiltersOnOffStatusLoaded
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// const TArray<bool>&                     FiltersOnOffStatus                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCrPlayerMapMenuDataComponent::OnMapMenuMarkerFiltersOnOffStatusLoaded(const TArray<bool>& FiltersOnOffStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerMapMenuDataComponent", "OnMapMenuMarkerFiltersOnOffStatusLoaded");

	Params::CrPlayerMapMenuDataComponent_OnMapMenuMarkerFiltersOnOffStatusLoaded Parms{};

	Parms.FiltersOnOffStatus = std::move(FiltersOnOffStatus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerMapMenuDataComponent.OnRep_EncodedFogOfWar
// (Final, Native, Private)

void UCrPlayerMapMenuDataComponent::OnRep_EncodedFogOfWar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerMapMenuDataComponent", "OnRep_EncodedFogOfWar");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerMapMenuDataComponent.OnRep_PlayerFootstepPositionArray
// (Final, Native, Private)

void UCrPlayerMapMenuDataComponent::OnRep_PlayerFootstepPositionArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerMapMenuDataComponent", "OnRep_PlayerFootstepPositionArray");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerMapMenuDataComponent.SetMapMenuMarkerFiltersOnOffStatusServer
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   FilterIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPlayerMapMenuDataComponent::SetMapMenuMarkerFiltersOnOffStatusServer(int32 FilterIndex, bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerMapMenuDataComponent", "SetMapMenuMarkerFiltersOnOffStatusServer");

	Params::CrPlayerMapMenuDataComponent_SetMapMenuMarkerFiltersOnOffStatusServer Parms{};

	Parms.FilterIndex = FilterIndex;
	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.CancelCurrentWave
// (Final, Native, Public, BlueprintCallable)

void UCrEnviroWaveSubsystem::CancelCurrentWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "CancelCurrentWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.ForceWaveStageProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InWaveProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnviroWaveSubsystem::ForceWaveStageProgress(float InWaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "ForceWaveStageProgress");

	Params::CrEnviroWaveSubsystem_ForceWaveStageProgress Parms{};

	Parms.InWaveProgress = InWaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrEnviroWaveSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrEnviroWaveSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.PauseCurrentWave
// (Final, Native, Public, BlueprintCallable)

void UCrEnviroWaveSubsystem::PauseCurrentWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "PauseCurrentWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.ResumeCurrentWave
// (Final, Native, Public, BlueprintCallable)

void UCrEnviroWaveSubsystem::ResumeCurrentWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "ResumeCurrentWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.StartWave
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnviroWaveSubsystem::StartWave(EEnviroWave WaveType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "StartWave");

	Params::CrEnviroWaveSubsystem_StartWave Parms{};

	Parms.WaveType = WaveType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.StartWaveCustom
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCrEnviroWaveSubsystem::StartWaveCustom(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "StartWaveCustom");

	Params::CrEnviroWaveSubsystem_StartWaveCustom Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveSubsystem.GetCurrentStage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEnviroWaveStage                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEnviroWaveStage UCrEnviroWaveSubsystem::GetCurrentStage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "GetCurrentStage");

	Params::CrEnviroWaveSubsystem_GetCurrentStage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.GetCurrentStageProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrEnviroWaveSubsystem::GetCurrentStageProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "GetCurrentStageProgress");

	Params::CrEnviroWaveSubsystem_GetCurrentStageProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.GetCurrentStageSettings
// (Final, Native, Public, Const)
// Parameters:
// const struct FCrEnviroWaveSettings      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FCrEnviroWaveSettings UCrEnviroWaveSubsystem::GetCurrentStageSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "GetCurrentStageSettings");

	Params::CrEnviroWaveSubsystem_GetCurrentStageSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.GetCurrentType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEnviroWave                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEnviroWave UCrEnviroWaveSubsystem::GetCurrentType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "GetCurrentType");

	Params::CrEnviroWaveSubsystem_GetCurrentType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.GetCurrentWaveTypeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCrEnviroWaveSubsystem::GetCurrentWaveTypeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "GetCurrentWaveTypeName");

	Params::CrEnviroWaveSubsystem_GetCurrentWaveTypeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.GetStageNameFromEnum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEnviroWaveStage                        Stage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCrEnviroWaveSubsystem::GetStageNameFromEnum(EEnviroWaveStage Stage) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "GetStageNameFromEnum");

	Params::CrEnviroWaveSubsystem_GetStageNameFromEnum Parms{};

	Parms.Stage = Stage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.GetTimeSinceLastWaveStarted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UCrEnviroWaveSubsystem::GetTimeSinceLastWaveStarted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "GetTimeSinceLastWaveStarted");

	Params::CrEnviroWaveSubsystem_GetTimeSinceLastWaveStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.GetWavePositionX
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrEnviroWaveSubsystem::GetWavePositionX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "GetWavePositionX");

	Params::CrEnviroWaveSubsystem_GetWavePositionX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.IsWaveInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrEnviroWaveSubsystem::IsWaveInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "IsWaveInProgress");

	Params::CrEnviroWaveSubsystem_IsWaveInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveSubsystem.IsWavePaused
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrEnviroWaveSubsystem::IsWavePaused() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveSubsystem", "IsWavePaused");

	Params::CrEnviroWaveSubsystem_IsWavePaused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveTimerSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrEnviroWaveTimerSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveTimerSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveTimerSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrEnviroWaveTimerSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveTimerSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveTimerSubsystem.WavesActive
// (Final, Native, Public)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnviroWaveTimerSubsystem::WavesActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveTimerSubsystem", "WavesActive");

	Params::CrEnviroWaveTimerSubsystem_WavesActive Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.HandleWaterEvaporatedChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsReplicationActor::HandleWaterEvaporatedChanged(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "HandleWaterEvaporatedChanged");

	Params::CrEnviroWaveVisualsReplicationActor_HandleWaterEvaporatedChanged Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.MulticastEnviroWaveCanceled
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsReplicationActor::MulticastEnviroWaveCanceled(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "MulticastEnviroWaveCanceled");

	Params::CrEnviroWaveVisualsReplicationActor_MulticastEnviroWaveCanceled Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.MulticastEnviroWaveFinished
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsReplicationActor::MulticastEnviroWaveFinished(EEnviroWave WaveType, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "MulticastEnviroWaveFinished");

	Params::CrEnviroWaveVisualsReplicationActor_MulticastEnviroWaveFinished Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.MulticastEnviroWaveForced
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   WaveProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsReplicationActor::MulticastEnviroWaveForced(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings, float WaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "MulticastEnviroWaveForced");

	Params::CrEnviroWaveVisualsReplicationActor_MulticastEnviroWaveForced Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);
	Parms.WaveProgress = WaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.MulticastEnviroWavePaused
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   WaveProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsReplicationActor::MulticastEnviroWavePaused(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings, float WaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "MulticastEnviroWavePaused");

	Params::CrEnviroWaveVisualsReplicationActor_MulticastEnviroWavePaused Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);
	Parms.WaveProgress = WaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.MulticastEnviroWaveStarted
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   WaveProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsReplicationActor::MulticastEnviroWaveStarted(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings, float WaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "MulticastEnviroWaveStarted");

	Params::CrEnviroWaveVisualsReplicationActor_MulticastEnviroWaveStarted Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);
	Parms.WaveProgress = WaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.OnFadeoutSubstageChanged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsReplicationActor::OnFadeoutSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveFadeoutSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "OnFadeoutSubstageChanged");

	Params::CrEnviroWaveVisualsReplicationActor_OnFadeoutSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.OnGrowbackSubstageChanged
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrEnviroWaveVisualsReplicationActor::OnGrowbackSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveGrowbackSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "OnGrowbackSubstageChanged");

	Params::CrEnviroWaveVisualsReplicationActor_OnGrowbackSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.OnIsWaterEvaporatedReplicated
// (Final, Native, Private)

void ACrEnviroWaveVisualsReplicationActor::OnIsWaterEvaporatedReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "OnIsWaterEvaporatedReplicated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsReplicationActor.OnWaterEvaporatedLastTimeChangedReplicated
// (Final, Native, Private)

void ACrEnviroWaveVisualsReplicationActor::OnWaterEvaporatedLastTimeChangedReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsReplicationActor", "OnWaterEvaporatedLastTimeChangedReplicated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsWorldSubsystem.DisableAllFXes
// (Final, Native, Public, BlueprintCallable)

void UCrEnviroWaveVisualsWorldSubsystem::DisableAllFXes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsWorldSubsystem", "DisableAllFXes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsWorldSubsystem.EnableAllFXes
// (Final, Native, Public, BlueprintCallable)

void UCrEnviroWaveVisualsWorldSubsystem::EnableAllFXes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsWorldSubsystem", "EnableAllFXes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsWorldSubsystem.OnFadeoutSubstageChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     InSettings                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              InSubstage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InProgress                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnviroWaveVisualsWorldSubsystem::OnFadeoutSubstageChanged(const struct FCrEnviroWaveSettings& InSettings, EEnviroWaveFadeoutSubstage InSubstage, float InProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsWorldSubsystem", "OnFadeoutSubstageChanged");

	Params::CrEnviroWaveVisualsWorldSubsystem_OnFadeoutSubstageChanged Parms{};

	Parms.InSettings = std::move(InSettings);
	Parms.InSubstage = InSubstage;
	Parms.InProgress = InProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsWorldSubsystem.OnGrowbackSubstageChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     InSettings                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             InSubstage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InProgress                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrEnviroWaveVisualsWorldSubsystem::OnGrowbackSubstageChanged(const struct FCrEnviroWaveSettings& InSettings, EEnviroWaveGrowbackSubstage InSubstage, float InProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsWorldSubsystem", "OnGrowbackSubstageChanged");

	Params::CrEnviroWaveVisualsWorldSubsystem_OnGrowbackSubstageChanged Parms{};

	Parms.InSettings = std::move(InSettings);
	Parms.InSubstage = InSubstage;
	Parms.InProgress = InProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrEnviroWaveVisualsWorldSubsystem.EvaporatedWaterLastTimeChange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrEnviroWaveVisualsWorldSubsystem::EvaporatedWaterLastTimeChange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsWorldSubsystem", "EvaporatedWaterLastTimeChange");

	Params::CrEnviroWaveVisualsWorldSubsystem_EvaporatedWaterLastTimeChange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrEnviroWaveVisualsWorldSubsystem.IsWaterEvaporated
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrEnviroWaveVisualsWorldSubsystem::IsWaterEvaporated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrEnviroWaveVisualsWorldSubsystem", "IsWaterEvaporated");

	Params::CrEnviroWaveVisualsWorldSubsystem_IsWaterEvaporated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrExperienceManagerComponent.OnRep_CurrentExperience
// (Final, Native, Private)

void UCrExperienceManagerComponent::OnRep_CurrentExperience()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrExperienceManagerComponent", "OnRep_CurrentExperience");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrExporter.OnCorporationChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             NewCorporation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrExporter::OnCorporationChanged(class FName NewCorporation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrExporter", "OnCorporationChanged");

	Params::CrExporter_OnCorporationChanged Parms{};

	Parms.NewCorporation = NewCorporation;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrExporter.OnRecipeChangedSignal
// (Final, Native, Protected)
// Parameters:
// const struct FMassEntityHandle&         EntityHandle                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SignalName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrExporter::OnRecipeChangedSignal(const struct FMassEntityHandle& EntityHandle, class FName SignalName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrExporter", "OnRecipeChangedSignal");

	Params::CrExporter_OnRecipeChangedSignal Parms{};

	Parms.EntityHandle = std::move(EntityHandle);
	Parms.SignalName = SignalName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrExtractor.OnResourceDetected
// (Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class UCrItemDataBase>      OreItemClass                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrExtractor::OnResourceDetected(TSubclassOf<class UCrItemDataBase> OreItemClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrExtractor", "OnResourceDetected");

	Params::CrExtractor_OnResourceDetected Parms{};

	Parms.OreItemClass = OreItemClass;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrFadeSubsystem.Fade
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRuntimeFloatCurve&        FadeCurve                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FLinearColor&              InColor                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrFadeSubsystem::Fade(const struct FRuntimeFloatCurve& FadeCurve, const struct FLinearColor& InColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFadeSubsystem", "Fade");

	Params::CrFadeSubsystem_Fade Parms{};

	Parms.FadeCurve = std::move(FadeCurve);
	Parms.InColor = std::move(InColor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlashlightComponent.FlashlightInputPressCompleted
// (Final, Native, Public, BlueprintCallable)

void UCrFlashlightComponent::FlashlightInputPressCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlashlightComponent", "FlashlightInputPressCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlashlightComponent.FlashlightinputPressStarted
// (Final, Native, Public, BlueprintCallable)

void UCrFlashlightComponent::FlashlightinputPressStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlashlightComponent", "FlashlightinputPressStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlashlightComponent.OnRep_CurrentMode
// (Final, Native, Public)

void UCrFlashlightComponent::OnRep_CurrentMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlashlightComponent", "OnRep_CurrentMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlashlightComponent.OnRep_FlashlightActive
// (Final, Native, Public)

void UCrFlashlightComponent::OnRep_FlashlightActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlashlightComponent", "OnRep_FlashlightActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlashlightComponent.SetFlashlightActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrFlashlightComponent::SetFlashlightActive(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlashlightComponent", "SetFlashlightActive");

	Params::CrFlashlightComponent_SetFlashlightActive Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlashlightComponent.SetMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrFlashlightComponent::SetMode(int32 Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlashlightComponent", "SetMode");

	Params::CrFlashlightComponent_SetMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlashlightComponent.SwitchFlashlightMode
// (Final, Native, Public, BlueprintCallable)

void UCrFlashlightComponent::SwitchFlashlightMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlashlightComponent", "SwitchFlashlightMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlowEventBase.Complete
// (Native, Public)

void UCrFlowEventBase::Complete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlowEventBase", "Complete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreActor.BP_OnEnviroWaveStarted
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// EEnviroWave                             InWaveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        InWaveStage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     InWaveSettings                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InWaveProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreActor::BP_OnEnviroWaveStarted(EEnviroWave InWaveType, EEnviroWaveStage InWaveStage, const struct FCrEnviroWaveSettings& InWaveSettings, float InWaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "BP_OnEnviroWaveStarted");

	Params::CrOreActor_BP_OnEnviroWaveStarted Parms{};

	Parms.InWaveType = InWaveType;
	Parms.InWaveStage = InWaveStage;
	Parms.InWaveSettings = std::move(InWaveSettings);
	Parms.InWaveProgress = InWaveProgress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrOreActor.BP_OnFadeoutSubstageChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreActor::BP_OnFadeoutSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveFadeoutSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "BP_OnFadeoutSubstageChanged");

	Params::CrOreActor_BP_OnFadeoutSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrOreActor.BP_OnGrowbackSubstageChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreActor::BP_OnGrowbackSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveGrowbackSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "BP_OnGrowbackSubstageChanged");

	Params::CrOreActor_BP_OnGrowbackSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrOreActor.BP_OnOreActivated
// (Event, Public, BlueprintEvent)

void ACrOreActor::BP_OnOreActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "BP_OnOreActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrOreActor.BP_OnSpawnedWithResourceDepleted
// (Event, Public, BlueprintEvent)

void ACrOreActor::BP_OnSpawnedWithResourceDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "BP_OnSpawnedWithResourceDepleted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrOreActor.MulticastOnWeakSpotDepletedCosmeticsStart
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)
// Parameters:
// class FName                             InWeakSpotSocketName                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreActor::MulticastOnWeakSpotDepletedCosmeticsStart(class FName InWeakSpotSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "MulticastOnWeakSpotDepletedCosmeticsStart");

	Params::CrOreActor_MulticastOnWeakSpotDepletedCosmeticsStart Parms{};

	Parms.InWeakSpotSocketName = InWeakSpotSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreActor.OnEnviroWaveFinished
// (Native, Protected, HasOutParams)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ACrOreActor::OnEnviroWaveFinished(EEnviroWave WaveType, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "OnEnviroWaveFinished");

	Params::CrOreActor_OnEnviroWaveFinished Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreActor.OnEnviroWaveStarted
// (Native, Protected, HasOutParams)
// Parameters:
// EEnviroWave                             InWaveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        InWaveStage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     InWaveSettings                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InWaveProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreActor::OnEnviroWaveStarted(EEnviroWave InWaveType, EEnviroWaveStage InWaveStage, const struct FCrEnviroWaveSettings& InWaveSettings, float InWaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "OnEnviroWaveStarted");

	Params::CrOreActor_OnEnviroWaveStarted Parms{};

	Parms.InWaveType = InWaveType;
	Parms.InWaveStage = InWaveStage;
	Parms.InWaveSettings = std::move(InWaveSettings);
	Parms.InWaveProgress = InWaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreActor.OnFadeoutSubstageChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreActor::OnFadeoutSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveFadeoutSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "OnFadeoutSubstageChanged");

	Params::CrOreActor_OnFadeoutSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreActor.OnGrowbackSubstageChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreActor::OnGrowbackSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveGrowbackSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "OnGrowbackSubstageChanged");

	Params::CrOreActor_OnGrowbackSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreActor.OnMiningWeakSpotDepletedCosmeticsStart
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FTransform&                CosmeticTransform                                      (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrOreActor::OnMiningWeakSpotDepletedCosmeticsStart(const struct FTransform& CosmeticTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "OnMiningWeakSpotDepletedCosmeticsStart");

	Params::CrOreActor_OnMiningWeakSpotDepletedCosmeticsStart Parms{};

	Parms.CosmeticTransform = std::move(CosmeticTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrOreActor.OnRep_OreData
// (Native, Protected)

void ACrOreActor::OnRep_OreData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "OnRep_OreData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreActor.OnResourceDepletedCosmeticsStart
// (Event, Public, BlueprintEvent)

void ACrOreActor::OnResourceDepletedCosmeticsStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreActor", "OnResourceDepletedCosmeticsStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrStandaloneMeteOreChunk.BP_SetAsMineableChunk
// (Final, Native, Public, BlueprintCallable)

void ACrStandaloneMeteOreChunk::BP_SetAsMineableChunk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneMeteOreChunk", "BP_SetAsMineableChunk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStandaloneMeteOreChunk.BP_SetAsNonMineableChunk
// (Final, Native, Public, BlueprintCallable)

void ACrStandaloneMeteOreChunk::BP_SetAsNonMineableChunk()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneMeteOreChunk", "BP_SetAsNonMineableChunk");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStandaloneMeteOreChunk.OnResourceDepletedBehaviour
// (Final, Native, Private)

void ACrStandaloneMeteOreChunk::OnResourceDepletedBehaviour()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneMeteOreChunk", "OnResourceDepletedBehaviour");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStandaloneMeteOreChunk.IsMineableChunk
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrStandaloneMeteOreChunk::IsMineableChunk() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneMeteOreChunk", "IsMineableChunk");

	Params::CrStandaloneMeteOreChunk_IsMineableChunk Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCutsceneFlowEvent.CutsceneCompleted
// (Final, Native, Private)

void UCrCutsceneFlowEvent::CutsceneCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCutsceneFlowEvent", "CutsceneCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrIvySubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrIvySubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrIvySubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrIvySubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrIvySubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrIvySubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.SurfaceTypesFunctionLibrary.GetSurfaceTypeName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const EPhysicalSurface&                 Surface                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName USurfaceTypesFunctionLibrary::GetSurfaceTypeName(const EPhysicalSurface& Surface)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SurfaceTypesFunctionLibrary", "GetSurfaceTypeName");

	Params::SurfaceTypesFunctionLibrary_GetSurfaceTypeName Parms{};

	Parms.Surface = Surface;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSteamSubsystem.HasDLC
// (Final, Native, Public, Const)
// Parameters:
// int32                                   DlcAppId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSteamSubsystem::HasDLC(int32 DlcAppId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSteamSubsystem", "HasDLC");

	Params::CrSteamSubsystem_HasDLC Parms{};

	Parms.DlcAppId = DlcAppId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSteamSubsystem.IsAvailable
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSteamSubsystem::IsAvailable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSteamSubsystem", "IsAvailable");

	Params::CrSteamSubsystem_IsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSteamSubsystem.IsUserLoggedIn
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSteamSubsystem::IsUserLoggedIn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSteamSubsystem", "IsUserLoggedIn");

	Params::CrSteamSubsystem_IsUserLoggedIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrZiplineSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrZiplineSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplineSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrZiplineSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrZiplineSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplineSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.ClientCreateSearchRequest
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCommonSession_SearchSessionRequest*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonSession_SearchSessionRequest* UCrSessionSubsystem::ClientCreateSearchRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "ClientCreateSearchRequest");

	Params::CrSessionSubsystem_ClientCreateSearchRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSessionSubsystem.ClientFindSessions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCommonSession_SearchSessionRequest*Request                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InIPAddress                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    InPort                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSessionSubsystem::ClientFindSessions(class UCommonSession_SearchSessionRequest* Request, const class FString& InIPAddress, const class FString& InPort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "ClientFindSessions");

	Params::CrSessionSubsystem_ClientFindSessions Parms{};

	Parms.Request = Request;
	Parms.InIPAddress = std::move(InIPAddress);
	Parms.InPort = std::move(InPort);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.ClientJoinSession
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCommonSession_SearchResult*      SearchResult                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSessionSubsystem::ClientJoinSession(class UCommonSession_SearchResult* SearchResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "ClientJoinSession");

	Params::CrSessionSubsystem_ClientJoinSession Parms{};

	Parms.SearchResult = SearchResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.ClientTryToLogin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSessionSubsystem::ClientTryToLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "ClientTryToLogin");

	Params::CrSessionSubsystem_ClientTryToLogin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSessionSubsystem.HandleNetworkFailure
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNetDriver*                       NetDriver                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ENetworkFailure                         FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ErrorString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSessionSubsystem::HandleNetworkFailure(class UWorld* InWorld, class UNetDriver* NetDriver, ENetworkFailure FailureType, const class FString& ErrorString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "HandleNetworkFailure");

	Params::CrSessionSubsystem_HandleNetworkFailure Parms{};

	Parms.InWorld = InWorld;
	Parms.NetDriver = NetDriver;
	Parms.FailureType = FailureType;
	Parms.ErrorString = std::move(ErrorString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.HandleTravelFailure
// (Final, Native, Protected)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETravelFailure                          FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ErrorString                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSessionSubsystem::HandleTravelFailure(class UWorld* World, ETravelFailure FailureType, const class FString& ErrorString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "HandleTravelFailure");

	Params::CrSessionSubsystem_HandleTravelFailure Parms{};

	Parms.World = World;
	Parms.FailureType = FailureType;
	Parms.ErrorString = std::move(ErrorString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.OnlineSetUsingDedicatedSessions
// (Final, Exec, Native, Protected)

void UCrSessionSubsystem::OnlineSetUsingDedicatedSessions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "OnlineSetUsingDedicatedSessions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.OnlineSetUsingP2PLobbies
// (Final, Exec, Native, Protected)

void UCrSessionSubsystem::OnlineSetUsingP2PLobbies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "OnlineSetUsingP2PLobbies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.OnUserInitialized
// (Final, Native, Protected)
// Parameters:
// const class UCommonUserInfo*            UserInfo                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FText&                      Error                                                  (Parm, NativeAccessSpecifierPublic)
// ECommonUserPrivilege                    RequestedPrivilege                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommonUserOnlineContext                OnlineContext                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSessionSubsystem::OnUserInitialized(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestedPrivilege, ECommonUserOnlineContext OnlineContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "OnUserInitialized");

	Params::CrSessionSubsystem_OnUserInitialized Parms{};

	Parms.UserInfo = UserInfo;
	Parms.bSuccess = bSuccess;
	Parms.Error = std::move(Error);
	Parms.RequestedPrivilege = RequestedPrivilege;
	Parms.OnlineContext = OnlineContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.ServerCreateSession
// (Final, Native, Public, BlueprintCallable)

void UCrSessionSubsystem::ServerCreateSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "ServerCreateSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.SetCommonSessionOnlineMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECommonSessionOnlineMode                Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSessionSubsystem::SetCommonSessionOnlineMode(ECommonSessionOnlineMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "SetCommonSessionOnlineMode");

	Params::CrSessionSubsystem_SetCommonSessionOnlineMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.SetOnlineConnectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrOnlineConnectionMode                 Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSessionSubsystem::SetOnlineConnectionMode(ECrOnlineConnectionMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "SetOnlineConnectionMode");

	Params::CrSessionSubsystem_SetOnlineConnectionMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.SetOnlineMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrOnlineSessionMode                    InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSessionSubsystem::SetOnlineMode(ECrOnlineSessionMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "SetOnlineMode");

	Params::CrSessionSubsystem_SetOnlineMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSessionSubsystem.GetDefaultExperience
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCrExperienceDefinition*    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCrExperienceDefinition* UCrSessionSubsystem::GetDefaultExperience() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "GetDefaultExperience");

	Params::CrSessionSubsystem_GetDefaultExperience Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSessionSubsystem.GetDefaultMapPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrSessionSubsystem::GetDefaultMapPath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "GetDefaultMapPath");

	Params::CrSessionSubsystem_GetDefaultMapPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSessionSubsystem.GetIsLoggedIn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSessionSubsystem::GetIsLoggedIn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSessionSubsystem", "GetIsLoggedIn");

	Params::CrSessionSubsystem_GetIsLoggedIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrZiplineReplicator.OnPreSaveStart
// (Final, Native, Private)

void ACrZiplineReplicator::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplineReplicator", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrZiplineReplicator.OnSaveLoaded
// (Final, Native, Private)

void ACrZiplineReplicator::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplineReplicator", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerCharacterAnimInstance.GetCharacterSpeed
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrPlayerCharacterAnimInstance::GetCharacterSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerCharacterAnimInstance", "GetCharacterSpeed");

	Params::CrPlayerCharacterAnimInstance_GetCharacterSpeed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerCharacterAnimInstance.GetCharacterVelocity
// (Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UCrPlayerCharacterAnimInstance::GetCharacterVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerCharacterAnimInstance", "GetCharacterVelocity");

	Params::CrPlayerCharacterAnimInstance_GetCharacterVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrHelperDroneRailSpline.BP_CanBePlaced
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrHelperDroneRailSpline::BP_CanBePlaced()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHelperDroneRailSpline", "BP_CanBePlaced");

	Params::CrHelperDroneRailSpline_BP_CanBePlaced Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrHelperDroneRailSpline.BP_OnCollisionHitsChanged
// (Event, Protected, BlueprintEvent)

void ACrHelperDroneRailSpline::BP_OnCollisionHitsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHelperDroneRailSpline", "BP_OnCollisionHitsChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrHelperDroneRailSpline.SetRailConnectorMesh
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrHelperDroneRailSpline::SetRailConnectorMesh(class UStaticMeshComponent* Mesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHelperDroneRailSpline", "SetRailConnectorMesh");

	Params::CrHelperDroneRailSpline_SetRailConnectorMesh Parms{};

	Parms.Mesh = Mesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHelperDroneRailSpline.UpdateSplineComponentCount
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class USplineMeshComponent*>&    Splines                                                (Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   SectionCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SectionLength                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      SM                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrHelperDroneRailSpline::UpdateSplineComponentCount(TArray<class USplineMeshComponent*>& Splines, int32 SectionCount, float SectionLength, class UStaticMesh* SM)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHelperDroneRailSpline", "UpdateSplineComponentCount");

	Params::CrHelperDroneRailSpline_UpdateSplineComponentCount Parms{};

	Parms.Splines = std::move(Splines);
	Parms.SectionCount = SectionCount;
	Parms.SectionLength = SectionLength;
	Parms.SM = SM;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Splines = std::move(Parms.Splines);
}


// Function Chimera.CrFlowSubsystem.OnContextualEventExecuted
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContextValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrFlowSubsystem::OnContextualEventExecuted(class AActor* Target, class FName Context, class FName ContextValue, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlowSubsystem", "OnContextualEventExecuted");

	Params::CrFlowSubsystem_OnContextualEventExecuted Parms{};

	Parms.Target = Target;
	Parms.Context = Context;
	Parms.ContextValue = ContextValue;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlowSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrFlowSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlowSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrFlowSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrFlowSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFlowSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSulphurLogic.OnSulphurActivityChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrSulphurLogic::OnSulphurActivityChanged(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSulphurLogic", "OnSulphurActivityChanged");

	Params::CrSulphurLogic_OnSulphurActivityChanged Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrFoundableMassEntityConfigAsset.GetHighResActorVisualization
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AActor> UCrFoundableMassEntityConfigAsset::GetHighResActorVisualization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrFoundableMassEntityConfigAsset", "GetHighResActorVisualization");

	Params::CrFoundableMassEntityConfigAsset_GetHighResActorVisualization Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrTeleportingSubsystem.OnTeleporterStateChanged
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         InTeleporter                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrTeleportingSubsystem::OnTeleporterStateChanged(const struct FMassEntityHandle& InTeleporter, class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTeleportingSubsystem", "OnTeleporterStateChanged");

	Params::CrTeleportingSubsystem_OnTeleporterStateChanged Parms{};

	Parms.InTeleporter = std::move(InTeleporter);
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTechnologyKeeper.OnRep_AllBuildings
// (Final, Native, Private)

void ACrTechnologyKeeper::OnRep_AllBuildings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTechnologyKeeper", "OnRep_AllBuildings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTechnologyKeeper.OnRep_AvailableBuildings
// (Final, Native, Private)

void ACrTechnologyKeeper::OnRep_AvailableBuildings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTechnologyKeeper", "OnRep_AvailableBuildings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameInstance.PlayMainMenuMusic
// (Final, Native, Public, BlueprintCallable)

void UCrGameInstance::PlayMainMenuMusic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameInstance", "PlayMainMenuMusic");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameInstance.SetGameInstanceState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrGameInstanceState                    State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameInstance::SetGameInstanceState(ECrGameInstanceState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameInstance", "SetGameInstanceState");

	Params::CrGameInstance_SetGameInstanceState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameModeBase.GetPawnDataForController
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AController*                InController                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCrPawnData*                ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCrPawnData* ACrGameModeBase::GetPawnDataForController(const class AController* InController) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameModeBase", "GetPawnDataForController");

	Params::CrGameModeBase_GetPawnDataForController Parms{};

	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameStateBase.GetActiveInteractionOfPlayerWithBuilding
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BuildingMassReplicationHelper                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUniqueNetIdRepl&          PlayerInteracting                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBuildingManualInteraction*             OutInteractionType                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrGameStateBase::GetActiveInteractionOfPlayerWithBuilding(const struct FCrMassEntityReplicationHelper& BuildingMassReplicationHelper, const struct FUniqueNetIdRepl& PlayerInteracting, EBuildingManualInteraction* OutInteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "GetActiveInteractionOfPlayerWithBuilding");

	Params::CrGameStateBase_GetActiveInteractionOfPlayerWithBuilding Parms{};

	Parms.BuildingMassReplicationHelper = std::move(BuildingMassReplicationHelper);
	Parms.PlayerInteracting = std::move(PlayerInteracting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInteractionType != nullptr)
		*OutInteractionType = Parms.OutInteractionType;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameStateBase.GetManualInteractionWithBuildingProgress
// (Final, Native, Public)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BuildingMassReplicationHelper                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUniqueNetIdRepl&          PlayerInteracting                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrGameStateBase::GetManualInteractionWithBuildingProgress(const struct FCrMassEntityReplicationHelper& BuildingMassReplicationHelper, const struct FUniqueNetIdRepl& PlayerInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "GetManualInteractionWithBuildingProgress");

	Params::CrGameStateBase_GetManualInteractionWithBuildingProgress Parms{};

	Parms.BuildingMassReplicationHelper = std::move(BuildingMassReplicationHelper);
	Parms.PlayerInteracting = std::move(PlayerInteracting);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameStateBase.GetPlayerSurvivalDataForNetId
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FString&                    UniqueNetId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCrCharacterPlayerSurvivalData*  OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrGameStateBase::GetPlayerSurvivalDataForNetId(const class FString& UniqueNetId, struct FCrCharacterPlayerSurvivalData* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "GetPlayerSurvivalDataForNetId");

	Params::CrGameStateBase_GetPlayerSurvivalDataForNetId Parms{};

	Parms.UniqueNetId = std::move(UniqueNetId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function Chimera.CrGameStateBase.HandleSulphurActivityChanged
// (Final, Native, Protected)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::HandleSulphurActivityChanged(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "HandleSulphurActivityChanged");

	Params::CrGameStateBase_HandleSulphurActivityChanged Parms{};

	Parms.bActive = bActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.IsActiveInteractionWithBuilding
// (Final, Native, Public)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BuildingMassReplicationHelper                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrGameStateBase::IsActiveInteractionWithBuilding(const struct FCrMassEntityReplicationHelper& BuildingMassReplicationHelper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "IsActiveInteractionWithBuilding");

	Params::CrGameStateBase_IsActiveInteractionWithBuilding Parms{};

	Parms.BuildingMassReplicationHelper = std::move(BuildingMassReplicationHelper);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameStateBase.MulticastClientChatCommit
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// class ACrPlayerStateBase*               Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ChatText                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::MulticastClientChatCommit(class ACrPlayerStateBase* Player, const class FString& ChatText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "MulticastClientChatCommit");

	Params::CrGameStateBase_MulticastClientChatCommit Parms{};

	Parms.Player = Player;
	Parms.ChatText = std::move(ChatText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.MulticastExecuteFlow
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// const class FString&                    InFlowName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::MulticastExecuteFlow(const class FString& InFlowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "MulticastExecuteFlow");

	Params::CrGameStateBase_MulticastExecuteFlow Parms{};

	Parms.InFlowName = std::move(InFlowName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.MulticastOnObjectiveFailed
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ACrGameStateBase::MulticastOnObjectiveFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "MulticastOnObjectiveFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.MulticastSystemMessage
// (Net, Native, Event, NetMulticast, Public)
// Parameters:
// ECrSystemMessageType                    MessageType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PlayerNickname                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::MulticastSystemMessage(ECrSystemMessageType MessageType, const class FString& PlayerNickname)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "MulticastSystemMessage");

	Params::CrGameStateBase_MulticastSystemMessage Parms{};

	Parms.MessageType = MessageType;
	Parms.PlayerNickname = std::move(PlayerNickname);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnAudiologPlayed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACrAudiologBase*                  Audiolog                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::OnAudiologPlayed(class ACrAudiologBase* Audiolog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnAudiologPlayed");

	Params::CrGameStateBase_OnAudiologPlayed Parms{};

	Parms.Audiolog = Audiolog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnControllerPossesedNewPlayer
// (Final, Native, Public)
// Parameters:
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::OnControllerPossesedNewPlayer(class APawn* InPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnControllerPossesedNewPlayer");

	Params::CrGameStateBase_OnControllerPossesedNewPlayer Parms{};

	Parms.InPawn = InPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnDatapadRead
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class ACrDatapadBase*                   Datapad                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EntryName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::OnDatapadRead(class ACrDatapadBase* Datapad, class FName EntryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnDatapadRead");

	Params::CrGameStateBase_OnDatapadRead Parms{};

	Parms.Datapad = Datapad;
	Parms.EntryName = EntryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnPreSaveStart
// (Final, Native, Public)

void ACrGameStateBase::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_AntennasOwner
// (Final, Native, Private)

void ACrGameStateBase::OnRep_AntennasOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_AntennasOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_BaseCoreReplicationHelper
// (Final, Native, Private)

void ACrGameStateBase::OnRep_BaseCoreReplicationHelper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_BaseCoreReplicationHelper");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_ElectricitySubgraphDataReplicator
// (Final, Native, Private)

void ACrGameStateBase::OnRep_ElectricitySubgraphDataReplicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_ElectricitySubgraphDataReplicator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_PlayerPingData
// (Final, Native, Private)

void ACrGameStateBase::OnRep_PlayerPingData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_PlayerPingData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_ProfessionSelection
// (Final, Native, Private)

void ACrGameStateBase::OnRep_ProfessionSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_ProfessionSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_ShouldPause
// (Final, Native, Private)

void ACrGameStateBase::OnRep_ShouldPause()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_ShouldPause");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_StandaloneInfectionASCReplicator
// (Final, Native, Private)

void ACrGameStateBase::OnRep_StandaloneInfectionASCReplicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_StandaloneInfectionASCReplicator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_SulphurActive
// (Final, Native, Private)

void ACrGameStateBase::OnRep_SulphurActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_SulphurActive");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_TechnologyKeeper
// (Final, Native, Private)

void ACrGameStateBase::OnRep_TechnologyKeeper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_TechnologyKeeper");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnRep_TimerActor
// (Final, Native, Private)

void ACrGameStateBase::OnRep_TimerActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnRep_TimerActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.OnSaveLoaded
// (Final, Native, Public)

void ACrGameStateBase::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.TickActiveManualInteractionsWithBuildings
// (Final, Native, Public)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::TickActiveManualInteractionsWithBuildings(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "TickActiveManualInteractionsWithBuildings");

	Params::CrGameStateBase_TickActiveManualInteractionsWithBuildings Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.TryStartInteractionWithBuilding
// (Final, Native, Public)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BuildingMassReplicationHelper                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FUniqueNetIdRepl&          PlayerInteracting                                      (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBuildingManualInteraction              InteractionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGameStateBase::TryStartInteractionWithBuilding(const struct FCrMassEntityReplicationHelper& BuildingMassReplicationHelper, const struct FUniqueNetIdRepl& PlayerInteracting, EBuildingManualInteraction InteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "TryStartInteractionWithBuilding");

	Params::CrGameStateBase_TryStartInteractionWithBuilding Parms{};

	Parms.BuildingMassReplicationHelper = std::move(BuildingMassReplicationHelper);
	Parms.PlayerInteracting = std::move(PlayerInteracting);
	Parms.InteractionType = InteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameStateBase.WasAudiologPlayed
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACrAudiologBase*                  Audiolog                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrGameStateBase::WasAudiologPlayed(class ACrAudiologBase* Audiolog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "WasAudiologPlayed");

	Params::CrGameStateBase_WasAudiologPlayed Parms{};

	Parms.Audiolog = Audiolog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameStateBase.WasDatapadRead
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACrDatapadBase*                   Datapad                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrGameStateBase::WasDatapadRead(class ACrDatapadBase* Datapad)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "WasDatapadRead");

	Params::CrGameStateBase_WasDatapadRead Parms{};

	Parms.Datapad = Datapad;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameStateBase.IsCutsceneActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrGameStateBase::IsCutsceneActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "IsCutsceneActive");

	Params::CrGameStateBase_IsCutsceneActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameStateBase.IsInTutorial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrGameStateBase::IsInTutorial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameStateBase", "IsInTutorial");

	Params::CrGameStateBase_IsInTutorial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsDLSSSupported
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsDLSSSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrGameUserSettings", "IsDLSSSupported");

	Params::CrGameUserSettings_IsDLSSSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsNVIDIAReflexSupported
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsNVIDIAReflexSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrGameUserSettings", "IsNVIDIAReflexSupported");

	Params::CrGameUserSettings_IsNVIDIAReflexSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.Chimera_SetAntiAliasingMethod
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrAntiAliasingMode                     Method                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::Chimera_SetAntiAliasingMethod(ECrAntiAliasingMode Method)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Chimera_SetAntiAliasingMethod");

	Params::CrGameUserSettings_Chimera_SetAntiAliasingMethod Parms{};

	Parms.Method = Method;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.Chimera_SetAntiAliasingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::Chimera_SetAntiAliasingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Chimera_SetAntiAliasingQuality");

	Params::CrGameUserSettings_Chimera_SetAntiAliasingQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.Chimera_SetFoliageQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::Chimera_SetFoliageQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Chimera_SetFoliageQuality");

	Params::CrGameUserSettings_Chimera_SetFoliageQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.Chimera_SetGlobalIlluminationQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::Chimera_SetGlobalIlluminationQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Chimera_SetGlobalIlluminationQuality");

	Params::CrGameUserSettings_Chimera_SetGlobalIlluminationQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.Chimera_SetPostProcessingQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::Chimera_SetPostProcessingQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Chimera_SetPostProcessingQuality");

	Params::CrGameUserSettings_Chimera_SetPostProcessingQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.Chimera_SetReflectionQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::Chimera_SetReflectionQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Chimera_SetReflectionQuality");

	Params::CrGameUserSettings_Chimera_SetReflectionQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.Chimera_SetShadowQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::Chimera_SetShadowQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Chimera_SetShadowQuality");

	Params::CrGameUserSettings_Chimera_SetShadowQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.Get3dResolutionQuality
// (Final, Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrGameUserSettings::Get3dResolutionQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Get3dResolutionQuality");

	Params::CrGameUserSettings_Get3dResolutionQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetCustomUpscalerSharpness
// (Final, Native, Public)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetCustomUpscalerSharpness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetCustomUpscalerSharpness");

	Params::CrGameUserSettings_GetCustomUpscalerSharpness Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetDLSSQuality
// (Final, Native, Public)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrGameUserSettings::GetDLSSQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetDLSSQuality");

	Params::CrGameUserSettings_GetDLSSQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetMotionBlurQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrGameUserSettings::GetMotionBlurQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetMotionBlurQuality");

	Params::CrGameUserSettings_GetMotionBlurQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetMotionBlurScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetMotionBlurScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetMotionBlurScale");

	Params::CrGameUserSettings_GetMotionBlurScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsFSRSupported
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsFSRSupported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "IsFSRSupported");

	Params::CrGameUserSettings_IsFSRSupported Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsLandscapeNaniteTessellationEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsLandscapeNaniteTessellationEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "IsLandscapeNaniteTessellationEnabled");

	Params::CrGameUserSettings_IsLandscapeNaniteTessellationEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsMotionBlurEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsMotionBlurEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "IsMotionBlurEnabled");

	Params::CrGameUserSettings_IsMotionBlurEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.RefreshCustomScalabilityQualityEvents
// (Final, Native, Public)

void UCrGameUserSettings::RefreshCustomScalabilityQualityEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "RefreshCustomScalabilityQualityEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.RunAutoBenchmark
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSaveImmediately                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::RunAutoBenchmark(bool bSaveImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "RunAutoBenchmark");

	Params::CrGameUserSettings_RunAutoBenchmark Parms{};

	Parms.bSaveImmediately = bSaveImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.Set3dResolutionQuality
// (Final, Native, Public)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::Set3dResolutionQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "Set3dResolutionQuality");

	Params::CrGameUserSettings_Set3dResolutionQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetAmbientVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetAmbientVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetAmbientVolume");

	Params::CrGameUserSettings_SetAmbientVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetAMDAntiLagEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetAMDAntiLagEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetAMDAntiLagEnabled");

	Params::CrGameUserSettings_SetAMDAntiLagEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetAntiAliasingMode
// (Final, Native, Public)
// Parameters:
// ECrAntiAliasingMode                     Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetAntiAliasingMode(ECrAntiAliasingMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetAntiAliasingMode");

	Params::CrGameUserSettings_SetAntiAliasingMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetAudioOutputDeviceId
// (Final, Native, Public)
// Parameters:
// const class FString&                    InAudioOutputDeviceId                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetAudioOutputDeviceId(const class FString& InAudioOutputDeviceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetAudioOutputDeviceId");

	Params::CrGameUserSettings_SetAudioOutputDeviceId Parms{};

	Parms.InAudioOutputDeviceId = std::move(InAudioOutputDeviceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetControllerPlatform
// (Final, Native, Public)
// Parameters:
// const class FName                       InControllerPlatform                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetControllerPlatform(const class FName InControllerPlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetControllerPlatform");

	Params::CrGameUserSettings_SetControllerPlatform Parms{};

	Parms.InControllerPlatform = InControllerPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetCustomUpscalerSharpness
// (Final, Native, Public)
// Parameters:
// float                                   InDLSSSharpness                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetCustomUpscalerSharpness(float InDLSSSharpness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetCustomUpscalerSharpness");

	Params::CrGameUserSettings_SetCustomUpscalerSharpness Parms{};

	Parms.InDLSSSharpness = InDLSSSharpness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetDesiredDeviceProfileQualitySuffix
// (Final, Native, Public)
// Parameters:
// const class FString&                    InDesiredSuffix                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetDesiredDeviceProfileQualitySuffix(const class FString& InDesiredSuffix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetDesiredDeviceProfileQualitySuffix");

	Params::CrGameUserSettings_SetDesiredDeviceProfileQualitySuffix Parms{};

	Parms.InDesiredSuffix = std::move(InDesiredSuffix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetDialogueVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetDialogueVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetDialogueVolume");

	Params::CrGameUserSettings_SetDialogueVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetDisplayGamma
// (Final, Native, Public)
// Parameters:
// float                                   InGamma                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetDisplayGamma(float InGamma)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetDisplayGamma");

	Params::CrGameUserSettings_SetDisplayGamma Parms{};

	Parms.InGamma = InGamma;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetDLSSEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetDLSSEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetDLSSEnabled");

	Params::CrGameUserSettings_SetDLSSEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetDLSSFGEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetDLSSFGEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetDLSSFGEnabled");

	Params::CrGameUserSettings_SetDLSSFGEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetDLSSQuality
// (Final, Native, Public)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetDLSSQuality(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetDLSSQuality");

	Params::CrGameUserSettings_SetDLSSQuality Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetEnableMotionBlur
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetEnableMotionBlur(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetEnableMotionBlur");

	Params::CrGameUserSettings_SetEnableMotionBlur Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetFidelityFXFGEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetFidelityFXFGEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetFidelityFXFGEnabled");

	Params::CrGameUserSettings_SetFidelityFXFGEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetFOV
// (Final, Native, Public)
// Parameters:
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetFOV(float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetFOV");

	Params::CrGameUserSettings_SetFOV Parms{};

	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetFrameGenerationMode
// (Final, Native, Public)
// Parameters:
// ECrFrameGenerationMode                  Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetFrameGenerationMode(ECrFrameGenerationMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetFrameGenerationMode");

	Params::CrGameUserSettings_SetFrameGenerationMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetFrameRateLimit_Always
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetFrameRateLimit_Always(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetFrameRateLimit_Always");

	Params::CrGameUserSettings_SetFrameRateLimit_Always Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetFrameRateLimit_InMenu
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetFrameRateLimit_InMenu(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetFrameRateLimit_InMenu");

	Params::CrGameUserSettings_SetFrameRateLimit_InMenu Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetFrameRateLimit_OnBattery
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetFrameRateLimit_OnBattery(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetFrameRateLimit_OnBattery");

	Params::CrGameUserSettings_SetFrameRateLimit_OnBattery Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetFrameRateLimit_WhenBackgrounded
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetFrameRateLimit_WhenBackgrounded(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetFrameRateLimit_WhenBackgrounded");

	Params::CrGameUserSettings_SetFrameRateLimit_WhenBackgrounded Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetFSREnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetFSREnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetFSREnabled");

	Params::CrGameUserSettings_SetFSREnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetHDRAudioModeEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetHDRAudioModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetHDRAudioModeEnabled");

	Params::CrGameUserSettings_SetHDRAudioModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetHeadphoneModeEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetHeadphoneModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetHeadphoneModeEnabled");

	Params::CrGameUserSettings_SetHeadphoneModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetLandscapeNaniteTessellation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetLandscapeNaniteTessellation(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetLandscapeNaniteTessellation");

	Params::CrGameUserSettings_SetLandscapeNaniteTessellation Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetLandscapeQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetLandscapeQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetLandscapeQuality");

	Params::CrGameUserSettings_SetLandscapeQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetLowLatencyFrameGeneration
// (Final, Native, Public)
// Parameters:
// ECrLowLatencyMode                       Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetLowLatencyFrameGeneration(ECrLowLatencyMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetLowLatencyFrameGeneration");

	Params::CrGameUserSettings_SetLowLatencyFrameGeneration Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetMasterVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetMasterVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetMasterVolume");

	Params::CrGameUserSettings_SetMasterVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetMotionBlurQuality
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetMotionBlurQuality(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetMotionBlurQuality");

	Params::CrGameUserSettings_SetMotionBlurQuality Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetMotionBlurScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetMotionBlurScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetMotionBlurScale");

	Params::CrGameUserSettings_SetMotionBlurScale Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetMusicVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetMusicVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetMusicVolume");

	Params::CrGameUserSettings_SetMusicVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetNVIDIAReflexEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetNVIDIAReflexEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetNVIDIAReflexEnabled");

	Params::CrGameUserSettings_SetNVIDIAReflexEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetSafeZone
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetSafeZone(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetSafeZone");

	Params::CrGameUserSettings_SetSafeZone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetShadingQualityWithFlush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetShadingQualityWithFlush(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetShadingQualityWithFlush");

	Params::CrGameUserSettings_SetShadingQualityWithFlush Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetSoundFXVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetSoundFXVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetSoundFXVolume");

	Params::CrGameUserSettings_SetSoundFXVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetTexturesQualityWithFlush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetTexturesQualityWithFlush(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetTexturesQualityWithFlush");

	Params::CrGameUserSettings_SetTexturesQualityWithFlush Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetUIVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetUIVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetUIVolume");

	Params::CrGameUserSettings_SetUIVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetUpscalingMode
// (Final, Native, Public)
// Parameters:
// ECrUpscalerMode                         Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetUpscalingMode(ECrUpscalerMode Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetUpscalingMode");

	Params::CrGameUserSettings_SetUpscalingMode Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetViewDistanceQualityWithFlush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetViewDistanceQualityWithFlush(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetViewDistanceQualityWithFlush");

	Params::CrGameUserSettings_SetViewDistanceQualityWithFlush Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetVisualEffectQualityWithFlush
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetVisualEffectQualityWithFlush(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetVisualEffectQualityWithFlush");

	Params::CrGameUserSettings_SetVisualEffectQualityWithFlush Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.SetVoiceChatVolume
// (Final, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGameUserSettings::SetVoiceChatVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "SetVoiceChatVolume");

	Params::CrGameUserSettings_SetVoiceChatVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGameUserSettings.CanModifyHeadphoneModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::CanModifyHeadphoneModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "CanModifyHeadphoneModeEnabled");

	Params::CrGameUserSettings_CanModifyHeadphoneModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.CanRunAutoBenchmark
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::CanRunAutoBenchmark() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "CanRunAutoBenchmark");

	Params::CrGameUserSettings_CanRunAutoBenchmark Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetAmbientVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetAmbientVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetAmbientVolume");

	Params::CrGameUserSettings_GetAmbientVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetAntiAliasingMode
// (Final, Native, Public, Const)
// Parameters:
// ECrAntiAliasingMode                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrAntiAliasingMode UCrGameUserSettings::GetAntiAliasingMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetAntiAliasingMode");

	Params::CrGameUserSettings_GetAntiAliasingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetAudioOutputDeviceId
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrGameUserSettings::GetAudioOutputDeviceId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetAudioOutputDeviceId");

	Params::CrGameUserSettings_GetAudioOutputDeviceId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetControllerPlatform
// (Final, Native, Public, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCrGameUserSettings::GetControllerPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetControllerPlatform");

	Params::CrGameUserSettings_GetControllerPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetDesiredDeviceProfileQualitySuffix
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrGameUserSettings::GetDesiredDeviceProfileQualitySuffix() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetDesiredDeviceProfileQualitySuffix");

	Params::CrGameUserSettings_GetDesiredDeviceProfileQualitySuffix Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetDialogueVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetDialogueVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetDialogueVolume");

	Params::CrGameUserSettings_GetDialogueVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetDisplayGamma
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetDisplayGamma() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetDisplayGamma");

	Params::CrGameUserSettings_GetDisplayGamma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetFOV
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetFOV");

	Params::CrGameUserSettings_GetFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetFrameGenerationMode
// (Final, Native, Public, Const)
// Parameters:
// ECrFrameGenerationMode                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrFrameGenerationMode UCrGameUserSettings::GetFrameGenerationMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetFrameGenerationMode");

	Params::CrGameUserSettings_GetFrameGenerationMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetFrameRateLimit_Always
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetFrameRateLimit_Always() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetFrameRateLimit_Always");

	Params::CrGameUserSettings_GetFrameRateLimit_Always Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetFrameRateLimit_InMenu
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetFrameRateLimit_InMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetFrameRateLimit_InMenu");

	Params::CrGameUserSettings_GetFrameRateLimit_InMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetFrameRateLimit_OnBattery
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetFrameRateLimit_OnBattery() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetFrameRateLimit_OnBattery");

	Params::CrGameUserSettings_GetFrameRateLimit_OnBattery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetFrameRateLimit_WhenBackgrounded
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetFrameRateLimit_WhenBackgrounded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetFrameRateLimit_WhenBackgrounded");

	Params::CrGameUserSettings_GetFrameRateLimit_WhenBackgrounded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetLandscapeQuality
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrGameUserSettings::GetLandscapeQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetLandscapeQuality");

	Params::CrGameUserSettings_GetLandscapeQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetLowLatencyFrameGeneration
// (Final, Native, Public, Const)
// Parameters:
// ECrLowLatencyMode                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrLowLatencyMode UCrGameUserSettings::GetLowLatencyFrameGeneration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetLowLatencyFrameGeneration");

	Params::CrGameUserSettings_GetLowLatencyFrameGeneration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetMasterVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetMasterVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetMasterVolume");

	Params::CrGameUserSettings_GetMasterVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetMusicVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetMusicVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetMusicVolume");

	Params::CrGameUserSettings_GetMusicVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetSafeZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetSafeZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetSafeZone");

	Params::CrGameUserSettings_GetSafeZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetSoundFXVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetSoundFXVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetSoundFXVolume");

	Params::CrGameUserSettings_GetSoundFXVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetUIVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetUIVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetUIVolume");

	Params::CrGameUserSettings_GetUIVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetUpscalingMode
// (Final, Native, Public, Const)
// Parameters:
// ECrUpscalerMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrUpscalerMode UCrGameUserSettings::GetUpscalingMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetUpscalingMode");

	Params::CrGameUserSettings_GetUpscalingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.GetVoiceChatVolume
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrGameUserSettings::GetVoiceChatVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "GetVoiceChatVolume");

	Params::CrGameUserSettings_GetVoiceChatVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsHDRAudioModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsHDRAudioModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "IsHDRAudioModeEnabled");

	Params::CrGameUserSettings_IsHDRAudioModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsHeadphoneModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsHeadphoneModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "IsHeadphoneModeEnabled");

	Params::CrGameUserSettings_IsHeadphoneModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsSafeZoneSet
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsSafeZoneSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "IsSafeZoneSet");

	Params::CrGameUserSettings_IsSafeZoneSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.IsSprintToggle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::IsSprintToggle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "IsSprintToggle");

	Params::CrGameUserSettings_IsSprintToggle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGameUserSettings.ShouldRunAutoBenchmarkAtStartup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGameUserSettings::ShouldRunAutoBenchmarkAtStartup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGameUserSettings", "ShouldRunAutoBenchmarkAtStartup");

	Params::CrGameUserSettings_ShouldRunAutoBenchmarkAtStartup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGasOverlapActor.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrGasOverlapActor::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGasOverlapActor", "OnBeginOverlap");

	Params::CrGasOverlapActor_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGasOverlapActor.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGasOverlapActor::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGasOverlapActor", "OnEndOverlap");

	Params::CrGasOverlapActor_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.BP_AddInstancedVisual
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::BP_AddInstancedVisual(class UStaticMeshComponent* InComponent, const struct FTransform& InTransform, class UStaticMesh* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_AddInstancedVisual");

	Params::CrGatherableBaseActor_BP_AddInstancedVisual Parms{};

	Parms.InComponent = InComponent;
	Parms.InTransform = std::move(InTransform);
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.BP_DebugRetriggerInstanceVisualization
// (Event, Public, BlueprintEvent)

void ACrGatherableBaseActor::BP_DebugRetriggerInstanceVisualization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_DebugRetriggerInstanceVisualization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGatherableBaseActor.BP_DebugToggleRegularVisualization
// (Event, Public, BlueprintEvent)

void ACrGatherableBaseActor::BP_DebugToggleRegularVisualization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_DebugToggleRegularVisualization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGatherableBaseActor.BP_DepleteViaBuildingPlacement
// (Final, Native, Public, BlueprintCallable)

void ACrGatherableBaseActor::BP_DepleteViaBuildingPlacement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_DepleteViaBuildingPlacement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.BP_InitializeInstancedVisuals
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UStaticMeshComponent*       InComponent                                            (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::BP_InitializeInstancedVisuals(class UStaticMesh* InMesh, const class UStaticMeshComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_InitializeInstancedVisuals");

	Params::CrGatherableBaseActor_BP_InitializeInstancedVisuals Parms{};

	Parms.InMesh = InMesh;
	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.BP_OnDepletedCosmetics
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   InInteractingActorLocation                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     InInteractingPlayer                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::BP_OnDepletedCosmetics(const struct FVector& InInteractingActorLocation, const class ACrCharacterPlayerBase* InInteractingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_OnDepletedCosmetics");

	Params::CrGatherableBaseActor_BP_OnDepletedCosmetics Parms{};

	Parms.InInteractingActorLocation = std::move(InInteractingActorLocation);
	Parms.InInteractingPlayer = InInteractingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrGatherableBaseActor.BP_OnRemoveInstancedVisualsRequested
// (Event, Protected, BlueprintEvent)

void ACrGatherableBaseActor::BP_OnRemoveInstancedVisualsRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_OnRemoveInstancedVisualsRequested");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGatherableBaseActor.BP_OnVisualInstanceAdded
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FCrGatherableInstancedVisualsData&InVisualData                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::BP_OnVisualInstanceAdded(const struct FCrGatherableInstancedVisualsData& InVisualData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_OnVisualInstanceAdded");

	Params::CrGatherableBaseActor_BP_OnVisualInstanceAdded Parms{};

	Parms.InVisualData = std::move(InVisualData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrGatherableBaseActor.BP_OnWaveChangedUpdate
// (Event, Protected, BlueprintEvent)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              FadeoutSubstage                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             GrowbackSubstage                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::BP_OnWaveChangedUpdate(EEnviroWave WaveType, EEnviroWaveStage WaveStage, EEnviroWaveFadeoutSubstage FadeoutSubstage, EEnviroWaveGrowbackSubstage GrowbackSubstage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_OnWaveChangedUpdate");

	Params::CrGatherableBaseActor_BP_OnWaveChangedUpdate Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.FadeoutSubstage = FadeoutSubstage;
	Parms.GrowbackSubstage = GrowbackSubstage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrGatherableBaseActor.BP_RemoveInstancedVisual
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::BP_RemoveInstancedVisual(class UStaticMeshComponent* InComponent, class UStaticMesh* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_RemoveInstancedVisual");

	Params::CrGatherableBaseActor_BP_RemoveInstancedVisual Parms{};

	Parms.InComponent = InComponent;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.BP_ShowDepletedVisuals
// (Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   InInteractingActorLocation                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::BP_ShowDepletedVisuals(const struct FVector& InInteractingActorLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_ShowDepletedVisuals");

	Params::CrGatherableBaseActor_BP_ShowDepletedVisuals Parms{};

	Parms.InInteractingActorLocation = std::move(InInteractingActorLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrGatherableBaseActor.BP_ShowInitVisuals
// (Event, Protected, BlueprintEvent)

void ACrGatherableBaseActor::BP_ShowInitVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_ShowInitVisuals");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGatherableBaseActor.InitializeInstance
// (Event, Public, BlueprintEvent)

void ACrGatherableBaseActor::InitializeInstance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "InitializeInstance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGatherableBaseActor.IsGameWorld
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrGatherableBaseActor::IsGameWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "IsGameWorld");

	Params::CrGatherableBaseActor_IsGameWorld Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableBaseActor.MulticastOnDepletedCosmetics
// (Net, Native, Event, NetMulticast, Protected, HasDefaults)
// Parameters:
// const struct FVector&                   InInteractingActorLocation                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     InInteractingPlayer                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::MulticastOnDepletedCosmetics(const struct FVector& InInteractingActorLocation, const class ACrCharacterPlayerBase* InInteractingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "MulticastOnDepletedCosmetics");

	Params::CrGatherableBaseActor_MulticastOnDepletedCosmetics Parms{};

	Parms.InInteractingActorLocation = std::move(InInteractingActorLocation);
	Parms.InInteractingPlayer = InInteractingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.OnFadeoutSubstageChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveFadeoutSubstage              Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::OnFadeoutSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveFadeoutSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "OnFadeoutSubstageChanged");

	Params::CrGatherableBaseActor_OnFadeoutSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.OnGrowbackSubstageChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EEnviroWaveGrowbackSubstage             Substage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableBaseActor::OnGrowbackSubstageChanged(const struct FCrEnviroWaveSettings& Settings, EEnviroWaveGrowbackSubstage Substage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "OnGrowbackSubstageChanged");

	Params::CrGatherableBaseActor_OnGrowbackSubstageChanged Parms{};

	Parms.Settings = std::move(Settings);
	Parms.Substage = Substage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.OnRep_Depleted
// (Final, Native, Private)

void ACrGatherableBaseActor::OnRep_Depleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "OnRep_Depleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableBaseActor.BP_GetInstancedVisualizationDataForComponent
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UStaticMeshComponent*             InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCrGatherableInstancedVisualsDataReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FCrGatherableInstancedVisualsData ACrGatherableBaseActor::BP_GetInstancedVisualizationDataForComponent(class UStaticMeshComponent* InComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableBaseActor", "BP_GetInstancedVisualizationDataForComponent");

	Params::CrGatherableBaseActor_BP_GetInstancedVisualizationDataForComponent Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableCropActor.GoDormant
// (Final, Native, Private)

void ACrGatherableCropActor::GoDormant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableCropActor", "GoDormant");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableCropActor.OnBeginPlayShowCropDepletedState
// (Event, Protected, BlueprintEvent)

void ACrGatherableCropActor::OnBeginPlayShowCropDepletedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableCropActor", "OnBeginPlayShowCropDepletedState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGatherableCropActor.OnCropDepletedCosmeticsStart
// (Event, Protected, BlueprintEvent)

void ACrGatherableCropActor::OnCropDepletedCosmeticsStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableCropActor", "OnCropDepletedCosmeticsStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGatherableCropActor.OnCropReplenishedCosmeticsStart
// (Event, Protected, BlueprintEvent)

void ACrGatherableCropActor::OnCropReplenishedCosmeticsStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableCropActor", "OnCropReplenishedCosmeticsStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrGatherableCropActor.OnRep_CropStateDepleted
// (Native, Protected)

void ACrGatherableCropActor::OnRep_CropStateDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableCropActor", "OnRep_CropStateDepleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableCropActor.OnTemperatureStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    bShouldDepleteCrops                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrGatherableCropActor::OnTemperatureStateChanged(bool bShouldDepleteCrops)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableCropActor", "OnTemperatureStateChanged");

	Params::CrGatherableCropActor_OnTemperatureStateChanged Parms{};

	Parms.bShouldDepleteCrops = bShouldDepleteCrops;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassGatherableCropInterface.GatherCropResource
// (Native, Public)
// Parameters:
// struct FCrMinedResource                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCrMinedResource ICrMassGatherableCropInterface::GatherCropResource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassGatherableCropInterface", "GatherCropResource");

	Params::CrMassGatherableCropInterface_GatherCropResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassGatherableCropInterface.OnCropDepleted
// (Native, Public)

void ICrMassGatherableCropInterface::OnCropDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassGatherableCropInterface", "OnCropDepleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassGatherableCropInterface.OnCropReplenished
// (Native, Public)

void ICrMassGatherableCropInterface::OnCropReplenished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassGatherableCropInterface", "OnCropReplenished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassGatherableCropInterface.GetCropResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrItemDataBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrItemDataBase* ICrMassGatherableCropInterface::GetCropResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassGatherableCropInterface", "GetCropResource");

	Params::CrMassGatherableCropInterface_GetCropResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassGatherableCropInterface.GetCurrentCropResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrMassGatherableCropInterface::GetCurrentCropResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassGatherableCropInterface", "GetCurrentCropResourceCount");

	Params::CrMassGatherableCropInterface_GetCurrentCropResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassGatherableCropInterface.GetMaxCropResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrMassGatherableCropInterface::GetMaxCropResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassGatherableCropInterface", "GetMaxCropResourceCount");

	Params::CrMassGatherableCropInterface_GetMaxCropResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassGatherableCropInterface.IsCropDepleted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMassGatherableCropInterface::IsCropDepleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassGatherableCropInterface", "IsCropDepleted");

	Params::CrMassGatherableCropInterface_IsCropDepleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableCropInterface.GatherCropResource
// (Native, Public)
// Parameters:
// struct FCrMinedResource                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCrMinedResource ICrGatherableCropInterface::GatherCropResource()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableCropInterface", "GatherCropResource");

	Params::CrGatherableCropInterface_GatherCropResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableCropInterface.HideCropVisuals
// (Native, Public, BlueprintCallable)

void ICrGatherableCropInterface::HideCropVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableCropInterface", "HideCropVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableCropInterface.OnCropReplenished
// (Native, Public, BlueprintCallable)

void ICrGatherableCropInterface::OnCropReplenished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableCropInterface", "OnCropReplenished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableCropInterface.ShowCropVisuals
// (Native, Public, BlueprintCallable)

void ICrGatherableCropInterface::ShowCropVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableCropInterface", "ShowCropVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableCropInterface.GetCropResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrItemDataBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrItemDataBase* ICrGatherableCropInterface::GetCropResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableCropInterface", "GetCropResource");

	Params::CrGatherableCropInterface_GetCropResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableCropInterface.GetCurrentCropResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrGatherableCropInterface::GetCurrentCropResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableCropInterface", "GetCurrentCropResourceCount");

	Params::CrGatherableCropInterface_GetCurrentCropResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableCropInterface.GetMaxCropResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrGatherableCropInterface::GetMaxCropResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableCropInterface", "GetMaxCropResourceCount");

	Params::CrGatherableCropInterface_GetMaxCropResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableCropInterface.IsCropDepleted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrGatherableCropInterface::IsCropDepleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableCropInterface", "IsCropDepleted");

	Params::CrGatherableCropInterface_IsCropDepleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponModDataAsset.GetAttributesModifiersWithValuesAndDescriptions
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class FText>*                    OutAttributesDescription                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TMap<struct FGameplayAttribute, float>  ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<struct FGameplayAttribute, float> UCrWeaponModDataAsset::GetAttributesModifiersWithValuesAndDescriptions(TArray<class FText>* OutAttributesDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponModDataAsset", "GetAttributesModifiersWithValuesAndDescriptions");

	Params::CrWeaponModDataAsset_GetAttributesModifiersWithValuesAndDescriptions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAttributesDescription != nullptr)
		*OutAttributesDescription = std::move(Parms.OutAttributesDescription);

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableInterface.DepleteResource
// (Native, Public, HasDefaults)
// Parameters:
// const struct FVector&                   InInteractingActorLocation                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     InInteractingPlayer                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCrMinedResource                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCrMinedResource ICrGatherableInterface::DepleteResource(const struct FVector& InInteractingActorLocation, const class ACrCharacterPlayerBase* InInteractingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableInterface", "DepleteResource");

	Params::CrGatherableInterface_DepleteResource Parms{};

	Parms.InInteractingActorLocation = std::move(InInteractingActorLocation);
	Parms.InInteractingPlayer = InInteractingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableInterface.ShowDepletedVisuals
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InInteractingActorLocation                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrGatherableInterface::ShowDepletedVisuals(const struct FVector& InInteractingActorLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableInterface", "ShowDepletedVisuals");

	Params::CrGatherableInterface_ShowDepletedVisuals Parms{};

	Parms.InInteractingActorLocation = std::move(InInteractingActorLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableInterface.ShowInitVisuals
// (Native, Public, BlueprintCallable)

void ICrGatherableInterface::ShowInitVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableInterface", "ShowInitVisuals");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableInterface.GetResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrItemDataBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrItemDataBase* ICrGatherableInterface::GetResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableInterface", "GetResource");

	Params::CrGatherableInterface_GetResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableInterface.GetResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrGatherableInterface::GetResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableInterface", "GetResourceCount");

	Params::CrGatherableInterface_GetResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableInterface.IsDepleted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrGatherableInterface::IsDepleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrGatherableInterface", "IsDepleted");

	Params::CrGatherableInterface_IsDepleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableSpawnersSubsystem.BlockGeneration
// (Final, Native, Public, BlueprintCallable)

void UCrGatherableSpawnersSubsystem::BlockGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "BlockGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersSubsystem.OnEnviroWaveStarted
// (Final, Native, Private, HasOutParams)
// Parameters:
// EEnviroWave                             InWaveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        InWaveStage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     InWaveSettings                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InWaveProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGatherableSpawnersSubsystem::OnEnviroWaveStarted(EEnviroWave InWaveType, EEnviroWaveStage InWaveStage, const struct FCrEnviroWaveSettings& InWaveSettings, float InWaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "OnEnviroWaveStarted");

	Params::CrGatherableSpawnersSubsystem_OnEnviroWaveStarted Parms{};

	Parms.InWaveType = InWaveType;
	Parms.InWaveStage = InWaveStage;
	Parms.InWaveSettings = std::move(InWaveSettings);
	Parms.InWaveProgress = InWaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrGatherableSpawnersSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersSubsystem.RegisterDepletedGatherable
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     InDepletedGatherable                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrGatherableSpawnersSubsystem::RegisterDepletedGatherable(const class AActor* InDepletedGatherable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "RegisterDepletedGatherable");

	Params::CrGatherableSpawnersSubsystem_RegisterDepletedGatherable Parms{};

	Parms.InDepletedGatherable = InDepletedGatherable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersSubsystem.ToggleGenerationEnabled
// (Final, Native, Public, BlueprintCallable)

void UCrGatherableSpawnersSubsystem::ToggleGenerationEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "ToggleGenerationEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersSubsystem.TriggerGenerationWithCurrentSeed
// (Final, Native, Public, BlueprintCallable)

void UCrGatherableSpawnersSubsystem::TriggerGenerationWithCurrentSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "TriggerGenerationWithCurrentSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersSubsystem.TryLoading
// (Final, Native, Public)

void UCrGatherableSpawnersSubsystem::TryLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "TryLoading");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersSubsystem.UnblockGeneration
// (Final, Native, Public, BlueprintCallable)

void UCrGatherableSpawnersSubsystem::UnblockGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "UnblockGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGatherableSpawnersSubsystem.BP_DidSpawnBoxAlreadyGeneratedEntities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     InSpawnBoxActor                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGatherableSpawnersSubsystem::BP_DidSpawnBoxAlreadyGeneratedEntities(const class AActor* InSpawnBoxActor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "BP_DidSpawnBoxAlreadyGeneratedEntities");

	Params::CrGatherableSpawnersSubsystem_BP_DidSpawnBoxAlreadyGeneratedEntities Parms{};

	Parms.InSpawnBoxActor = InSpawnBoxActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableSpawnersSubsystem.BP_IsGatherableDepleted
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class AActor*                     InGatherable                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGatherableSpawnersSubsystem::BP_IsGatherableDepleted(const class AActor* InGatherable) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "BP_IsGatherableDepleted");

	Params::CrGatherableSpawnersSubsystem_BP_IsGatherableDepleted Parms{};

	Parms.InGatherable = InGatherable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGatherableSpawnersSubsystem.IsGenerationEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrGatherableSpawnersSubsystem::IsGenerationEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGatherableSpawnersSubsystem", "IsGenerationEnabled");

	Params::CrGatherableSpawnersSubsystem_IsGenerationEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGemAttributeSet.OnRep_CaloriesLossMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCaloriesLossMultiplier                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_CaloriesLossMultiplier(const struct FGameplayAttributeData& OldCaloriesLossMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_CaloriesLossMultiplier");

	Params::CrGemAttributeSet_OnRep_CaloriesLossMultiplier Parms{};

	Parms.OldCaloriesLossMultiplier = std::move(OldCaloriesLossMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_ConsumableStatsMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldConsumableStatsMultiplier                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_ConsumableStatsMultiplier(const struct FGameplayAttributeData& OldConsumableStatsMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_ConsumableStatsMultiplier");

	Params::CrGemAttributeSet_OnRep_ConsumableStatsMultiplier Parms{};

	Parms.OldConsumableStatsMultiplier = std::move(OldConsumableStatsMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_ConsumableToxicityMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldConsumableToxicityMultiplier                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_ConsumableToxicityMultiplier(const struct FGameplayAttributeData& OldConsumableToxicityMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_ConsumableToxicityMultiplier");

	Params::CrGemAttributeSet_OnRep_ConsumableToxicityMultiplier Parms{};

	Parms.OldConsumableToxicityMultiplier = std::move(OldConsumableToxicityMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_DodgeCostMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldDodgeCostMultiplier                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_DodgeCostMultiplier(const struct FGameplayAttributeData& OldDodgeCostMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_DodgeCostMultiplier");

	Params::CrGemAttributeSet_OnRep_DodgeCostMultiplier Parms{};

	Parms.OldDodgeCostMultiplier = std::move(OldDodgeCostMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_DoubleJumpCostMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldDoubleJumpCostMultiplier                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_DoubleJumpCostMultiplier(const struct FGameplayAttributeData& OldDoubleJumpCostMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_DoubleJumpCostMultiplier");

	Params::CrGemAttributeSet_OnRep_DoubleJumpCostMultiplier Parms{};

	Parms.OldDoubleJumpCostMultiplier = std::move(OldDoubleJumpCostMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_EnemyDropChanceMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldEnemyDropChanceMultiplier                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_EnemyDropChanceMultiplier(const struct FGameplayAttributeData& OldEnemyDropChanceMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_EnemyDropChanceMultiplier");

	Params::CrGemAttributeSet_OnRep_EnemyDropChanceMultiplier Parms{};

	Parms.OldEnemyDropChanceMultiplier = std::move(OldEnemyDropChanceMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_FallDamageMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldFallDamageMultiplier                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_FallDamageMultiplier(const struct FGameplayAttributeData& OldFallDamageMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_FallDamageMultiplier");

	Params::CrGemAttributeSet_OnRep_FallDamageMultiplier Parms{};

	Parms.OldFallDamageMultiplier = std::move(OldFallDamageMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_FogOfWarRadiusMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldFogOfWarRadiusMultiplier                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_FogOfWarRadiusMultiplier(const struct FGameplayAttributeData& OldFogOfWarRadiusMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_FogOfWarRadiusMultiplier");

	Params::CrGemAttributeSet_OnRep_FogOfWarRadiusMultiplier Parms{};

	Parms.OldFogOfWarRadiusMultiplier = std::move(OldFogOfWarRadiusMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_FriendlyFireMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldFriendlyFireMultiplier                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_FriendlyFireMultiplier(const struct FGameplayAttributeData& OldFriendlyFireMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_FriendlyFireMultiplier");

	Params::CrGemAttributeSet_OnRep_FriendlyFireMultiplier Parms{};

	Parms.OldFriendlyFireMultiplier = std::move(OldFriendlyFireMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_HarvesterMiningDamageMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldHarvesterMiningDamageMultiplier                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_HarvesterMiningDamageMultiplier(const struct FGameplayAttributeData& OldHarvesterMiningDamageMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_HarvesterMiningDamageMultiplier");

	Params::CrGemAttributeSet_OnRep_HarvesterMiningDamageMultiplier Parms{};

	Parms.OldHarvesterMiningDamageMultiplier = std::move(OldHarvesterMiningDamageMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_HydrationLossMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldHydrationLossMultiplier                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_HydrationLossMultiplier(const struct FGameplayAttributeData& OldHydrationLossMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_HydrationLossMultiplier");

	Params::CrGemAttributeSet_OnRep_HydrationLossMultiplier Parms{};

	Parms.OldHydrationLossMultiplier = std::move(OldHydrationLossMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_InfectionGainMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldInfectionGainMultiplier                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_InfectionGainMultiplier(const struct FGameplayAttributeData& OldInfectionGainMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_InfectionGainMultiplier");

	Params::CrGemAttributeSet_OnRep_InfectionGainMultiplier Parms{};

	Parms.OldInfectionGainMultiplier = std::move(OldInfectionGainMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_NegativeStatsGainMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldNegativeStatsGainMultiplier                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_NegativeStatsGainMultiplier(const struct FGameplayAttributeData& OldNegativeStatsGainMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_NegativeStatsGainMultiplier");

	Params::CrGemAttributeSet_OnRep_NegativeStatsGainMultiplier Parms{};

	Parms.OldNegativeStatsGainMultiplier = std::move(OldNegativeStatsGainMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_ReviveDurationMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldReviveDurationMultiplier                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_ReviveDurationMultiplier(const struct FGameplayAttributeData& OldReviveDurationMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_ReviveDurationMultiplier");

	Params::CrGemAttributeSet_OnRep_ReviveDurationMultiplier Parms{};

	Parms.OldReviveDurationMultiplier = std::move(OldReviveDurationMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_ShieldRechargeCooldownMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldShieldRechargeCooldownMultiplier                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_ShieldRechargeCooldownMultiplier(const struct FGameplayAttributeData& OldShieldRechargeCooldownMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_ShieldRechargeCooldownMultiplier");

	Params::CrGemAttributeSet_OnRep_ShieldRechargeCooldownMultiplier Parms{};

	Parms.OldShieldRechargeCooldownMultiplier = std::move(OldShieldRechargeCooldownMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_SlideStaminaRegenMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldSlideStaminaRegenMultiplier                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_SlideStaminaRegenMultiplier(const struct FGameplayAttributeData& OldSlideStaminaRegenMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_SlideStaminaRegenMultiplier");

	Params::CrGemAttributeSet_OnRep_SlideStaminaRegenMultiplier Parms{};

	Parms.OldSlideStaminaRegenMultiplier = std::move(OldSlideStaminaRegenMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_StaminaRegenMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldStaminaRegenMultiplier                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_StaminaRegenMultiplier(const struct FGameplayAttributeData& OldStaminaRegenMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_StaminaRegenMultiplier");

	Params::CrGemAttributeSet_OnRep_StaminaRegenMultiplier Parms{};

	Parms.OldStaminaRegenMultiplier = std::move(OldStaminaRegenMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_WeaponADSSpeedMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldWeaponADSSpeedMultiplier                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_WeaponADSSpeedMultiplier(const struct FGameplayAttributeData& OldWeaponADSSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_WeaponADSSpeedMultiplier");

	Params::CrGemAttributeSet_OnRep_WeaponADSSpeedMultiplier Parms{};

	Parms.OldWeaponADSSpeedMultiplier = std::move(OldWeaponADSSpeedMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_WeaponReloadSpeedMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldWeaponReloadSpeedMultiplier                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_WeaponReloadSpeedMultiplier(const struct FGameplayAttributeData& OldWeaponReloadSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_WeaponReloadSpeedMultiplier");

	Params::CrGemAttributeSet_OnRep_WeaponReloadSpeedMultiplier Parms{};

	Parms.OldWeaponReloadSpeedMultiplier = std::move(OldWeaponReloadSpeedMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_WeaponSwapSpeedMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldWeaponSwapSpeedMultiplier                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_WeaponSwapSpeedMultiplier(const struct FGameplayAttributeData& OldWeaponSwapSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_WeaponSwapSpeedMultiplier");

	Params::CrGemAttributeSet_OnRep_WeaponSwapSpeedMultiplier Parms{};

	Parms.OldWeaponSwapSpeedMultiplier = std::move(OldWeaponSwapSpeedMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrGemAttributeSet.OnRep_ZiplineSpeedMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldZiplineSpeedMultiplier                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrGemAttributeSet::OnRep_ZiplineSpeedMultiplier(const struct FGameplayAttributeData& OldZiplineSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGemAttributeSet", "OnRep_ZiplineSpeedMultiplier");

	Params::CrGemAttributeSet_OnRep_ZiplineSpeedMultiplier Parms{};

	Parms.OldZiplineSpeedMultiplier = std::move(OldZiplineSpeedMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrAiActionFloat.Create_CrAiActionFloat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionFloat>     ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewInputVariable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionFloat*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionFloat* UCrAiActionFloat::Create_CrAiActionFloat(TSubclassOf<class UCrAiActionFloat> ActionType, float NewMaxLifetimeS, float NewInputVariable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionFloat", "Create_CrAiActionFloat");

	Params::CrAiActionFloat_Create_CrAiActionFloat Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewInputVariable = NewInputVariable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrGlassDecalActorBase.GetGlassPlaneMutable
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UStaticMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMeshComponent* ACrGlassDecalActorBase::GetGlassPlaneMutable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrGlassDecalActorBase", "GetGlassPlaneMutable");

	Params::CrGlassDecalActorBase_GetGlassPlaneMutable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrHeatAttributeSet.OnRep_CurrentHeat
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentHeat                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHeatAttributeSet::OnRep_CurrentHeat(const struct FGameplayAttributeData& OldCurrentHeat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHeatAttributeSet", "OnRep_CurrentHeat");

	Params::CrHeatAttributeSet_OnRep_CurrentHeat Parms{};

	Parms.OldCurrentHeat = std::move(OldCurrentHeat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHeatAttributeSet.OnRep_MaxHeat
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxHeat                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHeatAttributeSet::OnRep_MaxHeat(const struct FGameplayAttributeData& OldMaxHeat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHeatAttributeSet", "OnRep_MaxHeat");

	Params::CrHeatAttributeSet_OnRep_MaxHeat Parms{};

	Parms.OldMaxHeat = std::move(OldMaxHeat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHeatAttributeSet.OnRep_MinHeat
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinHeat                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrHeatAttributeSet::OnRep_MinHeat(const struct FGameplayAttributeData& OldMinHeat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHeatAttributeSet", "OnRep_MinHeat");

	Params::CrHeatAttributeSet_OnRep_MinHeat Parms{};

	Parms.OldMinHeat = std::move(OldMinHeat);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHintsSubsystem.OnContextualEventExecuted
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContextValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrHintsSubsystem::OnContextualEventExecuted(class AActor* Target, class FName Context, class FName ContextValue, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHintsSubsystem", "OnContextualEventExecuted");

	Params::CrHintsSubsystem_OnContextualEventExecuted Parms{};

	Parms.Target = Target;
	Parms.Context = Context;
	Parms.ContextValue = ContextValue;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionActor.OnRep_WasDestroyed
// (Final, Native, Public)

void ACrInfectionActor::OnRep_WasDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionActor", "OnRep_WasDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionActor.ResetGuid
// (Final, Native, Public, BlueprintCallable)

void ACrInfectionActor::ResetGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionActor", "ResetGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionActor.UpdateDestroyedStateVisuals
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bWasLoaded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInfectionActor::UpdateDestroyedStateVisuals(bool bWasLoaded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionActor", "UpdateDestroyedStateVisuals");

	Params::CrInfectionActor_UpdateDestroyedStateVisuals Parms{};

	Parms.bWasLoaded = bWasLoaded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInfectionActor.GetGuid
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid ACrInfectionActor::GetGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInfectionActor", "GetGuid");

	Params::CrInfectionActor_GetGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInputActionGroupMappingDataAsset.GetOtherActionMappingsFromGroup
// (Final, Native, Public, HasOutParams, Const)
// Parameters:
// const class FName&                      InActionMappingName                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCrInputActionGroupMappingDataAsset::GetOtherActionMappingsFromGroup(const class FName& InActionMappingName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInputActionGroupMappingDataAsset", "GetOtherActionMappingsFromGroup");

	Params::CrInputActionGroupMappingDataAsset_GetOtherActionMappingsFromGroup Parms{};

	Parms.InActionMappingName = InActionMappingName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrNativeInputBPHandler.BP_InputCompleted
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FInputActionValue&         InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrNativeInputBPHandler::BP_InputCompleted(const struct FInputActionValue& InputActionValue, class APawn* InPawn, const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrNativeInputBPHandler", "BP_InputCompleted");

	Params::CrNativeInputBPHandler_BP_InputCompleted Parms{};

	Parms.InputActionValue = std::move(InputActionValue);
	Parms.InPawn = InPawn;
	Parms.InputTag = std::move(InputTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrNativeInputBPHandler.BP_InputPressed
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FInputActionValue&         InputActionValue                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrNativeInputBPHandler::BP_InputPressed(const struct FInputActionValue& InputActionValue, class APawn* InPawn, const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrNativeInputBPHandler", "BP_InputPressed");

	Params::CrNativeInputBPHandler_BP_InputPressed Parms{};

	Parms.InputActionValue = std::move(InputActionValue);
	Parms.InPawn = InPawn;
	Parms.InputTag = std::move(InputTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.SharedQuestItemsFunctionLibrary.AddItemToSharedQuestList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAuItemDataBase>      Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsFunctionLibrary::AddItemToSharedQuestList(class UObject* WorldContext, TSubclassOf<class UAuItemDataBase> Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "AddItemToSharedQuestList");

	Params::SharedQuestItemsFunctionLibrary_AddItemToSharedQuestList Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.DoPlayerOwnQuestItem
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAuItemDataBase>      Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsFunctionLibrary::DoPlayerOwnQuestItem(class UObject* WorldContext, TSubclassOf<class UAuItemDataBase> Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "DoPlayerOwnQuestItem");

	Params::SharedQuestItemsFunctionLibrary_DoPlayerOwnQuestItem Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.GetAllAvailableMods
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSoftObjectPtr<class UCrWeaponModDataAsset>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UCrWeaponModDataAsset>> USharedQuestItemsFunctionLibrary::GetAllAvailableMods(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "GetAllAvailableMods");

	Params::SharedQuestItemsFunctionLibrary_GetAllAvailableMods Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.GetSharedQuestItems
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<TSubclassOf<class UAuItemDataBase>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class UAuItemDataBase>> USharedQuestItemsFunctionLibrary::GetSharedQuestItems(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "GetSharedQuestItems");

	Params::SharedQuestItemsFunctionLibrary_GetSharedQuestItems Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.GetSharedQuestItemsComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USharedQuestItemsListComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USharedQuestItemsListComponent* USharedQuestItemsFunctionLibrary::GetSharedQuestItemsComponent(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "GetSharedQuestItemsComponent");

	Params::SharedQuestItemsFunctionLibrary_GetSharedQuestItemsComponent Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.GetSharedQuestItemsMap
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<TSubclassOf<class UAuItemDataBase>, int32>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<TSubclassOf<class UAuItemDataBase>, int32> USharedQuestItemsFunctionLibrary::GetSharedQuestItemsMap(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "GetSharedQuestItemsMap");

	Params::SharedQuestItemsFunctionLibrary_GetSharedQuestItemsMap Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.IsWeaponModUnlocked
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UCrWeaponModDataAsset>ModObject                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsFunctionLibrary::IsWeaponModUnlocked(class UObject* WorldContext, TSoftObjectPtr<class UCrWeaponModDataAsset> ModObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "IsWeaponModUnlocked");

	Params::SharedQuestItemsFunctionLibrary_IsWeaponModUnlocked Parms{};

	Parms.WorldContext = WorldContext;
	Parms.ModObject = ModObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.OnPickableTaken
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AAuItemPickupBase*                Pickable                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USharedQuestItemsFunctionLibrary::OnPickableTaken(class AAuItemPickupBase* Pickable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "OnPickableTaken");

	Params::SharedQuestItemsFunctionLibrary_OnPickableTaken Parms{};

	Parms.Pickable = Pickable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.RemoveItemFromSharedQuestList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAuItemDataBase>      Item                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsFunctionLibrary::RemoveItemFromSharedQuestList(class UObject* WorldContext, TSubclassOf<class UAuItemDataBase> Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "RemoveItemFromSharedQuestList");

	Params::SharedQuestItemsFunctionLibrary_RemoveItemFromSharedQuestList Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.SharedQuestItemsFunctionLibrary.WasPickableTaken
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AAuItemPickupBase*                Pickable                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USharedQuestItemsFunctionLibrary::WasPickableTaken(class AAuItemPickupBase* Pickable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SharedQuestItemsFunctionLibrary", "WasPickableTaken");

	Params::SharedQuestItemsFunctionLibrary_WasPickableTaken Parms{};

	Parms.Pickable = Pickable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.ApplyCameraGameplayEffect
// (Final, Native, Public)
// Parameters:
// class UGameplayEffect*                  CamGE                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ApplyCameraGameplayEffect(class UGameplayEffect* CamGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ApplyCameraGameplayEffect");

	Params::CrPlayerControllerBase_ApplyCameraGameplayEffect Parms{};

	Parms.CamGE = CamGE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.BlockGameMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    Caller                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::BlockGameMenu(const class UObject* Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "BlockGameMenu");

	Params::CrPlayerControllerBase_BlockGameMenu Parms{};

	Parms.Caller = Caller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.BP_GetBuildingComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCrBuildingComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrBuildingComponent* ACrPlayerControllerBase::BP_GetBuildingComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "BP_GetBuildingComponent");

	Params::CrPlayerControllerBase_BP_GetBuildingComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.CancelPlacement
// (Native, Public, BlueprintCallable)

void ACrPlayerControllerBase::CancelPlacement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CancelPlacement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.CanInputKeyBePassedFromUIOnlyMode
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrPlayerControllerBase::CanInputKeyBePassedFromUIOnlyMode(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CanInputKeyBePassedFromUIOnlyMode");

	Params::CrPlayerControllerBase_CanInputKeyBePassedFromUIOnlyMode Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.CheatApplyGameplayEffect
// (Final, Native, Public)
// Parameters:
// class UGameplayEffect*                  GE                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::CheatApplyGameplayEffect(class UGameplayEffect* GE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CheatApplyGameplayEffect");

	Params::CrPlayerControllerBase_CheatApplyGameplayEffect Parms{};

	Parms.GE = GE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.CheatApplyGameplayEffectServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UGameplayEffect*                  GE                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::CheatApplyGameplayEffectServer(class UGameplayEffect* GE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CheatApplyGameplayEffectServer");

	Params::CrPlayerControllerBase_CheatApplyGameplayEffectServer Parms{};

	Parms.GE = GE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.CheatApplyGameplayEffectSetByCaller
// (Final, Native, Public)
// Parameters:
// class UGameplayEffect*                  GE                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Magnitude                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::CheatApplyGameplayEffectSetByCaller(class UGameplayEffect* GE, const float Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CheatApplyGameplayEffectSetByCaller");

	Params::CrPlayerControllerBase_CheatApplyGameplayEffectSetByCaller Parms{};

	Parms.GE = GE;
	Parms.Magnitude = Magnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.CheatApplyGameplayEffectSetByCallerServer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UGameplayEffect*                  GE                                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             Magnitude                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::CheatApplyGameplayEffectSetByCallerServer(class UGameplayEffect* GE, const float Magnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CheatApplyGameplayEffectSetByCallerServer");

	Params::CrPlayerControllerBase_CheatApplyGameplayEffectSetByCallerServer Parms{};

	Parms.GE = GE;
	Parms.Magnitude = Magnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.CheatGiveDefaultWeapons
// (Final, Native, Public, BlueprintCallable)

void ACrPlayerControllerBase::CheatGiveDefaultWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CheatGiveDefaultWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.CheatGiveItem
// (Final, Native, Public)
// Parameters:
// class UAuItemDataBase*                  ItemType                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::CheatGiveItem(class UAuItemDataBase* ItemType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CheatGiveItem");

	Params::CrPlayerControllerBase_CheatGiveItem Parms{};

	Parms.ItemType = ItemType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerCaloriesChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerCaloriesChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerCaloriesChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerCaloriesChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerCorrosionChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerCorrosionChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerCorrosionChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerCorrosionChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerDrainChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerDrainChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerDrainChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerDrainChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerEnergyChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerEnergyChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerEnergyChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerEnergyChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerHealthChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerHealthChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerHealthChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerHealthChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerHeatChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerHeatChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerHeatChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerHeatChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerHydrationChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerHydrationChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerHydrationChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerHydrationChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerInfectionChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerInfectionChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerInfectionChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerInfectionChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerMiningProgressChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             DamageNeededToGrantResource                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewGrantingResourceDamageThreshold                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharThatMines                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerMiningProgressChanged(const float DamageNeededToGrantResource, const float NewGrantingResourceDamageThreshold, const class ACrCharacterPlayerBase* CharThatMines)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerMiningProgressChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerMiningProgressChanged Parms{};

	Parms.DamageNeededToGrantResource = DamageNeededToGrantResource;
	Parms.NewGrantingResourceDamageThreshold = NewGrantingResourceDamageThreshold;
	Parms.CharThatMines = CharThatMines;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerMovementSpeedMultiplierChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerMovementSpeedMultiplierChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerMovementSpeedMultiplierChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerMovementSpeedMultiplierChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerOxygenChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerOxygenChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerOxygenChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerOxygenChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerRadiationChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerRadiationChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerRadiationChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerRadiationChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerShieldChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerShieldChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerShieldChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerShieldChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerTemperatureChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerTemperatureChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerTemperatureChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerTemperatureChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPlayerToxicityChanged
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const float                             NewCurrentValue                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMaxValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             NewMinValue                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             OldValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class ACrCharacterPlayerBase*     CharWithChange                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPlayerToxicityChanged(const float NewCurrentValue, const float NewMaxValue, const float NewMinValue, const float OldValue, const class ACrCharacterPlayerBase* CharWithChange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPlayerToxicityChanged");

	Params::CrPlayerControllerBase_ClientBroadcastOnPlayerToxicityChanged Parms{};

	Parms.NewCurrentValue = NewCurrentValue;
	Parms.NewMaxValue = NewMaxValue;
	Parms.NewMinValue = NewMinValue;
	Parms.OldValue = OldValue;
	Parms.CharWithChange = CharWithChange;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnPossessedDelegate
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APawn*                            PossessedPawn                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnPossessedDelegate(class APawn* PossessedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnPossessedDelegate");

	Params::CrPlayerControllerBase_ClientBroadcastOnPossessedDelegate Parms{};

	Parms.PossessedPawn = PossessedPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientBroadcastOnUnpossessedDelegate
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class APawn*                            UnpossessedPawn                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientBroadcastOnUnpossessedDelegate(class APawn* UnpossessedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientBroadcastOnUnpossessedDelegate");

	Params::CrPlayerControllerBase_ClientBroadcastOnUnpossessedDelegate Parms{};

	Parms.UnpossessedPawn = UnpossessedPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientEndPlacementMode
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACrPlayerControllerBase::ClientEndPlacementMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientEndPlacementMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientInitializeEnviroWave
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   WaveProgress                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientInitializeEnviroWave(EEnviroWave WaveType, EEnviroWaveStage WaveStage, const struct FCrEnviroWaveSettings& WaveSettings, float WaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientInitializeEnviroWave");

	Params::CrPlayerControllerBase_ClientInitializeEnviroWave Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.WaveSettings = std::move(WaveSettings);
	Parms.WaveProgress = WaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientOnDamageRecieved
// (Net, NetReliable, Native, Event, Public, HasDefaults, NetClient)
// Parameters:
// const struct FVector&                   InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrHitReactionType                      InHitReactionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientOnDamageRecieved(const struct FVector& InDirection, ECrHitReactionType InHitReactionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientOnDamageRecieved");

	Params::CrPlayerControllerBase_ClientOnDamageRecieved Parms{};

	Parms.InDirection = std::move(InDirection);
	Parms.InHitReactionType = InHitReactionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientOnDied
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigtor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientOnDied(class ACrCharacterPlayerBase* InPlayer, class AActor* InInstigtor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientOnDied");

	Params::CrPlayerControllerBase_ClientOnDied Parms{};

	Parms.InPlayer = InPlayer;
	Parms.InInstigtor = InInstigtor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientOnFlowSubsystemInitialized
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACrPlayerControllerBase::ClientOnFlowSubsystemInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientOnFlowSubsystemInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientOnHintContextualEventExecuted
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FName                             ContextName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContextValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EventContextValueNumber                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientOnHintContextualEventExecuted(class FName ContextName, class FName ContextValue, int32 EventContextValueNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientOnHintContextualEventExecuted");

	Params::CrPlayerControllerBase_ClientOnHintContextualEventExecuted Parms{};

	Parms.ContextName = ContextName;
	Parms.ContextValue = ContextValue;
	Parms.EventContextValueNumber = EventContextValueNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientOnIncapacitated
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InInstigtor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientOnIncapacitated(class ACrCharacterPlayerBase* InPlayer, class AActor* InInstigtor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientOnIncapacitated");

	Params::CrPlayerControllerBase_ClientOnIncapacitated Parms{};

	Parms.InPlayer = InPlayer;
	Parms.InInstigtor = InInstigtor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientOnInteractionWithBuildingCompleted
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EBuildingManualInteraction              Interaction                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientOnInteractionWithBuildingCompleted(EBuildingManualInteraction Interaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientOnInteractionWithBuildingCompleted");

	Params::CrPlayerControllerBase_ClientOnInteractionWithBuildingCompleted Parms{};

	Parms.Interaction = Interaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientReceiveBuildingCustomName
// (Net, Native, Event, Public, NetClient)
// Parameters:
// const struct FCrMassEntityReplicationHelper&Building                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsDefaultName                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    CustomName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientReceiveBuildingCustomName(const struct FCrMassEntityReplicationHelper& Building, bool bIsDefaultName, const class FString& CustomName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientReceiveBuildingCustomName");

	Params::CrPlayerControllerBase_ClientReceiveBuildingCustomName Parms{};

	Parms.Building = std::move(Building);
	Parms.bIsDefaultName = bIsDefaultName;
	Parms.CustomName = std::move(CustomName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientSaveStringToTxt
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// const class FString&                    InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Path                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientSaveStringToTxt(const class FString& InString, const class FString& Path)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientSaveStringToTxt");

	Params::CrPlayerControllerBase_ClientSaveStringToTxt Parms{};

	Parms.InString = std::move(InString);
	Parms.Path = std::move(Path);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ClientStartBuilding
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class UAuActorPlacementData*            InPlacementData                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrBuildingBeginPlayData&  BeginPlayData                                          (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ClientStartBuilding(class UAuActorPlacementData* InPlacementData, const struct FCrBuildingBeginPlayData& BeginPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ClientStartBuilding");

	Params::CrPlayerControllerBase_ClientStartBuilding Parms{};

	Parms.InPlacementData = InPlacementData;
	Parms.BeginPlayData = std::move(BeginPlayData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugAddItems
// (Final, Native, Public, HasOutParams)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UCrItemDataBase*>*         OutItems                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DebugAddItems(const class FString& Name_0, int32 Amount, TArray<class UCrItemDataBase*>* OutItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugAddItems");

	Params::CrPlayerControllerBase_DebugAddItems Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutItems != nullptr)
		*OutItems = std::move(Parms.OutItems);
}


// Function Chimera.CrPlayerControllerBase.DebugDestroyAllItems
// (Final, Native, Public)

void ACrPlayerControllerBase::DebugDestroyAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugDestroyAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugKillAllEnemies
// (Final, Native, Public, BlueprintCallable)

void ACrPlayerControllerBase::DebugKillAllEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugKillAllEnemies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugRemoveItems
// (Final, Native, Public)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DebugRemoveItems(const class FString& Name_0, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugRemoveItems");

	Params::CrPlayerControllerBase_DebugRemoveItems Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugSetSurvivalAttribute
// (Final, Native, Public)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DebugSetSurvivalAttribute(const class FString& Name_0, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugSetSurvivalAttribute");

	Params::CrPlayerControllerBase_DebugSetSurvivalAttribute Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugSetUnlockedInventorySlots
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InUnlockedInventorySlots                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DebugSetUnlockedInventorySlots(int32 InUnlockedInventorySlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugSetUnlockedInventorySlots");

	Params::CrPlayerControllerBase_DebugSetUnlockedInventorySlots Parms{};

	Parms.InUnlockedInventorySlots = InUnlockedInventorySlots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugSpawnActor
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DebugSpawnActor(class UClass* Class_0, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugSpawnActor");

	Params::CrPlayerControllerBase_DebugSpawnActor Parms{};

	Parms.Class_0 = Class_0;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugTeleportPlayerToCamera
// (Final, Native, Public)

void ACrPlayerControllerBase::DebugTeleportPlayerToCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugTeleportPlayerToCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugUnlockAllFeatures
// (Final, Native, Public, BlueprintCallable)

void ACrPlayerControllerBase::DebugUnlockAllFeatures()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugUnlockAllFeatures");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DebugUnlockFeature
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrCorporationUnlockedFeatures          InFeature                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DebugUnlockFeature(ECrCorporationUnlockedFeatures InFeature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DebugUnlockFeature");

	Params::CrPlayerControllerBase_DebugUnlockFeature Parms{};

	Parms.InFeature = InFeature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DedicatedServerConsoleCommand
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWriteToLog                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DedicatedServerConsoleCommand(const class FString& Command, bool bWriteToLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DedicatedServerConsoleCommand");

	Params::CrPlayerControllerBase_DedicatedServerConsoleCommand Parms{};

	Parms.Command = std::move(Command);
	Parms.bWriteToLog = bWriteToLog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DestructBuilding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Building                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DestructBuilding(class AActor* Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DestructBuilding");

	Params::CrPlayerControllerBase_DestructBuilding Parms{};

	Parms.Building = Building;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.DestructBuildingConditional
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Building                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::DestructBuildingConditional(class AActor* Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "DestructBuildingConditional");

	Params::CrPlayerControllerBase_DestructBuildingConditional Parms{};

	Parms.Building = Building;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.GetBuildingStatus
// (Final, Native, Public)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACrPlayerControllerBase::GetBuildingStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "GetBuildingStatus");

	Params::CrPlayerControllerBase_GetBuildingStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.GetDeconstructionTime
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrPlayerControllerBase::GetDeconstructionTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "GetDeconstructionTime");

	Params::CrPlayerControllerBase_GetDeconstructionTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.HandleSkillLevelChanged
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCrSkillData*                    InSkill                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::HandleSkillLevelChanged(struct FCrSkillData* InSkill, int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "HandleSkillLevelChanged");

	Params::CrPlayerControllerBase_HandleSkillLevelChanged Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (InSkill != nullptr)
		*InSkill = std::move(Parms.InSkill);
}


// Function Chimera.CrPlayerControllerBase.HandleWaveCheckSurvivals
// (Final, Native, Public)
// Parameters:
// bool                                    bWaveFinished                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::HandleWaveCheckSurvivals(bool bWaveFinished)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "HandleWaveCheckSurvivals");

	Params::CrPlayerControllerBase_HandleWaveCheckSurvivals Parms{};

	Parms.bWaveFinished = bWaveFinished;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.InputConfirmPlacement
// (Native, Public, BlueprintCallable)

void ACrPlayerControllerBase::InputConfirmPlacement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "InputConfirmPlacement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.K2_ShowProfessionMenu
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrPlayerControllerBase::K2_ShowProfessionMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "K2_ShowProfessionMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.MulticastCancelZiplineMode
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrPlayerControllerBase::MulticastCancelZiplineMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "MulticastCancelZiplineMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.MulticastOnPlayerRespawned
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::MulticastOnPlayerRespawned(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "MulticastOnPlayerRespawned");

	Params::CrPlayerControllerBase_MulticastOnPlayerRespawned Parms{};

	Parms.InPlayer = InPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.MulticastStartZiplineMode
// (Net, NetReliable, Native, Event, NetMulticast, Public)
// Parameters:
// const struct FCrMassActorReplicationHelper&CurrentZiplinePoint                                    (Parm, NativeAccessSpecifierPublic)
// bool                                    bJustTravelled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::MulticastStartZiplineMode(const struct FCrMassActorReplicationHelper& CurrentZiplinePoint, bool bJustTravelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "MulticastStartZiplineMode");

	Params::CrPlayerControllerBase_MulticastStartZiplineMode Parms{};

	Parms.CurrentZiplinePoint = std::move(CurrentZiplinePoint);
	Parms.bJustTravelled = bJustTravelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.MulticastSwitchToNextZipline
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrPlayerControllerBase::MulticastSwitchToNextZipline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "MulticastSwitchToNextZipline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.MulticastSwitchToPreviousZipline
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrPlayerControllerBase::MulticastSwitchToPreviousZipline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "MulticastSwitchToPreviousZipline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.NativeOnInputInteractCompleted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrPlayerControllerBase::NativeOnInputInteractCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "NativeOnInputInteractCompleted");

	Params::CrPlayerControllerBase_NativeOnInputInteractCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.OnDeconstructionEnd
// (Final, Native, Public, BlueprintCallable)

void ACrPlayerControllerBase::OnDeconstructionEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "OnDeconstructionEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.OnDeconstructionStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrBuildingActorBase*             InBuilding                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::OnDeconstructionStart(class ACrBuildingActorBase* InBuilding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "OnDeconstructionStart");

	Params::CrPlayerControllerBase_OnDeconstructionStart Parms{};

	Parms.InBuilding = InBuilding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.OnDeconstructionSuccess
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrBuildingActorBase*             InBuilding                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::OnDeconstructionSuccess(class ACrBuildingActorBase* InBuilding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "OnDeconstructionSuccess");

	Params::CrPlayerControllerBase_OnDeconstructionSuccess Parms{};

	Parms.InBuilding = InBuilding;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.OnRep_PlayerSkills
// (Final, Native, Public)

void ACrPlayerControllerBase::OnRep_PlayerSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "OnRep_PlayerSkills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.RemoveCameraGameplayEffect
// (Final, Native, Public)
// Parameters:
// class UGameplayEffect*                  CamGE                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::RemoveCameraGameplayEffect(class UGameplayEffect* CamGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "RemoveCameraGameplayEffect");

	Params::CrPlayerControllerBase_RemoveCameraGameplayEffect Parms{};

	Parms.CamGE = CamGE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ResetDeconstructionData
// (Final, Native, Public)

void ACrPlayerControllerBase::ResetDeconstructionData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ResetDeconstructionData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.RespawnPlayerInBase
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::RespawnPlayerInBase(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "RespawnPlayerInBase");

	Params::CrPlayerControllerBase_RespawnPlayerInBase Parms{};

	Parms.InPlayer = InPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SaveBuildingsToTxt
// (Final, Native, Public)

void ACrPlayerControllerBase::SaveBuildingsToTxt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SaveBuildingsToTxt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SaveCBStatusToTxt
// (Final, Native, Public)

void ACrPlayerControllerBase::SaveCBStatusToTxt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SaveCBStatusToTxt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SaveInventoryToTxt
// (Final, Native, Public)

void ACrPlayerControllerBase::SaveInventoryToTxt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SaveInventoryToTxt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SaveSurvivalStatsToTxt
// (Final, Native, Public)

void ACrPlayerControllerBase::SaveSurvivalStatsToTxt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SaveSurvivalStatsToTxt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SaveWeaponToTxt
// (Final, Native, Public)

void ACrPlayerControllerBase::SaveWeaponToTxt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SaveWeaponToTxt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.Server_DedicatedServerConsoleCommand
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWriteToLog                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::Server_DedicatedServerConsoleCommand(const class FString& Command, bool bWriteToLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "Server_DedicatedServerConsoleCommand");

	Params::CrPlayerControllerBase_Server_DedicatedServerConsoleCommand Parms{};

	Parms.Command = std::move(Command);
	Parms.bWriteToLog = bWriteToLog;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerAddBaseCoreItemsToUpgrade
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BaseCore                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrCountItem&              ItemsToAddItem                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerAddBaseCoreItemsToUpgrade(const struct FCrMassEntityReplicationHelper& BaseCore, const struct FCrCountItem& ItemsToAddItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerAddBaseCoreItemsToUpgrade");

	Params::CrPlayerControllerBase_ServerAddBaseCoreItemsToUpgrade Parms{};

	Parms.BaseCore = std::move(BaseCore);
	Parms.ItemsToAddItem = std::move(ItemsToAddItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerAddDynamicTagGameplayEffect
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerAddDynamicTagGameplayEffect(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerAddDynamicTagGameplayEffect");

	Params::CrPlayerControllerBase_ServerAddDynamicTagGameplayEffect Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerAddItemToAnalyze
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Analyzer                                               (Parm, NativeAccessSpecifierPublic)
// class UAuItemDataBase*                  Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerAddItemToAnalyze(const struct FCrMassActorReplicationHelper& Analyzer, class UAuItemDataBase* Item, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerAddItemToAnalyze");

	Params::CrPlayerControllerBase_ServerAddItemToAnalyze Parms{};

	Parms.Analyzer = std::move(Analyzer);
	Parms.Item = Item;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerAddItemToCraft
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Crafter                                                (Parm, NativeAccessSpecifierPublic)
// class UCrItemRecipeData*                InRecipe                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerAddItemToCraft(const struct FCrMassActorReplicationHelper& Crafter, class UCrItemRecipeData* InRecipe, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerAddItemToCraft");

	Params::CrPlayerControllerBase_ServerAddItemToCraft Parms{};

	Parms.Crafter = std::move(Crafter);
	Parms.InRecipe = InRecipe;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerAddItemToExport
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Exporter                                               (Parm, NativeAccessSpecifierPublic)
// class UAuItemDataBase*                  Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   CorporationIndex                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerAddItemToExport(const struct FCrMassActorReplicationHelper& Exporter, class UAuItemDataBase* Item, int32 Level, uint8 CorporationIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerAddItemToExport");

	Params::CrPlayerControllerBase_ServerAddItemToExport Parms{};

	Parms.Exporter = std::move(Exporter);
	Parms.Item = Item;
	Parms.Level = Level;
	Parms.CorporationIndex = CorporationIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerAddItemToRecycle
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Crafter                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    bFullRecycle                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerAddItemToRecycle(const struct FCrMassActorReplicationHelper& Crafter, bool bFullRecycle, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerAddItemToRecycle");

	Params::CrPlayerControllerBase_ServerAddItemToRecycle Parms{};

	Parms.Crafter = std::move(Crafter);
	Parms.bFullRecycle = bFullRecycle;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerAddSecondaryWeaponTag
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerAddSecondaryWeaponTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerAddSecondaryWeaponTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerApplyCameraGameplayEffect
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UGameplayEffect*                  CamGE                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerApplyCameraGameplayEffect(class UGameplayEffect* CamGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerApplyCameraGameplayEffect");

	Params::CrPlayerControllerBase_ServerApplyCameraGameplayEffect Parms{};

	Parms.CamGE = CamGE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerCancelZiplineMode
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerCancelZiplineMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerCancelZiplineMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerChangeStorageElectricityMultiplier
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Storage                                                (Parm, NativeAccessSpecifierPublic)
// int32                                   NewMultiplier                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerChangeStorageElectricityMultiplier(const struct FCrMassActorReplicationHelper& Storage, int32 NewMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerChangeStorageElectricityMultiplier");

	Params::CrPlayerControllerBase_ServerChangeStorageElectricityMultiplier Parms{};

	Parms.Storage = std::move(Storage);
	Parms.NewMultiplier = NewMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerChatCommit
// (Net, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    Text                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerChatCommit(const class FString& Text)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerChatCommit");

	Params::CrPlayerControllerBase_ServerChatCommit Parms{};

	Parms.Text = std::move(Text);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerCheat
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerCheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerCheat");

	Params::CrPlayerControllerBase_ServerCheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerCheatAll
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerCheatAll(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerCheatAll");

	Params::CrPlayerControllerBase_ServerCheatAll Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerCheatGiveDefaultWeaopns
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerCheatGiveDefaultWeaopns()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerCheatGiveDefaultWeaopns");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerCheatGiveItem
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UAuItemDataBase*                  ItemType                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerCheatGiveItem(class UAuItemDataBase* ItemType, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerCheatGiveItem");

	Params::CrPlayerControllerBase_ServerCheatGiveItem Parms{};

	Parms.ItemType = ItemType;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerCompleteTutorial
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bNotify                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerCompleteTutorial(bool bNotify)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerCompleteTutorial");

	Params::CrPlayerControllerBase_ServerCompleteTutorial Parms{};

	Parms.bNotify = bNotify;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerCraftItemInstant
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class UCrItemRecipeData*          InRecipe                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Multiplier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrInventoryComponent*            SourceItemComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerCraftItemInstant(const class UCrItemRecipeData* InRecipe, int32 Multiplier, class UCrInventoryComponent* SourceItemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerCraftItemInstant");

	Params::CrPlayerControllerBase_ServerCraftItemInstant Parms{};

	Parms.InRecipe = InRecipe;
	Parms.Multiplier = Multiplier;
	Parms.SourceItemComponent = SourceItemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerCraftItemInstantCustom
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TArray<struct FAuSimpleItem>&     From                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FAuSimpleItem>&     To                                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UCrInventoryComponent*            SourceItemComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerCraftItemInstantCustom(const TArray<struct FAuSimpleItem>& From, const TArray<struct FAuSimpleItem>& To, class UCrInventoryComponent* SourceItemComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerCraftItemInstantCustom");

	Params::CrPlayerControllerBase_ServerCraftItemInstantCustom Parms{};

	Parms.From = std::move(From);
	Parms.To = std::move(To);
	Parms.SourceItemComponent = SourceItemComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDamageMassTarget
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Target                                                 (Parm, NativeAccessSpecifierPublic)
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDamageEvent&              DamageEvent                                            (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDamageMassTarget(const struct FCrMassActorReplicationHelper& Target, float DamageAmount, const struct FDamageEvent& DamageEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDamageMassTarget");

	Params::CrPlayerControllerBase_ServerDamageMassTarget Parms{};

	Parms.Target = std::move(Target);
	Parms.DamageAmount = DamageAmount;
	Parms.DamageEvent = std::move(DamageEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugAddItems
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugAddItems(const class FString& Name_0, int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugAddItems");

	Params::CrPlayerControllerBase_ServerDebugAddItems Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugCancelWave
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugCancelWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugCancelWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugChangeGlobalGatherablesPCGSeed
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugChangeGlobalGatherablesPCGSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugChangeGlobalGatherablesPCGSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugDestroyAllItems
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugDestroyAllItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugDestroyAllItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugKillAllEnemies
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugKillAllEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugKillAllEnemies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugPauseWave
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugPauseWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugPauseWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugRemoveTemperatureOverride
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugRemoveTemperatureOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugRemoveTemperatureOverride");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugSetEnviroWaveProgress
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        WaveStage                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugSetEnviroWaveProgress(EEnviroWave WaveType, EEnviroWaveStage WaveStage, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugSetEnviroWaveProgress");

	Params::CrPlayerControllerBase_ServerDebugSetEnviroWaveProgress Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveStage = WaveStage;
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugSetSurvivalAttribute
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugSetSurvivalAttribute(const class FString& Name_0, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugSetSurvivalAttribute");

	Params::CrPlayerControllerBase_ServerDebugSetSurvivalAttribute Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugSetTemperatureOverride
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugSetTemperatureOverride(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugSetTemperatureOverride");

	Params::CrPlayerControllerBase_ServerDebugSetTemperatureOverride Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugSetUnlockedInventorySlots
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   InUnlockedInventorySlots                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugSetUnlockedInventorySlots(int32 InUnlockedInventorySlots)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugSetUnlockedInventorySlots");

	Params::CrPlayerControllerBase_ServerDebugSetUnlockedInventorySlots Parms{};

	Parms.InUnlockedInventorySlots = InUnlockedInventorySlots;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugSkipToNextWaveStage
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugSkipToNextWaveStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugSkipToNextWaveStage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugSpawnActor
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// class UClass*                           Class_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugSpawnActor(class UClass* Class_0, const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugSpawnActor");

	Params::CrPlayerControllerBase_ServerDebugSpawnActor Parms{};

	Parms.Class_0 = Class_0;
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugStartResumeDefaultHeatWave
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugStartResumeDefaultHeatWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugStartResumeDefaultHeatWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugTeleportPlayer
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugTeleportPlayer(const struct FVector& Location, const struct FRotator& Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugTeleportPlayer");

	Params::CrPlayerControllerBase_ServerDebugTeleportPlayer Parms{};

	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugUnlockAllFeatures
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerDebugUnlockAllFeatures()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugUnlockAllFeatures");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugUnlockFeature
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// ECrCorporationUnlockedFeatures          InFeature                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugUnlockFeature(ECrCorporationUnlockedFeatures InFeature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugUnlockFeature");

	Params::CrPlayerControllerBase_ServerDebugUnlockFeature Parms{};

	Parms.InFeature = InFeature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDestructBuilding
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Building                                               (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDestructBuilding(const struct FCrMassActorReplicationHelper& Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDestructBuilding");

	Params::CrPlayerControllerBase_ServerDestructBuilding Parms{};

	Parms.Building = std::move(Building);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerDestructBuildingConditional
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Building                                               (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDestructBuildingConditional(const struct FCrMassActorReplicationHelper& Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDestructBuildingConditional");

	Params::CrPlayerControllerBase_ServerDestructBuildingConditional Parms{};

	Parms.Building = std::move(Building);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerExecuteConsoleCommand
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const class FString&                    Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerExecuteConsoleCommand(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerExecuteConsoleCommand");

	Params::CrPlayerControllerBase_ServerExecuteConsoleCommand Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerExecuteFlow
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    InFlowName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerExecuteFlow(const class FString& InFlowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerExecuteFlow");

	Params::CrPlayerControllerBase_ServerExecuteFlow Parms{};

	Parms.InFlowName = std::move(InFlowName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerGetBuildingCustomName
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&Building                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerGetBuildingCustomName(const struct FCrMassEntityReplicationHelper& Building)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerGetBuildingCustomName");

	Params::CrPlayerControllerBase_ServerGetBuildingCustomName Parms{};

	Parms.Building = std::move(Building);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerGiveDataPointsToCorporation
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// uint8                                   InCorporationIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InDataPoints                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerGiveDataPointsToCorporation(uint8 InCorporationIndex, int32 InDataPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerGiveDataPointsToCorporation");

	Params::CrPlayerControllerBase_ServerGiveDataPointsToCorporation Parms{};

	Parms.InCorporationIndex = InCorporationIndex;
	Parms.InDataPoints = InDataPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerMergeStack
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassComponentReplicationHelper&Inventory                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FAuItemId&                 FromId                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuItemId&                 ToId                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToMerge                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerMergeStack(const struct FCrMassComponentReplicationHelper& Inventory, const struct FAuItemId& FromId, const struct FAuItemId& ToId, int32 ToMerge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerMergeStack");

	Params::CrPlayerControllerBase_ServerMergeStack Parms{};

	Parms.Inventory = std::move(Inventory);
	Parms.FromId = std::move(FromId);
	Parms.ToId = std::move(ToId);
	Parms.ToMerge = ToMerge;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerMoveItemSlotToStorage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrSlotId&                 FromSlot                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrInventoryComponent*            FromInventory                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrSlotId&                 ToSlot                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&ToStorage                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerMoveItemSlotToStorage(const struct FCrSlotId& FromSlot, class UCrInventoryComponent* FromInventory, const struct FCrSlotId& ToSlot, const struct FCrMassComponentReplicationHelper& ToStorage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerMoveItemSlotToStorage");

	Params::CrPlayerControllerBase_ServerMoveItemSlotToStorage Parms{};

	Parms.FromSlot = std::move(FromSlot);
	Parms.FromInventory = FromInventory;
	Parms.ToSlot = std::move(ToSlot);
	Parms.ToStorage = std::move(ToStorage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerMoveItemToInventory
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UAuItemDataBase*                  ItemType                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuItemId&                 ItemId                                                 (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuItemsComponent*                Inventory                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&From                                                   (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerMoveItemToInventory(class UAuItemDataBase* ItemType, const struct FAuItemId& ItemId, int32 Amount, class UAuItemsComponent* Inventory, const struct FCrMassComponentReplicationHelper& From)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerMoveItemToInventory");

	Params::CrPlayerControllerBase_ServerMoveItemToInventory Parms{};

	Parms.ItemType = ItemType;
	Parms.ItemId = std::move(ItemId);
	Parms.Amount = Amount;
	Parms.Inventory = Inventory;
	Parms.From = std::move(From);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerMoveItemTypeFromStorage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class UAuItemDataBase*            ItemType                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuItemsComponent*                Inventory                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&Storage                                                (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerMoveItemTypeFromStorage(const class UAuItemDataBase* ItemType, int32 Amount, class UAuItemsComponent* Inventory, const struct FCrMassComponentReplicationHelper& Storage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerMoveItemTypeFromStorage");

	Params::CrPlayerControllerBase_ServerMoveItemTypeFromStorage Parms{};

	Parms.ItemType = ItemType;
	Parms.Amount = Amount;
	Parms.Inventory = Inventory;
	Parms.Storage = std::move(Storage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerMoveItemTypeToStorage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UAuItemDataBase*                  ItemType                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAuItemsComponent*                Inventory                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&Storage                                                (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerMoveItemTypeToStorage(class UAuItemDataBase* ItemType, int32 Amount, class UAuItemsComponent* Inventory, const struct FCrMassComponentReplicationHelper& Storage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerMoveItemTypeToStorage");

	Params::CrPlayerControllerBase_ServerMoveItemTypeToStorage Parms{};

	Parms.ItemType = ItemType;
	Parms.Amount = Amount;
	Parms.Inventory = Inventory;
	Parms.Storage = std::move(Storage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnAudiologEnded
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FGuid&                     AudiologGuid                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerOnAudiologEnded(const struct FGuid& AudiologGuid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnAudiologEnded");

	Params::CrPlayerControllerBase_ServerOnAudiologEnded Parms{};

	Parms.AudiologGuid = std::move(AudiologGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnAudiologStarted
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FGuid&                     AudiologGuid                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerOnAudiologStarted(const struct FGuid& AudiologGuid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnAudiologStarted");

	Params::CrPlayerControllerBase_ServerOnAudiologStarted Parms{};

	Parms.AudiologGuid = std::move(AudiologGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnBuildingUIOpened
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerOnBuildingUIOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnBuildingUIOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnCloseUI
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerOnCloseUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnCloseUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnDatapadRead
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FGuid&                     DatapadGuid                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             EntryName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerOnDatapadRead(const struct FGuid& DatapadGuid, class FName EntryName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnDatapadRead");

	Params::CrPlayerControllerBase_ServerOnDatapadRead Parms{};

	Parms.DatapadGuid = std::move(DatapadGuid);
	Parms.EntryName = EntryName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnEnterAiSpawner
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TScriptInterface<class ICrAISpawnerTriggerInterface>&SpawnerTrigger                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerOnEnterAiSpawner(const TScriptInterface<class ICrAISpawnerTriggerInterface>& SpawnerTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnEnterAiSpawner");

	Params::CrPlayerControllerBase_ServerOnEnterAiSpawner Parms{};

	Parms.SpawnerTrigger = SpawnerTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnExitAiSpawner
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const TScriptInterface<class ICrAISpawnerTriggerInterface>&SpawnerTrigger                                         (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerOnExitAiSpawner(const TScriptInterface<class ICrAISpawnerTriggerInterface>& SpawnerTrigger)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnExitAiSpawner");

	Params::CrPlayerControllerBase_ServerOnExitAiSpawner Parms{};

	Parms.SpawnerTrigger = SpawnerTrigger;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnInputEncyclopediaMenu
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerOnInputEncyclopediaMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnInputEncyclopediaMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnInputInventoryMenu
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerOnInputInventoryMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnInputInventoryMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnInputMapMenu
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerOnInputMapMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnInputMapMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnPing
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector&                   PingLocation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerOnPing(const struct FVector& PingLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnPing");

	Params::CrPlayerControllerBase_ServerOnPing Parms{};

	Parms.PingLocation = std::move(PingLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerOnSingleBuildingUIOpened
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerOnSingleBuildingUIOpened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerOnSingleBuildingUIOpened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerPickAllFromStorage
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UAuItemsComponent*                Inventory                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassComponentReplicationHelper&From                                                   (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bDropItemsThatDidntFit                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerPickAllFromStorage(class UAuItemsComponent* Inventory, const struct FCrMassComponentReplicationHelper& From, bool bDropItemsThatDidntFit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerPickAllFromStorage");

	Params::CrPlayerControllerBase_ServerPickAllFromStorage Parms{};

	Parms.Inventory = Inventory;
	Parms.From = std::move(From);
	Parms.bDropItemsThatDidntFit = bDropItemsThatDidntFit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerPickUpAllRequestDrones
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&Drone                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerPickUpAllRequestDrones(const struct FCrMassEntityReplicationHelper& Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerPickUpAllRequestDrones");

	Params::CrPlayerControllerBase_ServerPickUpAllRequestDrones Parms{};

	Parms.Drone = std::move(Drone);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerPickUpDronesFromBuilding
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&DroneBuilding                                          (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerPickUpDronesFromBuilding(const struct FCrMassActorReplicationHelper& DroneBuilding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerPickUpDronesFromBuilding");

	Params::CrPlayerControllerBase_ServerPickUpDronesFromBuilding Parms{};

	Parms.DroneBuilding = std::move(DroneBuilding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerPickUpItemFromDrone
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Drone                                                  (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerPickUpItemFromDrone(const struct FCrMassActorReplicationHelper& Drone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerPickUpItemFromDrone");

	Params::CrPlayerControllerBase_ServerPickUpItemFromDrone Parms{};

	Parms.Drone = std::move(Drone);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerPossesPawnByProfessionType
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EProfessionType                         Profession                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPlayerSelected                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerPossesPawnByProfessionType(EProfessionType Profession, bool bPlayerSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerPossesPawnByProfessionType");

	Params::CrPlayerControllerBase_ServerPossesPawnByProfessionType Parms{};

	Parms.Profession = Profession;
	Parms.bPlayerSelected = bPlayerSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRemoveAllItemsFromCrafting
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Crafter                                                (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerRemoveAllItemsFromCrafting(const struct FCrMassActorReplicationHelper& Crafter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRemoveAllItemsFromCrafting");

	Params::CrPlayerControllerBase_ServerRemoveAllItemsFromCrafting Parms{};

	Parms.Crafter = std::move(Crafter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRemoveBaseCoreItemsToUpgrade
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BaseCore                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrCountItem&              ItemsToAddItem                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerRemoveBaseCoreItemsToUpgrade(const struct FCrMassEntityReplicationHelper& BaseCore, const struct FCrCountItem& ItemsToAddItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRemoveBaseCoreItemsToUpgrade");

	Params::CrPlayerControllerBase_ServerRemoveBaseCoreItemsToUpgrade Parms{};

	Parms.BaseCore = std::move(BaseCore);
	Parms.ItemsToAddItem = std::move(ItemsToAddItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRemoveCameraGameplayEffect
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UGameplayEffect*                  CamGE                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerRemoveCameraGameplayEffect(class UGameplayEffect* CamGE)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRemoveCameraGameplayEffect");

	Params::CrPlayerControllerBase_ServerRemoveCameraGameplayEffect Parms{};

	Parms.CamGE = CamGE;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRemoveDynamicTagGameplayEffect
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FGameplayTag&              InTag                                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerRemoveDynamicTagGameplayEffect(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRemoveDynamicTagGameplayEffect");

	Params::CrPlayerControllerBase_ServerRemoveDynamicTagGameplayEffect Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRemoveItemFromCrafting
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Crafter                                                (Parm, NativeAccessSpecifierPublic)
// class UCrItemRecipeData*                ItemTag                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerRemoveItemFromCrafting(const struct FCrMassActorReplicationHelper& Crafter, class UCrItemRecipeData* ItemTag, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRemoveItemFromCrafting");

	Params::CrPlayerControllerBase_ServerRemoveItemFromCrafting Parms{};

	Parms.Crafter = std::move(Crafter);
	Parms.ItemTag = ItemTag;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRemoveItemFromCraftingByIdx
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Crafter                                                (Parm, NativeAccessSpecifierPublic)
// int32                                   Idx                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerRemoveItemFromCraftingByIdx(const struct FCrMassActorReplicationHelper& Crafter, int32 Idx, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRemoveItemFromCraftingByIdx");

	Params::CrPlayerControllerBase_ServerRemoveItemFromCraftingByIdx Parms{};

	Parms.Crafter = std::move(Crafter);
	Parms.Idx = Idx;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRemovePlayerPersonalMarker
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerRemovePlayerPersonalMarker()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRemovePlayerPersonalMarker");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRemoveSecondaryWeaponTag
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerRemoveSecondaryWeaponTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRemoveSecondaryWeaponTag");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRequestSaveGame
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerRequestSaveGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRequestSaveGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRespawnPlayerInBase
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerRespawnPlayerInBase(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRespawnPlayerInBase");

	Params::CrPlayerControllerBase_ServerRespawnPlayerInBase Parms{};

	Parms.InPlayer = InPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerRespawnPlayerInSpawnPoint
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerRespawnPlayerInSpawnPoint(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerRespawnPlayerInSpawnPoint");

	Params::CrPlayerControllerBase_ServerRespawnPlayerInSpawnPoint Parms{};

	Parms.InPlayer = InPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSaveBuildingsToTxt
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerSaveBuildingsToTxt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSaveBuildingsToTxt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSaveCBStatusToTxt
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerSaveCBStatusToTxt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSaveCBStatusToTxt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetAntennaState
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&InAntenna                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrAntennaState                         InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetAntennaState(const struct FCrMassEntityReplicationHelper& InAntenna, ECrAntennaState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetAntennaState");

	Params::CrPlayerControllerBase_ServerSetAntennaState Parms{};

	Parms.InAntenna = std::move(InAntenna);
	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetBaseCoreDeconstructionStartTime
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BaseCore                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeconstructionStartTime                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetBaseCoreDeconstructionStartTime(const struct FCrMassEntityReplicationHelper& BaseCore, float DeconstructionStartTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetBaseCoreDeconstructionStartTime");

	Params::CrPlayerControllerBase_ServerSetBaseCoreDeconstructionStartTime Parms{};

	Parms.BaseCore = std::move(BaseCore);
	Parms.DeconstructionStartTime = DeconstructionStartTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetBaseCoreSelectedLevelToUpgrade
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BaseCore                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    SelectedLevelToUpgrade                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetBaseCoreSelectedLevelToUpgrade(const struct FCrMassEntityReplicationHelper& BaseCore, int8 SelectedLevelToUpgrade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetBaseCoreSelectedLevelToUpgrade");

	Params::CrPlayerControllerBase_ServerSetBaseCoreSelectedLevelToUpgrade Parms{};

	Parms.BaseCore = std::move(BaseCore);
	Parms.SelectedLevelToUpgrade = SelectedLevelToUpgrade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetBaseCoreUpgradeLevel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BaseCore                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   BaseCoreUpgradeLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ClearBaseCoreItems                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetBaseCoreUpgradeLevel(const struct FCrMassEntityReplicationHelper& BaseCore, uint8 BaseCoreUpgradeLevel, bool ClearBaseCoreItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetBaseCoreUpgradeLevel");

	Params::CrPlayerControllerBase_ServerSetBaseCoreUpgradeLevel Parms{};

	Parms.BaseCore = std::move(BaseCore);
	Parms.BaseCoreUpgradeLevel = BaseCoreUpgradeLevel;
	Parms.ClearBaseCoreItems = ClearBaseCoreItems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetBuildingCustomName
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&Building                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    CustomName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetBuildingCustomName(const struct FCrMassEntityReplicationHelper& Building, const class FString& CustomName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetBuildingCustomName");

	Params::CrPlayerControllerBase_ServerSetBuildingCustomName Parms{};

	Parms.Building = std::move(Building);
	Parms.CustomName = std::move(CustomName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetBuildingInventoryAllSlotFilter
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassComponentReplicationHelper&Inventory                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UAuItemDataBase*            Filter                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACrPlayerControllerBase*          PlayerToReturnItemsTo                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetBuildingInventoryAllSlotFilter(const struct FCrMassComponentReplicationHelper& Inventory, const class UAuItemDataBase* Filter, class ACrPlayerControllerBase* PlayerToReturnItemsTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetBuildingInventoryAllSlotFilter");

	Params::CrPlayerControllerBase_ServerSetBuildingInventoryAllSlotFilter Parms{};

	Parms.Inventory = std::move(Inventory);
	Parms.Filter = Filter;
	Parms.PlayerToReturnItemsTo = PlayerToReturnItemsTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetBuildingInventorySlotFilter
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassComponentReplicationHelper&Inventory                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FCrSlotId&                 SlotID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAuItemDataBase*            Filter                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACrPlayerControllerBase*          PlayerToReturnItemsTo                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetBuildingInventorySlotFilter(const struct FCrMassComponentReplicationHelper& Inventory, const struct FCrSlotId& SlotID, const class UAuItemDataBase* Filter, class ACrPlayerControllerBase* PlayerToReturnItemsTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetBuildingInventorySlotFilter");

	Params::CrPlayerControllerBase_ServerSetBuildingInventorySlotFilter Parms{};

	Parms.Inventory = std::move(Inventory);
	Parms.SlotID = std::move(SlotID);
	Parms.Filter = Filter;
	Parms.PlayerToReturnItemsTo = PlayerToReturnItemsTo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetCraftingMultiplier
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Crafter                                                (Parm, NativeAccessSpecifierPublic)
// int32                                   Mul                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetCraftingMultiplier(const struct FCrMassActorReplicationHelper& Crafter, int32 Mul)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetCraftingMultiplier");

	Params::CrPlayerControllerBase_ServerSetCraftingMultiplier Parms{};

	Parms.Crafter = std::move(Crafter);
	Parms.Mul = Mul;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetDroneLineFilter
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&DroneLine                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrItemDataBase*                  Filter                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetDroneLineFilter(const struct FCrMassEntityReplicationHelper& DroneLine, class UCrItemDataBase* Filter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetDroneLineFilter");

	Params::CrPlayerControllerBase_ServerSetDroneLineFilter Parms{};

	Parms.DroneLine = std::move(DroneLine);
	Parms.Filter = Filter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetInPauseMenu
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bInSet                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetInPauseMenu(bool bInSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetInPauseMenu");

	Params::CrPlayerControllerBase_ServerSetInPauseMenu Parms{};

	Parms.bInSet = bInSet;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetLogisticsPriority
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Building                                               (Parm, NativeAccessSpecifierPublic)
// ECrLogisticsRequestPriority             Priority                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetLogisticsPriority(const struct FCrMassActorReplicationHelper& Building, ECrLogisticsRequestPriority Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetLogisticsPriority");

	Params::CrPlayerControllerBase_ServerSetLogisticsPriority Parms{};

	Parms.Building = std::move(Building);
	Parms.Priority = Priority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetMapMenuOpened
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    IsOpen                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetMapMenuOpened(bool IsOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetMapMenuOpened");

	Params::CrPlayerControllerBase_ServerSetMapMenuOpened Parms{};

	Parms.IsOpen = IsOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetPlayerPersonalMarker
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults)
// Parameters:
// const struct FVector2f&                 Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetPlayerPersonalMarker(const struct FVector2f& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetPlayerPersonalMarker");

	Params::CrPlayerControllerBase_ServerSetPlayerPersonalMarker Parms{};

	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetPlayerSelectedProfession
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   InPlayerId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EProfessionType                         InSelectedProfession                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetPlayerSelectedProfession(int32 InPlayerId, EProfessionType InSelectedProfession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetPlayerSelectedProfession");

	Params::CrPlayerControllerBase_ServerSetPlayerSelectedProfession Parms{};

	Parms.InPlayerId = InPlayerId;
	Parms.InSelectedProfession = InSelectedProfession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetSenderReceiverConnection
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&Sender                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassEntityReplicationHelper&Receiver                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetSenderReceiverConnection(const struct FCrMassEntityReplicationHelper& Sender, const struct FCrMassEntityReplicationHelper& Receiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetSenderReceiverConnection");

	Params::CrPlayerControllerBase_ServerSetSenderReceiverConnection Parms{};

	Parms.Sender = std::move(Sender);
	Parms.Receiver = std::move(Receiver);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetSlotItemThreshold
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassComponentReplicationHelper&Inventory                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FCrSlotId&                 SlotID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Threshold                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetSlotItemThreshold(const struct FCrMassComponentReplicationHelper& Inventory, const struct FCrSlotId& SlotID, int32 Threshold)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetSlotItemThreshold");

	Params::CrPlayerControllerBase_ServerSetSlotItemThreshold Parms{};

	Parms.Inventory = std::move(Inventory);
	Parms.SlotID = std::move(SlotID);
	Parms.Threshold = Threshold;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSetTransportItemForSender
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&Sender                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCrItemDataBase*            InItem                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InRequestedAmount                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSetTransportItemForSender(const struct FCrMassEntityReplicationHelper& Sender, const class UCrItemDataBase* InItem, int32 InRequestedAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSetTransportItemForSender");

	Params::CrPlayerControllerBase_ServerSetTransportItemForSender Parms{};

	Parms.Sender = std::move(Sender);
	Parms.InItem = InItem;
	Parms.InRequestedAmount = InRequestedAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSimulateDestruction
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&Building                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    BaseCoreDeconstructionMode                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSimulateDestruction(const struct FCrMassEntityReplicationHelper& Building, bool BaseCoreDeconstructionMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSimulateDestruction");

	Params::CrPlayerControllerBase_ServerSimulateDestruction Parms{};

	Parms.Building = std::move(Building);
	Parms.BaseCoreDeconstructionMode = BaseCoreDeconstructionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSpawnPointActorDestroyed
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BuildingEntityReplicationHelper                        (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSpawnPointActorDestroyed(const struct FCrMassEntityReplicationHelper& BuildingEntityReplicationHelper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSpawnPointActorDestroyed");

	Params::CrPlayerControllerBase_ServerSpawnPointActorDestroyed Parms{};

	Parms.BuildingEntityReplicationHelper = std::move(BuildingEntityReplicationHelper);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSpawnPointBuildingStarted
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&InBuilding                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSpawnPointBuildingStarted(const struct FCrMassEntityReplicationHelper& InBuilding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSpawnPointBuildingStarted");

	Params::CrPlayerControllerBase_ServerSpawnPointBuildingStarted Parms{};

	Parms.InBuilding = std::move(InBuilding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSpawnPointCreate
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&ReplicationHelper                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSpawnPointCreate(const struct FCrMassEntityReplicationHelper& ReplicationHelper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSpawnPointCreate");

	Params::CrPlayerControllerBase_ServerSpawnPointCreate Parms{};

	Parms.ReplicationHelper = std::move(ReplicationHelper);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSpawnPointOccupy
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&InBuilding                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    PlayerName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSpawnPointOccupy(const struct FCrMassEntityReplicationHelper& InBuilding, const class FString& PlayerName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSpawnPointOccupy");

	Params::CrPlayerControllerBase_ServerSpawnPointOccupy Parms{};

	Parms.InBuilding = std::move(InBuilding);
	Parms.PlayerName = std::move(PlayerName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSplitStack
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassComponentReplicationHelper&Inventory                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FAuItemId&                 ItemId                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToSplit                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSplitStack(const struct FCrMassComponentReplicationHelper& Inventory, const struct FAuItemId& ItemId, int32 ToSplit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSplitStack");

	Params::CrPlayerControllerBase_ServerSplitStack Parms{};

	Parms.Inventory = std::move(Inventory);
	Parms.ItemId = std::move(ItemId);
	Parms.ToSplit = ToSplit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStartActorInteractWithSystemAbility
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStartActorInteractWithSystemAbility(class AActor* InActor, int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStartActorInteractWithSystemAbility");

	Params::CrPlayerControllerBase_ServerStartActorInteractWithSystemAbility Parms{};

	Parms.InActor = InActor;
	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStartBuildingInteraction
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BuildingMassReplicationHelper                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBuildingManualInteraction              InteractionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStartBuildingInteraction(const struct FCrMassEntityReplicationHelper& BuildingMassReplicationHelper, EBuildingManualInteraction InteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStartBuildingInteraction");

	Params::CrPlayerControllerBase_ServerStartBuildingInteraction Parms{};

	Parms.BuildingMassReplicationHelper = std::move(BuildingMassReplicationHelper);
	Parms.InteractionType = InteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStartInteractWithActor
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStartInteractWithActor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStartInteractWithActor");

	Params::CrPlayerControllerBase_ServerStartInteractWithActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStartInteractWithInstance
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class UInstancedStaticMeshComponent*    InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int8                                    InstanceIdx                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStartInteractWithInstance(class UInstancedStaticMeshComponent* InComponent, int8 InstanceIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStartInteractWithInstance");

	Params::CrPlayerControllerBase_ServerStartInteractWithInstance Parms{};

	Parms.InComponent = InComponent;
	Parms.InstanceIdx = InstanceIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStartInteractWithMass
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FMassNetworkID&            InActor                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStartInteractWithMass(const struct FMassNetworkID& InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStartInteractWithMass");

	Params::CrPlayerControllerBase_ServerStartInteractWithMass Parms{};

	Parms.InActor = std::move(InActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStartMassInteractWithSystemAbility
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FMassNetworkID&            InActor                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AbilityIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStartMassInteractWithSystemAbility(const struct FMassNetworkID& InActor, int32 AbilityIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStartMassInteractWithSystemAbility");

	Params::CrPlayerControllerBase_ServerStartMassInteractWithSystemAbility Parms{};

	Parms.InActor = std::move(InActor);
	Parms.AbilityIndex = AbilityIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStartZiplineMode
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&CurrentZiplinePoint                                    (Parm, NativeAccessSpecifierPublic)
// bool                                    bJustTravelled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStartZiplineMode(const struct FCrMassActorReplicationHelper& CurrentZiplinePoint, bool bJustTravelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStartZiplineMode");

	Params::CrPlayerControllerBase_ServerStartZiplineMode Parms{};

	Parms.CurrentZiplinePoint = std::move(CurrentZiplinePoint);
	Parms.bJustTravelled = bJustTravelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStopAllInteractions
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerStopAllInteractions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStopAllInteractions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStopBuildingInteraction
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&BuildingMassReplicationHelper                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EBuildingManualInteraction              InteractionType                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStopBuildingInteraction(const struct FCrMassEntityReplicationHelper& BuildingMassReplicationHelper, EBuildingManualInteraction InteractionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStopBuildingInteraction");

	Params::CrPlayerControllerBase_ServerStopBuildingInteraction Parms{};

	Parms.BuildingMassReplicationHelper = std::move(BuildingMassReplicationHelper);
	Parms.InteractionType = InteractionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStopInteractWithActor
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStopInteractWithActor(class AActor* InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStopInteractWithActor");

	Params::CrPlayerControllerBase_ServerStopInteractWithActor Parms{};

	Parms.InActor = InActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStopInteractWithMass
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FMassNetworkID&            InActor                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerStopInteractWithMass(const struct FMassNetworkID& InActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStopInteractWithMass");

	Params::CrPlayerControllerBase_ServerStopInteractWithMass Parms{};

	Parms.InActor = std::move(InActor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerStopSimulateDestruction
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerStopSimulateDestruction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerStopSimulateDestruction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSwitchPawn
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerSwitchPawn(class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSwitchPawn");

	Params::CrPlayerControllerBase_ServerSwitchPawn Parms{};

	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSwitchToMainPawn
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerSwitchToMainPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSwitchToMainPawn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSwitchToNextZipline
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerSwitchToNextZipline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSwitchToNextZipline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerSwitchToPreviousZipline
// (Net, NetReliable, Native, Event, Public, NetServer)

void ACrPlayerControllerBase::ServerSwitchToPreviousZipline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerSwitchToPreviousZipline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerTeleportPlayer
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassEntityReplicationHelper&SourceTeleporter                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrMassEntityReplicationHelper&TargetTeleporter                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerTeleportPlayer(const struct FCrMassEntityReplicationHelper& SourceTeleporter, const struct FCrMassEntityReplicationHelper& TargetTeleporter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerTeleportPlayer");

	Params::CrPlayerControllerBase_ServerTeleportPlayer Parms{};

	Parms.SourceTeleporter = std::move(SourceTeleporter);
	Parms.TargetTeleporter = std::move(TargetTeleporter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerToggleBuildingDisabled
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&Crafter                                                (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerToggleBuildingDisabled(const struct FCrMassActorReplicationHelper& Crafter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerToggleBuildingDisabled");

	Params::CrPlayerControllerBase_ServerToggleBuildingDisabled Parms{};

	Parms.Crafter = std::move(Crafter);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerToggleBuildingOpen
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const struct FCrMassActorReplicationHelper&InBuilding                                             (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerToggleBuildingOpen(const struct FCrMassActorReplicationHelper& InBuilding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerToggleBuildingOpen");

	Params::CrPlayerControllerBase_ServerToggleBuildingOpen Parms{};

	Parms.InBuilding = std::move(InBuilding);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerToggleDeconstructMode
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bChangedWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerToggleDeconstructMode(bool bChangedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerToggleDeconstructMode");

	Params::CrPlayerControllerBase_ServerToggleDeconstructMode Parms{};

	Parms.bChangedWeapon = bChangedWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerTryAddItemsForRecipeUnlock
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UCrItemRecipeData*                InRecipe                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCrItemDataBase>      InItem                                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerTryAddItemsForRecipeUnlock(class UCrItemRecipeData* InRecipe, TSubclassOf<class UCrItemDataBase> InItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerTryAddItemsForRecipeUnlock");

	Params::CrPlayerControllerBase_ServerTryAddItemsForRecipeUnlock Parms{};

	Parms.InRecipe = InRecipe;
	Parms.InItem = InItem;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerTryClaimReward
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// uint8                                   InCorporationIndex                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerTryClaimReward(uint8 InCorporationIndex, int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerTryClaimReward");

	Params::CrPlayerControllerBase_ServerTryClaimReward Parms{};

	Parms.InCorporationIndex = InCorporationIndex;
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerUnselectPlayerProfessionViaType
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// EProfessionType                         InSelectedProfession                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerUnselectPlayerProfessionViaType(EProfessionType InSelectedProfession)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerUnselectPlayerProfessionViaType");

	Params::CrPlayerControllerBase_ServerUnselectPlayerProfessionViaType Parms{};

	Parms.InSelectedProfession = InSelectedProfession;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ServerUnselectPreviousPlayerProfession
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// int32                                   InPlayerId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerUnselectPreviousPlayerProfession(int32 InPlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerUnselectPreviousPlayerProfession");

	Params::CrPlayerControllerBase_ServerUnselectPreviousPlayerProfession Parms{};

	Parms.InPlayerId = InPlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SetCurrentDeconstructible
// (Final, Native, Public)
// Parameters:
// class AActor*                           Deconstructible                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::SetCurrentDeconstructible(class AActor* Deconstructible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SetCurrentDeconstructible");

	Params::CrPlayerControllerBase_SetCurrentDeconstructible Parms{};

	Parms.Deconstructible = Deconstructible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SetOpenGameMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bOpen                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::SetOpenGameMenu(bool bOpen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SetOpenGameMenu");

	Params::CrPlayerControllerBase_SetOpenGameMenu Parms{};

	Parms.bOpen = bOpen;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SetPlacementMode
// (Native, Public)
// Parameters:
// bool                                    bTerrain                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::SetPlacementMode(bool bTerrain)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SetPlacementMode");

	Params::CrPlayerControllerBase_SetPlacementMode Parms{};

	Parms.bTerrain = bTerrain;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ShowProfessionMenuOnClient
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)

void ACrPlayerControllerBase::ShowProfessionMenuOnClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ShowProfessionMenuOnClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.SimulateInputKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FKey&                      Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bPressed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::SimulateInputKey(const struct FKey& Key, bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "SimulateInputKey");

	Params::CrPlayerControllerBase_SimulateInputKey Parms{};

	Parms.Key = std::move(Key);
	Parms.bPressed = bPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.StartBuilding
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UAuActorPlacementData*            InPlacementData                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrBuildingBeginPlayData&  BeginPlayData                                          (Parm, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::StartBuilding(class UAuActorPlacementData* InPlacementData, const struct FCrBuildingBeginPlayData& BeginPlayData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "StartBuilding");

	Params::CrPlayerControllerBase_StartBuilding Parms{};

	Parms.InPlacementData = InPlacementData;
	Parms.BeginPlayData = std::move(BeginPlayData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.StartPlacementMode
// (Net, NetReliable, Native, Event, Public, NetClient)

void ACrPlayerControllerBase::StartPlacementMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "StartPlacementMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ToggleCamera
// (Final, Exec, Native, Public)

void ACrPlayerControllerBase::ToggleCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ToggleCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.ToggleDeconstructMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bChangedWeapon                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ToggleDeconstructMode(bool bChangedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ToggleDeconstructMode");

	Params::CrPlayerControllerBase_ToggleDeconstructMode Parms{};

	Parms.bChangedWeapon = bChangedWeapon;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.UnblockGameMenu
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    Caller                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::UnblockGameMenu(const class UObject* Caller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "UnblockGameMenu");

	Params::CrPlayerControllerBase_UnblockGameMenu Parms{};

	Parms.Caller = Caller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerControllerBase.AreSubtitlesEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrPlayerControllerBase::AreSubtitlesEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "AreSubtitlesEnabled");

	Params::CrPlayerControllerBase_AreSubtitlesEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.CanTriggerDeconstruct
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrPlayerControllerBase::CanTriggerDeconstruct() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "CanTriggerDeconstruct");

	Params::CrPlayerControllerBase_CanTriggerDeconstruct Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.GetCBStatus
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ACrPlayerControllerBase::GetCBStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "GetCBStatus");

	Params::CrPlayerControllerBase_GetCBStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.GetCurrentDeconstructible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACrPlayerControllerBase::GetCurrentDeconstructible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "GetCurrentDeconstructible");

	Params::CrPlayerControllerBase_GetCurrentDeconstructible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.GetCurrentInteractable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ACrPlayerControllerBase::GetCurrentInteractable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "GetCurrentInteractable");

	Params::CrPlayerControllerBase_GetCurrentInteractable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.GetPlayerControlState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECrPlayerControlState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrPlayerControlState ACrPlayerControllerBase::GetPlayerControlState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "GetPlayerControlState");

	Params::CrPlayerControllerBase_GetPlayerControlState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerControllerBase.ServerDebugSpawnDebugAiSpawner
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, Const)
// Parameters:
// const TSoftClassPtr<class UClass>&      SoftClass                                              (ConstParm, Parm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotator                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACrPlayerControllerBase::ServerDebugSpawnDebugAiSpawner(const TSoftClassPtr<class UClass>& SoftClass, const struct FVector& Location, const struct FRotator& Rotator) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerControllerBase", "ServerDebugSpawnDebugAiSpawner");

	Params::CrPlayerControllerBase_ServerDebugSpawnDebugAiSpawner Parms{};

	Parms.SoftClass = SoftClass;
	Parms.Location = std::move(Location);
	Parms.Rotator = std::move(Rotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInteractionInterface.K2_GetInteractionActionText
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ICrInteractionInterface::K2_GetInteractionActionText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrInteractionInterface", "K2_GetInteractionActionText");

	Params::CrInteractionInterface_K2_GetInteractionActionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractionInterface.K2_GetInteractionProgress
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrInteractionInterface::K2_GetInteractionProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrInteractionInterface", "K2_GetInteractionProgress");

	Params::CrInteractionInterface_K2_GetInteractionProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractionInterface.K2_GetInteractionText
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ICrInteractionInterface::K2_GetInteractionText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrInteractionInterface", "K2_GetInteractionText");

	Params::CrInteractionInterface_K2_GetInteractionText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractionInterface.K2_GetRequiredInteractionDuration
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrInteractionInterface::K2_GetRequiredInteractionDuration(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrInteractionInterface", "K2_GetRequiredInteractionDuration");

	Params::CrInteractionInterface_K2_GetRequiredInteractionDuration Parms{};

	Parms.InPc = InPc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractionInterface.GetItemRequiredForInteraction
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UAuItemDataBase>*     OutRequiredItem                                        (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrInteractionInterface::GetItemRequiredForInteraction(TSubclassOf<class UAuItemDataBase>* OutRequiredItem) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrInteractionInterface", "GetItemRequiredForInteraction");

	Params::CrInteractionInterface_GetItemRequiredForInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRequiredItem != nullptr)
		*OutRequiredItem = Parms.OutRequiredItem;

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractionInterface.GetItemsRequiredForInteraction
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<TSubclassOf<class UAuItemDataBase>>*OutRequiredItems                                       (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrInteractionInterface::GetItemsRequiredForInteraction(TArray<TSubclassOf<class UAuItemDataBase>>* OutRequiredItems) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrInteractionInterface", "GetItemsRequiredForInteraction");

	Params::CrInteractionInterface_GetItemsRequiredForInteraction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRequiredItems != nullptr)
		*OutRequiredItems = std::move(Parms.OutRequiredItems);

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractionInterface.HasCustomInteractionWidget
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UUserWidget>*         OutInteractionWidget                                   (Parm, OutParm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrInteractionInterface::HasCustomInteractionWidget(TSubclassOf<class UUserWidget>* OutInteractionWidget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrInteractionInterface", "HasCustomInteractionWidget");

	Params::CrInteractionInterface_HasCustomInteractionWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutInteractionWidget != nullptr)
		*OutInteractionWidget = Parms.OutInteractionWidget;

	return Parms.ReturnValue;
}


// Function Chimera.CrInteractiveFunBox.K2_OnInteract
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInteractiveFunBox::K2_OnInteract(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractiveFunBox", "K2_OnInteract");

	Params::CrInteractiveFunBox_K2_OnInteract Parms{};

	Parms.InPc = InPc;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrInteractiveFunBox.MulticastInteract
// (Net, Native, Event, NetMulticast, Protected)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrInteractiveFunBox::MulticastInteract(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractiveFunBox", "MulticastInteract");

	Params::CrInteractiveFunBox_MulticastInteract Parms{};

	Parms.InPc = InPc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrInteractiveFunBox.OnRep_IsOpen
// (Final, Native, Protected)

void ACrInteractiveFunBox::OnRep_IsOpen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrInteractiveFunBox", "OnRep_IsOpen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrItemPickupGeneric.OnRep_ItemClass
// (Final, Native, Private)

void ACrItemPickupGeneric::OnRep_ItemClass()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrItemPickupGeneric", "OnRep_ItemClass");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrItemRecipeCollection.GetRecipes
// (Final, Native, Public, Const)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UCrItemRecipeData*>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCrItemRecipeData*> UCrItemRecipeCollection::GetRecipes(const class UObject* WorldContextObject) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrItemRecipeCollection", "GetRecipes");

	Params::CrItemRecipeCollection_GetRecipes Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrItemSenderBuilding.OnItemsSent
// (Event, Public, BlueprintEvent)

void ACrItemSenderBuilding::OnItemsSent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrItemSenderBuilding", "OnItemsSent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrLocalizedInteractiveActor.OnPostBecameInsignificant
// (Event, Public, BlueprintEvent)

void ACrLocalizedInteractiveActor::OnPostBecameInsignificant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrLocalizedInteractiveActor", "OnPostBecameInsignificant");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrLocalizedInteractiveActor.OnPostBecameSignificant
// (Event, Public, BlueprintEvent)

void ACrLocalizedInteractiveActor::OnPostBecameSignificant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrLocalizedInteractiveActor", "OnPostBecameSignificant");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrMapMenuDataReplicationHelper.OnRep_PointOfInterestReplicationData
// (Final, Native, Private)

void ACrMapMenuDataReplicationHelper::OnRep_PointOfInterestReplicationData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMapMenuDataReplicationHelper", "OnRep_PointOfInterestReplicationData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMapMenuDataReplicationHelper.SendMapWarningLocations
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// const TArray<struct FVector3f>&         Locations                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACrMapMenuDataReplicationHelper::SendMapWarningLocations(const TArray<struct FVector3f>& Locations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMapMenuDataReplicationHelper", "SendMapWarningLocations");

	Params::CrMapMenuDataReplicationHelper_SendMapWarningLocations Parms{};

	Parms.Locations = std::move(Locations);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBordersSubsystem.GetRadiationLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrRadiationBordersSubsystem::GetRadiationLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBordersSubsystem", "GetRadiationLevel");

	Params::CrRadiationBordersSubsystem_GetRadiationLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrRadiationBordersSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrRadiationBordersSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBordersSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBordersSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrRadiationBordersSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBordersSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBordersSubsystem.SetRadiationLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewRadiationLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrRadiationBordersSubsystem::SetRadiationLevel(int32 NewRadiationLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBordersSubsystem", "SetRadiationLevel");

	Params::CrRadiationBordersSubsystem_SetRadiationLevel Parms{};

	Parms.NewRadiationLevel = NewRadiationLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBordersSubsystem.SetRadiationLevelImmediately
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewRadiationLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrRadiationBordersSubsystem::SetRadiationLevelImmediately(int32 NewRadiationLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBordersSubsystem", "SetRadiationLevelImmediately");

	Params::CrRadiationBordersSubsystem_SetRadiationLevelImmediately Parms{};

	Parms.NewRadiationLevel = NewRadiationLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBordersSubsystem.GetDataLayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWorld*                           Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RadiationLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UDataLayerInstance*         ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDataLayerInstance* UCrRadiationBordersSubsystem::GetDataLayer(class UWorld* Context, int32 RadiationLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBordersSubsystem", "GetDataLayer");

	Params::CrRadiationBordersSubsystem_GetDataLayer Parms{};

	Parms.Context = Context;
	Parms.RadiationLevel = RadiationLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetAntiAliasingMode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetAntiAliasingMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetAntiAliasingMode");

	Params::CrScalabialityQualityActor_GetAntiAliasingMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetAntiAliasingQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetAntiAliasingQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetAntiAliasingQuality");

	Params::CrScalabialityQualityActor_GetAntiAliasingQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetEffectsQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetEffectsQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetEffectsQuality");

	Params::CrScalabialityQualityActor_GetEffectsQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetFoliageQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetFoliageQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetFoliageQuality");

	Params::CrScalabialityQualityActor_GetFoliageQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetGlobalIlluminationQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetGlobalIlluminationQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetGlobalIlluminationQuality");

	Params::CrScalabialityQualityActor_GetGlobalIlluminationQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetLandscapeQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetLandscapeQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetLandscapeQuality");

	Params::CrScalabialityQualityActor_GetLandscapeQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetPostProcessQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetPostProcessQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetPostProcessQuality");

	Params::CrScalabialityQualityActor_GetPostProcessQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetReflectionQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetReflectionQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetReflectionQuality");

	Params::CrScalabialityQualityActor_GetReflectionQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetResolutionQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetResolutionQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetResolutionQuality");

	Params::CrScalabialityQualityActor_GetResolutionQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetShadingQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetShadingQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetShadingQuality");

	Params::CrScalabialityQualityActor_GetShadingQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetShadowQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetShadowQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetShadowQuality");

	Params::CrScalabialityQualityActor_GetShadowQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetTextureQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetTextureQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetTextureQuality");

	Params::CrScalabialityQualityActor_GetTextureQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.GetViewQuality
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACrScalabialityQualityActor::GetViewQuality()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrScalabialityQualityActor", "GetViewQuality");

	Params::CrScalabialityQualityActor_GetViewQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrScalabialityQualityActor.OnAntiAliasingModeChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Mode                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnAntiAliasingModeChanged(int32 Mode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnAntiAliasingModeChanged");

	Params::CrScalabialityQualityActor_OnAntiAliasingModeChanged Parms{};

	Parms.Mode = Mode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnAntiAliasingQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnAntiAliasingQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnAntiAliasingQualityChanged");

	Params::CrScalabialityQualityActor_OnAntiAliasingQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnCameraModeChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bFirstPersonView                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnCameraModeChanged(bool bFirstPersonView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnCameraModeChanged");

	Params::CrScalabialityQualityActor_OnCameraModeChanged Parms{};

	Parms.bFirstPersonView = bFirstPersonView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnEffectsQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnEffectsQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnEffectsQualityChanged");

	Params::CrScalabialityQualityActor_OnEffectsQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnFoliageQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnFoliageQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnFoliageQualityChanged");

	Params::CrScalabialityQualityActor_OnFoliageQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnGlobalIlluminationQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnGlobalIlluminationQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnGlobalIlluminationQualityChanged");

	Params::CrScalabialityQualityActor_OnGlobalIlluminationQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnLandscapeQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnLandscapeQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnLandscapeQualityChanged");

	Params::CrScalabialityQualityActor_OnLandscapeQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnPostProcessQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnPostProcessQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnPostProcessQualityChanged");

	Params::CrScalabialityQualityActor_OnPostProcessQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnReflectionQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnReflectionQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnReflectionQualityChanged");

	Params::CrScalabialityQualityActor_OnReflectionQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnResolutionQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnResolutionQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnResolutionQualityChanged");

	Params::CrScalabialityQualityActor_OnResolutionQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnShadingQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnShadingQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnShadingQualityChanged");

	Params::CrScalabialityQualityActor_OnShadingQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnShadowQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnShadowQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnShadowQualityChanged");

	Params::CrScalabialityQualityActor_OnShadowQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnTextureQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnTextureQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnTextureQualityChanged");

	Params::CrScalabialityQualityActor_OnTextureQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrScalabialityQualityActor.OnViewQualityChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrScalabialityQualityActor::OnViewQualityChanged(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrScalabialityQualityActor", "OnViewQualityChanged");

	Params::CrScalabialityQualityActor_OnViewQualityChanged Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassBuildingNiagaraSignalProcessor.GetAvailableSignalValues
// (Final, Native, Static, Public)
// Parameters:
// const TArray<class FName>               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class FName> UCrMassBuildingNiagaraSignalProcessor::GetAvailableSignalValues()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrMassBuildingNiagaraSignalProcessor", "GetAvailableSignalValues");

	Params::CrMassBuildingNiagaraSignalProcessor_GetAvailableSignalValues Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.GEBoxComponent.SetTriggerEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bNewEnabled                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGEBoxComponent::SetTriggerEnabled(bool bNewEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GEBoxComponent", "SetTriggerEnabled");

	Params::GEBoxComponent_SetTriggerEnabled Parms{};

	Parms.bNewEnabled = bNewEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.GEBoxComponent.GetTriggerEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGEBoxComponent::GetTriggerEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GEBoxComponent", "GetTriggerEnabled");

	Params::GEBoxComponent_GetTriggerEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassCustomOnRepInterface.OnRep_CustomState
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FInstancedStruct&          CustomFragment                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ICrMassCustomOnRepInterface::OnRep_CustomState(const struct FInstancedStruct& CustomFragment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassCustomOnRepInterface", "OnRep_CustomState");

	Params::CrMassCustomOnRepInterface_OnRep_CustomState Parms{};

	Parms.CustomFragment = std::move(CustomFragment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrUW_BuildingCostEntry.OnRequirementsMetChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bRequirementsMet                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrUW_BuildingCostEntry::OnRequirementsMetChanged(bool bRequirementsMet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrUW_BuildingCostEntry", "OnRequirementsMetChanged");

	Params::CrUW_BuildingCostEntry_OnRequirementsMetChanged Parms{};

	Parms.bRequirementsMet = bRequirementsMet;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrSimpleSplineActor.UpdateSpline
// (Final, Native, Protected, BlueprintCallable)

void ACrSimpleSplineActor::UpdateSpline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSimpleSplineActor", "UpdateSpline");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeatherSubsystem.BlendTemperature
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeatherSubsystem::BlendTemperature(const struct FVector& InLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeatherSubsystem", "BlendTemperature");

	Params::CrWeatherSubsystem_BlendTemperature Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWorldSpawnerSubsystem.OnEnviroWaveActivateSpawnersChanged
// (Final, Native, Public)
// Parameters:
// bool                                    bIsSpawnersActive                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWorldSpawnerSubsystem::OnEnviroWaveActivateSpawnersChanged(bool bIsSpawnersActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWorldSpawnerSubsystem", "OnEnviroWaveActivateSpawnersChanged");

	Params::CrWorldSpawnerSubsystem_OnEnviroWaveActivateSpawnersChanged Parms{};

	Parms.bIsSpawnersActive = bIsSpawnersActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWorldSpawnerSubsystem.OnEnviroWaveSubsystemActivated
// (Final, Native, Public)

void UCrWorldSpawnerSubsystem::OnEnviroWaveSubsystemActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWorldSpawnerSubsystem", "OnEnviroWaveSubsystemActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBillboard.ValidateForStaticSwitch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UMaterialInstance*                Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ParameterName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrRadiationBillboard::ValidateForStaticSwitch(class UMaterialInstance* Instance, class FName ParameterName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrRadiationBillboard", "ValidateForStaticSwitch");

	Params::CrRadiationBillboard_ValidateForStaticSwitch Parms{};

	Parms.Instance = Instance;
	Parms.ParameterName = ParameterName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrRadiationBillboard.SetupPrimitiveData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   Mesh                                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRadiationBillboardPrimitiveData&Data                                                   (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void ACrRadiationBillboard::SetupPrimitiveData(class UMeshComponent* Mesh, const struct FRadiationBillboardPrimitiveData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBillboard", "SetupPrimitiveData");

	Params::CrRadiationBillboard_SetupPrimitiveData Parms{};

	Parms.Mesh = Mesh;
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBillboard.ValidateSetup
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMaterialInterface*               ParentMaterial                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StaticSwitchName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrRadiationBillboard::ValidateSetup(class UMaterialInterface* ParentMaterial, class UMaterialInstance* Instance, class FName StaticSwitchName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBillboard", "ValidateSetup");

	Params::CrRadiationBillboard_ValidateSetup Parms{};

	Parms.ParentMaterial = ParentMaterial;
	Parms.Instance = Instance;
	Parms.StaticSwitchName = StaticSwitchName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassInfectionSubsystem.IsInfectionValid
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInfectionEntityHandle&    InfectionEntityHandle                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrMassInfectionSubsystem::IsInfectionValid(const struct FInfectionEntityHandle& InfectionEntityHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassInfectionSubsystem", "IsInfectionValid");

	Params::CrMassInfectionSubsystem_IsInfectionValid Parms{};

	Parms.InfectionEntityHandle = std::move(InfectionEntityHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassInfectionSubsystem.RemoveInfection
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FInfectionEntityHandle&    InfectionEntityHandle                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCrMassInfectionSubsystem::RemoveInfection(const struct FInfectionEntityHandle& InfectionEntityHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassInfectionSubsystem", "RemoveInfection");

	Params::CrMassInfectionSubsystem_RemoveInfection Parms{};

	Parms.InfectionEntityHandle = std::move(InfectionEntityHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassInfectionSubsystem.SpawnInfectionAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FAuAPMassSpawnedEntityType&EntityType                                             (Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  Rotation                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FInfectionCollisionData&   InfectionCollisionData                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FInfectionEntityHandle&    AttachToBaseCore                                       (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TDelegate<void(const struct FInfectionEntityHandle& InfectionEntityHandle)>OnInfectionEntityCreatedEvent                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInfectionEntityHandle           ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FInfectionEntityHandle UCrMassInfectionSubsystem::SpawnInfectionAtLocation(const struct FAuAPMassSpawnedEntityType& EntityType, const struct FVector& Location, const struct FRotator& Rotation, const struct FInfectionCollisionData& InfectionCollisionData, const struct FInfectionEntityHandle& AttachToBaseCore, TDelegate<void(const struct FInfectionEntityHandle& InfectionEntityHandle)> OnInfectionEntityCreatedEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassInfectionSubsystem", "SpawnInfectionAtLocation");

	Params::CrMassInfectionSubsystem_SpawnInfectionAtLocation Parms{};

	Parms.EntityType = std::move(EntityType);
	Parms.Location = std::move(Location);
	Parms.Rotation = std::move(Rotation);
	Parms.InfectionCollisionData = std::move(InfectionCollisionData);
	Parms.AttachToBaseCore = std::move(AttachToBaseCore);
	Parms.OnInfectionEntityCreatedEvent = OnInfectionEntityCreatedEvent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrAT_WaitReloadWeapon.CrWaitReloadWeapon
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              InEffectTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAT_WaitReloadWeapon*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAT_WaitReloadWeapon* UCrAT_WaitReloadWeapon::CrWaitReloadWeapon(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, const struct FGameplayTag& InEffectTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAT_WaitReloadWeapon", "CrWaitReloadWeapon");

	Params::CrAT_WaitReloadWeapon_CrWaitReloadWeapon Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.InEffectTag = std::move(InEffectTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.OnPiercingCommitedCosmetics
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuTargetData&             InHitResults                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::OnPiercingCommitedCosmetics(class UGameplayAbility* Ability, const struct FAuTargetData& InHitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrWeaponComponent", "OnPiercingCommitedCosmetics");

	Params::CrWeaponComponent_OnPiercingCommitedCosmetics Parms{};

	Parms.Ability = Ability;
	Parms.InHitResults = std::move(InHitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.AddWeaponItemInfoToEffectContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayEffectContextHandle&EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// const struct FAuItemSlot&               Slot                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::AddWeaponItemInfoToEffectContext(const struct FGameplayEffectContextHandle& EffectContext, const struct FAuItemSlot& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "AddWeaponItemInfoToEffectContext");

	Params::CrWeaponComponent_AddWeaponItemInfoToEffectContext Parms{};

	Parms.EffectContext = std::move(EffectContext);
	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.AddWeaponModsToCurrentWeapon
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TMap<struct FGameplayTag, TSoftObjectPtr<class UCrWeaponModDataAsset>>&ModsToApply                                            (Parm, UObjectWrapper, NativeAccessSpecifierPublic)

void UCrWeaponComponent::AddWeaponModsToCurrentWeapon(const TMap<struct FGameplayTag, TSoftObjectPtr<class UCrWeaponModDataAsset>>& ModsToApply)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "AddWeaponModsToCurrentWeapon");

	Params::CrWeaponComponent_AddWeaponModsToCurrentWeapon Parms{};

	Parms.ModsToApply = std::move(ModsToApply);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.BP_ResetRelaxedState
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::BP_ResetRelaxedState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "BP_ResetRelaxedState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.BP_StopFire
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::BP_StopFire()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "BP_StopFire");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.DetachOnUnequip
// (Final, Native, Private)
// Parameters:
// const struct FAuEquippedWeapon&         dupa                                                   (Parm, NativeAccessSpecifierPublic)
// const struct FAuEquippedWeapon&         OldEquippedWeapon                                      (Parm, NativeAccessSpecifierPublic)

void UCrWeaponComponent::DetachOnUnequip(const struct FAuEquippedWeapon& dupa, const struct FAuEquippedWeapon& OldEquippedWeapon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "DetachOnUnequip");

	Params::CrWeaponComponent_DetachOnUnequip Parms{};

	Parms.dupa = std::move(dupa);
	Parms.OldEquippedWeapon = std::move(OldEquippedWeapon);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.DisableCurrentWeaponMods
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::DisableCurrentWeaponMods()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "DisableCurrentWeaponMods");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.EnableCurrentWeaponMods
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::EnableCurrentWeaponMods()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "EnableCurrentWeaponMods");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.EquipLastWeapon
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::EquipLastWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "EquipLastWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.FindWeaponSlotFromType
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UCrWeaponItemDataBase*      WeaponItemDataBase                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAuItemSlot*                     OutFoundSlot                                           (Parm, OutParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrWeaponComponent::FindWeaponSlotFromType(const class UCrWeaponItemDataBase* WeaponItemDataBase, struct FAuItemSlot* OutFoundSlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "FindWeaponSlotFromType");

	Params::CrWeaponComponent_FindWeaponSlotFromType Parms{};

	Parms.WeaponItemDataBase = WeaponItemDataBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFoundSlot != nullptr)
		*OutFoundSlot = std::move(Parms.OutFoundSlot);

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetAppliedModsToWeapon
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAuItemId&                 WeaponId                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, TSoftObjectPtr<class UCrWeaponModDataAsset>>*OutMods                                                (Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)

void UCrWeaponComponent::GetAppliedModsToWeapon(const struct FAuItemId& WeaponId, TMap<struct FGameplayTag, TSoftObjectPtr<class UCrWeaponModDataAsset>>* OutMods)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetAppliedModsToWeapon");

	Params::CrWeaponComponent_GetAppliedModsToWeapon Parms{};

	Parms.WeaponId = std::move(WeaponId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMods != nullptr)
		*OutMods = std::move(Parms.OutMods);
}


// Function Chimera.CrWeaponComponent.GetAppliedModsToWeaponByWeaponItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class UCrWeaponItemDataBase*      WeaponItemData                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, TSoftObjectPtr<class UCrWeaponModDataAsset>>*OutMods                                                (Parm, OutParm, UObjectWrapper, NativeAccessSpecifierPublic)

void UCrWeaponComponent::GetAppliedModsToWeaponByWeaponItem(const class UCrWeaponItemDataBase* WeaponItemData, TMap<struct FGameplayTag, TSoftObjectPtr<class UCrWeaponModDataAsset>>* OutMods)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetAppliedModsToWeaponByWeaponItem");

	Params::CrWeaponComponent_GetAppliedModsToWeaponByWeaponItem Parms{};

	Parms.WeaponItemData = WeaponItemData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutMods != nullptr)
		*OutMods = std::move(Parms.OutMods);
}


// Function Chimera.CrWeaponComponent.GetCurrentWeaponItemHandleAsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UCrWeaponComponent::GetCurrentWeaponItemHandleAsString()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetCurrentWeaponItemHandleAsString");

	Params::CrWeaponComponent_GetCurrentWeaponItemHandleAsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetCurrentWeaponItemId
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAuItemId                        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuItemId UCrWeaponComponent::GetCurrentWeaponItemId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetCurrentWeaponItemId");

	Params::CrWeaponComponent_GetCurrentWeaponItemId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetEquippedWeaponActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrWeaponActor*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACrWeaponActor* UCrWeaponComponent::GetEquippedWeaponActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetEquippedWeaponActor");

	Params::CrWeaponComponent_GetEquippedWeaponActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetEquippedWeaponAmmoInInventory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::GetEquippedWeaponAmmoInInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetEquippedWeaponAmmoInInventory");

	Params::CrWeaponComponent_GetEquippedWeaponAmmoInInventory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetEquippedWeaponCurrentAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::GetEquippedWeaponCurrentAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetEquippedWeaponCurrentAmmo");

	Params::CrWeaponComponent_GetEquippedWeaponCurrentAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetEquippedWeaponMaxAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::GetEquippedWeaponMaxAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetEquippedWeaponMaxAmmo");

	Params::CrWeaponComponent_GetEquippedWeaponMaxAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetHarvesterData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCrHarvesterItemInstance*        OutData                                                (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrWeaponComponent::GetHarvesterData(struct FCrHarvesterItemInstance* OutData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetHarvesterData");

	Params::CrWeaponComponent_GetHarvesterData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutData != nullptr)
		*OutData = std::move(Parms.OutData);

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetPossibleEnemiesHitPerTrace
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrWeaponComponent::GetPossibleEnemiesHitPerTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetPossibleEnemiesHitPerTrace");

	Params::CrWeaponComponent_GetPossibleEnemiesHitPerTrace Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.InputWeaponPrimaryFirePressed
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              FireTag                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::InputWeaponPrimaryFirePressed(const struct FGameplayTag& FireTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "InputWeaponPrimaryFirePressed");

	Params::CrWeaponComponent_InputWeaponPrimaryFirePressed Parms{};

	Parms.FireTag = std::move(FireTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.InputWeaponReloadPressed
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::InputWeaponReloadPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "InputWeaponReloadPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.IsFireInputDown
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrWeaponComponent::IsFireInputDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "IsFireInputDown");

	Params::CrWeaponComponent_IsFireInputDown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.K2_ReattachAllWeapons
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::K2_ReattachAllWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "K2_ReattachAllWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.LogCurrentWeaponModsModifiers
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::LogCurrentWeaponModsModifiers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "LogCurrentWeaponModsModifiers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.OnWeaponFullyEquipped
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::OnWeaponFullyEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "OnWeaponFullyEquipped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.RemoveAllWeaponModsFromCurrentWeapon
// (Final, Native, Public, BlueprintCallable)

void UCrWeaponComponent::RemoveAllWeaponModsFromCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "RemoveAllWeaponModsFromCurrentWeapon");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.RemoveWeaponItemFromSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               Slot                                                   (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::RemoveWeaponItemFromSlot(const struct FAuItemSlot& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "RemoveWeaponItemFromSlot");

	Params::CrWeaponComponent_RemoveWeaponItemFromSlot Parms{};

	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.Server_ApplyModToWeaponByName
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    ModName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    WeaponName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::Server_ApplyModToWeaponByName(const class FString& ModName, const class FString& WeaponName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "Server_ApplyModToWeaponByName");

	Params::CrWeaponComponent_Server_ApplyModToWeaponByName Parms{};

	Parms.ModName = std::move(ModName);
	Parms.WeaponName = std::move(WeaponName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.Server_ApplyRifleMod
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// const class FString&                    ModName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::Server_ApplyRifleMod(const class FString& ModName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "Server_ApplyRifleMod");

	Params::CrWeaponComponent_Server_ApplyRifleMod Parms{};

	Parms.ModName = std::move(ModName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerAddWeaponMod
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FAuItemId&                 WeaponItemId                                           (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UCrWeaponModDataAsset>&ModAsset                                               (ConstParm, Parm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::ServerAddWeaponMod(const struct FAuItemId& WeaponItemId, const struct FGameplayTag& Slot, const TSoftObjectPtr<class UCrWeaponModDataAsset>& ModAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerAddWeaponMod");

	Params::CrWeaponComponent_ServerAddWeaponMod Parms{};

	Parms.WeaponItemId = std::move(WeaponItemId);
	Parms.Slot = std::move(Slot);
	Parms.ModAsset = ModAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerAddWeaponModByWeaponItem
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const class UCrWeaponItemDataBase*      WeaponItem                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UCrWeaponModDataAsset>&ModAsset                                               (ConstParm, Parm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::ServerAddWeaponModByWeaponItem(const class UCrWeaponItemDataBase* WeaponItem, const struct FGameplayTag& Slot, const TSoftObjectPtr<class UCrWeaponModDataAsset>& ModAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerAddWeaponModByWeaponItem");

	Params::CrWeaponComponent_ServerAddWeaponModByWeaponItem Parms{};

	Parms.WeaponItem = WeaponItem;
	Parms.Slot = std::move(Slot);
	Parms.ModAsset = ModAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerAddWeaponModToSlot
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               WeaponSlot                                             (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UCrWeaponModDataAsset>&ModAsset                                               (ConstParm, Parm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::ServerAddWeaponModToSlot(const struct FAuItemSlot& WeaponSlot, const struct FGameplayTag& Slot, const TSoftObjectPtr<class UCrWeaponModDataAsset>& ModAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerAddWeaponModToSlot");

	Params::CrWeaponComponent_ServerAddWeaponModToSlot Parms{};

	Parms.WeaponSlot = std::move(WeaponSlot);
	Parms.Slot = std::move(Slot);
	Parms.ModAsset = ModAsset;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerMoveMagAmmoToInventoryFromWeaponOnSlot
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// const struct FAuItemSlot&               Slot                                                   (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::ServerMoveMagAmmoToInventoryFromWeaponOnSlot(const struct FAuItemSlot& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerMoveMagAmmoToInventoryFromWeaponOnSlot");

	Params::CrWeaponComponent_ServerMoveMagAmmoToInventoryFromWeaponOnSlot Parms{};

	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerOnADSReleased
// (Final, Net, Native, Event, Private, NetServer)

void UCrWeaponComponent::ServerOnADSReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerOnADSReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerOnReloadInterrupted
// (Final, Net, Native, Event, Private, NetServer)

void UCrWeaponComponent::ServerOnReloadInterrupted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerOnReloadInterrupted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerTryToTriggerReload
// (Net, NetReliable, Native, Event, Public, NetServer)

void UCrWeaponComponent::ServerTryToTriggerReload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerTryToTriggerReload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerUnlockMod
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrWeaponModBlueprintItemBase>ModBlueprint                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAuItemDataBase>      ItemToken                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::ServerUnlockMod(TSubclassOf<class UCrWeaponModBlueprintItemBase> ModBlueprint, TSubclassOf<class UAuItemDataBase> ItemToken, int32 Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerUnlockMod");

	Params::CrWeaponComponent_ServerUnlockMod Parms{};

	Parms.ModBlueprint = ModBlueprint;
	Parms.ItemToken = ItemToken;
	Parms.Cost = Cost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.ServerUnlockWeapon
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrWeaponItemDataBase>WeaponClass                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UAuItemDataBase>      ItemToken                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::ServerUnlockWeapon(TSubclassOf<class UCrWeaponItemDataBase> WeaponClass, TSubclassOf<class UAuItemDataBase> ItemToken, int32 Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ServerUnlockWeapon");

	Params::CrWeaponComponent_ServerUnlockWeapon Parms{};

	Parms.WeaponClass = WeaponClass;
	Parms.ItemToken = ItemToken;
	Parms.Cost = Cost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.SetEquippedWeaponCurrentAmmo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewCurrent                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrWeaponComponent::SetEquippedWeaponCurrentAmmo(float NewCurrent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "SetEquippedWeaponCurrentAmmo");

	Params::CrWeaponComponent_SetEquippedWeaponCurrentAmmo Parms{};

	Parms.NewCurrent = NewCurrent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.SetHarvesterData
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// const struct FCrHarvesterItemInstance&  NewData                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrWeaponComponent::SetHarvesterData(const struct FCrHarvesterItemInstance& NewData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "SetHarvesterData");

	Params::CrWeaponComponent_SetHarvesterData Parms{};

	Parms.NewData = std::move(NewData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.ShouldCurrentWeaponSlideBeBack
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrWeaponComponent::ShouldCurrentWeaponSlideBeBack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "ShouldCurrentWeaponSlideBeBack");

	Params::CrWeaponComponent_ShouldCurrentWeaponSlideBeBack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.TryToTriggerReload
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsTriggeredFromAbility                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrWeaponComponent::TryToTriggerReload(bool bIsTriggeredFromAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "TryToTriggerReload");

	Params::CrWeaponComponent_TryToTriggerReload Parms{};

	Parms.bIsTriggeredFromAbility = bIsTriggeredFromAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponComponent.WasFirstShotExecutedInCurrentWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrWeaponComponent::WasFirstShotExecutedInCurrentWeapon()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "WasFirstShotExecutedInCurrentWeapon");

	Params::CrWeaponComponent_WasFirstShotExecutedInCurrentWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.BP_GetEquippedWeaponFireRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::BP_GetEquippedWeaponFireRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "BP_GetEquippedWeaponFireRate");

	Params::CrWeaponComponent_BP_GetEquippedWeaponFireRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.CanUnquipWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrWeaponComponent::CanUnquipWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "CanUnquipWeapon");

	Params::CrWeaponComponent_CanUnquipWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetADSFppAutoFireEmptyMagMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetADSFppAutoFireEmptyMagMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetADSFppAutoFireEmptyMagMontage");

	Params::CrWeaponComponent_GetADSFppAutoFireEmptyMagMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetCurrentWeaponDefaultData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UCrWeaponItemDataBase*      ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCrWeaponItemDataBase* UCrWeaponComponent::GetCurrentWeaponDefaultData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetCurrentWeaponDefaultData");

	Params::CrWeaponComponent_GetCurrentWeaponDefaultData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetEquippedWeaponFireAnimPlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::GetEquippedWeaponFireAnimPlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetEquippedWeaponFireAnimPlayRate");

	Params::CrWeaponComponent_GetEquippedWeaponFireAnimPlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetEquippedWeaponMaxMagazineAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::GetEquippedWeaponMaxMagazineAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetEquippedWeaponMaxMagazineAmmo");

	Params::CrWeaponComponent_GetEquippedWeaponMaxMagazineAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetEquippedWeaponSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAuItemSlot                      ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FAuItemSlot UCrWeaponComponent::GetEquippedWeaponSlot() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetEquippedWeaponSlot");

	Params::CrWeaponComponent_GetEquippedWeaponSlot Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetFppAutoFireADSMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetFppAutoFireADSMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetFppAutoFireADSMontage");

	Params::CrWeaponComponent_GetFppAutoFireADSMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetFppAutoFireEmptyMagMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetFppAutoFireEmptyMagMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetFppAutoFireEmptyMagMontage");

	Params::CrWeaponComponent_GetFppAutoFireEmptyMagMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetFppAutoFireMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetFppAutoFireMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetFppAutoFireMontage");

	Params::CrWeaponComponent_GetFppAutoFireMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetFppReloadEmptyMagMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetFppReloadEmptyMagMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetFppReloadEmptyMagMontage");

	Params::CrWeaponComponent_GetFppReloadEmptyMagMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetFppReloadMontage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetFppReloadMontage(const struct FGameplayTagContainer& CosmeticTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetFppReloadMontage");

	Params::CrWeaponComponent_GetFppReloadMontage Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetFppSingleFireADSMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetFppSingleFireADSMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetFppSingleFireADSMontage");

	Params::CrWeaponComponent_GetFppSingleFireADSMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetFppSingleFireMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetFppSingleFireMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetFppSingleFireMontage");

	Params::CrWeaponComponent_GetFppSingleFireMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetFppUnEquipMontage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetFppUnEquipMontage(const struct FGameplayTagContainer& CosmeticTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetFppUnEquipMontage");

	Params::CrWeaponComponent_GetFppUnEquipMontage Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetReloadMontagePlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::GetReloadMontagePlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetReloadMontagePlayRate");

	Params::CrWeaponComponent_GetReloadMontagePlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetSingleBulletReloadMontagePlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             IntroSectionName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             LoopSectionName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AfterLoopWindupSectionName                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             OutroSectionName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::GetSingleBulletReloadMontagePlayRate(class FName IntroSectionName, class FName LoopSectionName, class FName AfterLoopWindupSectionName, class FName OutroSectionName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetSingleBulletReloadMontagePlayRate");

	Params::CrWeaponComponent_GetSingleBulletReloadMontagePlayRate Parms{};

	Parms.IntroSectionName = IntroSectionName;
	Parms.LoopSectionName = LoopSectionName;
	Parms.AfterLoopWindupSectionName = AfterLoopWindupSectionName;
	Parms.OutroSectionName = OutroSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetSingleFireMontagePlayRate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrWeaponComponent::GetSingleFireMontagePlayRate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetSingleFireMontagePlayRate");

	Params::CrWeaponComponent_GetSingleFireMontagePlayRate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetTppAutoFireADSMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetTppAutoFireADSMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetTppAutoFireADSMontage");

	Params::CrWeaponComponent_GetTppAutoFireADSMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetTppAutoFireEmptyMagMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetTppAutoFireEmptyMagMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetTppAutoFireEmptyMagMontage");

	Params::CrWeaponComponent_GetTppAutoFireEmptyMagMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetTppAutoFireMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetTppAutoFireMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetTppAutoFireMontage");

	Params::CrWeaponComponent_GetTppAutoFireMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetTppReloadMontage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetTppReloadMontage(const struct FGameplayTagContainer& CosmeticTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetTppReloadMontage");

	Params::CrWeaponComponent_GetTppReloadMontage Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetTppSingleFireADSMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetTppSingleFireADSMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetTppSingleFireADSMontage");

	Params::CrWeaponComponent_GetTppSingleFireADSMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetTppSingleFireMontage
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetTppSingleFireMontage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetTppSingleFireMontage");

	Params::CrWeaponComponent_GetTppSingleFireMontage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponComponent.GetTppUnEquipMontage
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTagContainer&     CosmeticTags                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UCrWeaponComponent::GetTppUnEquipMontage(const struct FGameplayTagContainer& CosmeticTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponComponent", "GetTppUnEquipMontage");

	Params::CrWeaponComponent_GetTppUnEquipMontage Parms{};

	Parms.CosmeticTags = std::move(CosmeticTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassSaveSubsystem.OnPostSaveLoaded
// (Final, Native, Private)

void UCrMassSaveSubsystem::OnPostSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassSaveSubsystem", "OnPostSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassSaveSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UCrMassSaveSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassSaveSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassSaveSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UCrMassSaveSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMassSaveSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSoundChannelPlayer.OnAudioPlaybackPercent
// (Final, Native, Private)
// Parameters:
// const class USoundWave*                 PlayingSoundWave                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             PlaybackPercent                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSoundChannelPlayer::OnAudioPlaybackPercent(const class USoundWave* PlayingSoundWave, const float PlaybackPercent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSoundChannelPlayer", "OnAudioPlaybackPercent");

	Params::CrSoundChannelPlayer_OnAudioPlaybackPercent Parms{};

	Parms.PlayingSoundWave = PlayingSoundWave;
	Parms.PlaybackPercent = PlaybackPercent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSoundChannelPlayer.OnSoundFinished
// (Final, Native, Private)

void UCrSoundChannelPlayer::OnSoundFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSoundChannelPlayer", "OnSoundFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSpawnPointBuilding.OnBuildingOwnershipChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// ECrBuildingOwnership                    NewOwnership                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrSpawnPointBuilding::OnBuildingOwnershipChanged(ECrBuildingOwnership NewOwnership)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSpawnPointBuilding", "OnBuildingOwnershipChanged");

	Params::CrSpawnPointBuilding_OnBuildingOwnershipChanged Parms{};

	Parms.NewOwnership = NewOwnership;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrSpawnPointBuilding.GetInteractionAdditionalTextFromOwnership
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// ECrBuildingOwnership                    InOwnership                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ACrSpawnPointBuilding::GetInteractionAdditionalTextFromOwnership(ECrBuildingOwnership InOwnership) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSpawnPointBuilding", "GetInteractionAdditionalTextFromOwnership");

	Params::CrSpawnPointBuilding_GetInteractionAdditionalTextFromOwnership Parms{};

	Parms.InOwnership = InOwnership;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrStandaloneInfectionActor.BP_OnDamageProtectionChanged
// (Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsActive                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrStandaloneInfectionActor::BP_OnDamageProtectionChanged(bool IsActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionActor", "BP_OnDamageProtectionChanged");

	Params::CrStandaloneInfectionActor_BP_OnDamageProtectionChanged Parms{};

	Parms.IsActive = IsActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrStandaloneInfectionActor.BP_OnDestroyed
// (Event, Public, BlueprintEvent)

void ACrStandaloneInfectionActor::BP_OnDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionActor", "BP_OnDestroyed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrStandaloneInfectionActor.BP_OnInfectionJustSpawned
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void ACrStandaloneInfectionActor::BP_OnInfectionJustSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionActor", "BP_OnInfectionJustSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrStandaloneInfectionActor.OnDamageProtectionChanged
// (Final, Native, Public)
// Parameters:
// const struct FMassEntityHandle&         Entity                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Signal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrStandaloneInfectionActor::OnDamageProtectionChanged(const struct FMassEntityHandle& Entity, class FName Signal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionActor", "OnDamageProtectionChanged");

	Params::CrStandaloneInfectionActor_OnDamageProtectionChanged Parms{};

	Parms.Entity = std::move(Entity);
	Parms.Signal = Signal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStandaloneInfectionActor.OnDestroyed
// (Final, Native, Public)
// Parameters:
// const struct FMassEntityHandle&         Entity                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Signal                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrStandaloneInfectionActor::OnDestroyed(const struct FMassEntityHandle& Entity, class FName Signal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionActor", "OnDestroyed");

	Params::CrStandaloneInfectionActor_OnDestroyed Parms{};

	Parms.Entity = std::move(Entity);
	Parms.Signal = Signal;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStandaloneInfectionActor.OnGrowthProgress
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrStandaloneInfectionActor::OnGrowthProgress(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionActor", "OnGrowthProgress");

	Params::CrStandaloneInfectionActor_OnGrowthProgress Parms{};

	Parms.Progress = Progress;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrStandaloneInfectionActor.GetDamageProtectionActive
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrStandaloneInfectionActor::GetDamageProtectionActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionActor", "GetDamageProtectionActive");

	Params::CrStandaloneInfectionActor_GetDamageProtectionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrStandaloneInfectionActor.GetWasDestroyed
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrStandaloneInfectionActor::GetWasDestroyed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStandaloneInfectionActor", "GetWasDestroyed");

	Params::CrStandaloneInfectionActor_GetWasDestroyed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerAggroComponent.OnBuildingToolUsed
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    bConstructed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPlayerAggroComponent::OnBuildingToolUsed(bool bConstructed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerAggroComponent", "OnBuildingToolUsed");

	Params::CrPlayerAggroComponent_OnBuildingToolUsed Parms{};

	Parms.bConstructed = bConstructed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMedToolChargeAttributeSet.OnRep_CurrentMedToolCharge
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentCharge                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMedToolChargeAttributeSet::OnRep_CurrentMedToolCharge(const struct FGameplayAttributeData& OldCurrentCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMedToolChargeAttributeSet", "OnRep_CurrentMedToolCharge");

	Params::CrMedToolChargeAttributeSet_OnRep_CurrentMedToolCharge Parms{};

	Parms.OldCurrentCharge = std::move(OldCurrentCharge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMedToolChargeAttributeSet.OnRep_MaxMedToolCharge
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxCharge                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMedToolChargeAttributeSet::OnRep_MaxMedToolCharge(const struct FGameplayAttributeData& OldMaxCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMedToolChargeAttributeSet", "OnRep_MaxMedToolCharge");

	Params::CrMedToolChargeAttributeSet_OnRep_MaxMedToolCharge Parms{};

	Parms.OldMaxCharge = std::move(OldMaxCharge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMedToolChargeAttributeSet.OnRep_MinMedToolCharge
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinCharge                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMedToolChargeAttributeSet::OnRep_MinMedToolCharge(const struct FGameplayAttributeData& OldMinCharge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMedToolChargeAttributeSet", "OnRep_MinMedToolCharge");

	Params::CrMedToolChargeAttributeSet_OnRep_MinMedToolCharge Parms{};

	Parms.OldMinCharge = std::move(OldMinCharge);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineAirlockDoor.ActivateOtherDoor
// (Final, Native, Public)
// Parameters:
// class AActor*                           ActorActivating                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineAirlockDoor::ActivateOtherDoor(class AActor* ActorActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineAirlockDoor", "ActivateOtherDoor");

	Params::CrMegamachineAirlockDoor_ActivateOtherDoor Parms{};

	Parms.ActorActivating = ActorActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineAirlockDoor.OnOtherDoorClosingCompleted
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineAirlockDoor::OnOtherDoorClosingCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineAirlockDoor", "OnOtherDoorClosingCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineAirlockDoor.OnOtherDoorOpeningCompleted
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineAirlockDoor::OnOtherDoorOpeningCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineAirlockDoor", "OnOtherDoorOpeningCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineAirlockDoor.OnUnlocked
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           ActorActivating                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineAirlockDoor::OnUnlocked(class AActor* ActorActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineAirlockDoor", "OnUnlocked");

	Params::CrMegamachineAirlockDoor_OnUnlocked Parms{};

	Parms.ActorActivating = ActorActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineAirlockDoor.ServerActivateOtherDoor
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           ActorActivating                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineAirlockDoor::ServerActivateOtherDoor(class AActor* ActorActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineAirlockDoor", "ServerActivateOtherDoor");

	Params::CrMegamachineAirlockDoor_ServerActivateOtherDoor Parms{};

	Parms.ActorActivating = ActorActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineCannon.PlayAnimation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           SkeletalMeshComponent                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimationAsset*                  AnimationAsset                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRuntimeFloatCurve&        AnimCurve                                              (Parm, NativeAccessSpecifierPublic)
// float                                   Playrate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Looping                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineCannon::PlayAnimation(class USkeletalMeshComponent* SkeletalMeshComponent, class UAnimationAsset* AnimationAsset, const struct FRuntimeFloatCurve& AnimCurve, float Playrate, bool Looping)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineCannon", "PlayAnimation");

	Params::CrMegamachineCannon_PlayAnimation Parms{};

	Parms.SkeletalMeshComponent = SkeletalMeshComponent;
	Parms.AnimationAsset = AnimationAsset;
	Parms.AnimCurve = std::move(AnimCurve);
	Parms.Playrate = Playrate;
	Parms.Looping = Looping;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.ActivateActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineDeviceBase::ActivateActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "ActivateActor");

	Params::CrMegamachineDeviceBase_ActivateActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.ActivateTargetActors
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineDeviceBase::ActivateTargetActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "ActivateTargetActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.CanActivateTargetActors
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDeviceBase::CanActivateTargetActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "CanActivateTargetActors");

	Params::CrMegamachineDeviceBase_CanActivateTargetActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.CanInteractWithMegamachine
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDeviceBase::CanInteractWithMegamachine(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "CanInteractWithMegamachine");

	Params::CrMegamachineDeviceBase_CanInteractWithMegamachine Parms{};

	Parms.InPc = InPc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.CanUnlockTargetActors
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDeviceBase::CanUnlockTargetActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "CanUnlockTargetActors");

	Params::CrMegamachineDeviceBase_CanUnlockTargetActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.GetDataToSave
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// bool*                                   bOutDataValid                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInstancedStruct                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInstancedStruct ACrMegamachineDeviceBase::GetDataToSave(bool* bOutDataValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "GetDataToSave");

	Params::CrMegamachineDeviceBase_GetDataToSave Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutDataValid != nullptr)
		*bOutDataValid = Parms.bOutDataValid;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.LoadData
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const struct FInstancedStruct&          Data                                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDeviceBase::LoadData(const struct FInstancedStruct& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "LoadData");

	Params::CrMegamachineDeviceBase_LoadData Parms{};

	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.MulticastOnTargetActorsActivated
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ACrMegamachineDeviceBase::MulticastOnTargetActorsActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "MulticastOnTargetActorsActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.MulticastOnTargetActorsUnlocked
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)

void ACrMegamachineDeviceBase::MulticastOnTargetActorsUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "MulticastOnTargetActorsUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.OnActorLoaded
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FMegamachineDeviceSaveData&SavedData                                              (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDeviceBase::OnActorLoaded(const struct FMegamachineDeviceSaveData& SavedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "OnActorLoaded");

	Params::CrMegamachineDeviceBase_OnActorLoaded Parms{};

	Parms.SavedData = std::move(SavedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.OnInteractionStarted
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerControllerInteracting                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDeviceBase::OnInteractionStarted(class APlayerController* PlayerControllerInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "OnInteractionStarted");

	Params::CrMegamachineDeviceBase_OnInteractionStarted Parms{};

	Parms.PlayerControllerInteracting = PlayerControllerInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.OnInteractionStopped
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerControllerInteracting                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineDeviceBase::OnInteractionStopped(class APlayerController* PlayerControllerInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "OnInteractionStopped");

	Params::CrMegamachineDeviceBase_OnInteractionStopped Parms{};

	Parms.PlayerControllerInteracting = PlayerControllerInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.OnRep_WasActivated
// (Final, Native, Public)

void ACrMegamachineDeviceBase::OnRep_WasActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "OnRep_WasActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.OnTargetActorsActivated
// (Native, Event, Public, BlueprintEvent)

void ACrMegamachineDeviceBase::OnTargetActorsActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "OnTargetActorsActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.OnTargetActorsUnlocked
// (Native, Event, Public, BlueprintEvent)

void ACrMegamachineDeviceBase::OnTargetActorsUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "OnTargetActorsUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.ResetGuid
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineDeviceBase::ResetGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "ResetGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.SaveMachineState
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineDeviceBase::SaveMachineState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "SaveMachineState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.UnlockTargetActors
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineDeviceBase::UnlockTargetActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "UnlockTargetActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineDeviceBase.GetContaminationActorsData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TMap<class FName, float>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, float> ACrMegamachineDeviceBase::GetContaminationActorsData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "GetContaminationActorsData");

	Params::CrMegamachineDeviceBase_GetContaminationActorsData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineDeviceBase.GetGuid
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid ACrMegamachineDeviceBase::GetGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineDeviceBase", "GetGuid");

	Params::CrMegamachineDeviceBase_GetGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineTimelineDevice.ActivateActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineTimelineDevice::ActivateActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "ActivateActor");

	Params::CrMegamachineTimelineDevice_ActivateActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.ActivateMachine
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorActivating                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineTimelineDevice::ActivateMachine(class AActor* ActorActivating)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "ActivateMachine");

	Params::CrMegamachineTimelineDevice_ActivateMachine Parms{};

	Parms.ActorActivating = ActorActivating;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.CanInteractWithMegamachine
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                InPc                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineTimelineDevice::CanInteractWithMegamachine(class APlayerController* InPc)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "CanInteractWithMegamachine");

	Params::CrMegamachineTimelineDevice_CanInteractWithMegamachine Parms{};

	Parms.InPc = InPc;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineTimelineDevice.MulticastOnMachineActivated
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ACrMegamachineTimelineDevice::MulticastOnMachineActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "MulticastOnMachineActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.OnActorLoaded
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// const struct FMegamachineTimelineDeviceSaveData&LoadedData                                             (Parm, NativeAccessSpecifierPublic)

void ACrMegamachineTimelineDevice::OnActorLoaded(const struct FMegamachineTimelineDeviceSaveData& LoadedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "OnActorLoaded");

	Params::CrMegamachineTimelineDevice_OnActorLoaded Parms{};

	Parms.LoadedData = std::move(LoadedData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.OnInteractionStarted
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerControllerInteracting                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineTimelineDevice::OnInteractionStarted(class APlayerController* PlayerControllerInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "OnInteractionStarted");

	Params::CrMegamachineTimelineDevice_OnInteractionStarted Parms{};

	Parms.PlayerControllerInteracting = PlayerControllerInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineTimelineDevice.OnInteractionStopped
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerControllerInteracting                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMegamachineTimelineDevice::OnInteractionStopped(class APlayerController* PlayerControllerInteracting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "OnInteractionStopped");

	Params::CrMegamachineTimelineDevice_OnInteractionStopped Parms{};

	Parms.PlayerControllerInteracting = PlayerControllerInteracting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineTimelineDevice.OnMachineActivated
// (Native, Event, Public, BlueprintEvent)

void ACrMegamachineTimelineDevice::OnMachineActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "OnMachineActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.OnRep_State
// (Final, Native, Public)

void ACrMegamachineTimelineDevice::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "OnRep_State");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.OnRep_WasActivated
// (Final, Native, Public)

void ACrMegamachineTimelineDevice::OnRep_WasActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "OnRep_WasActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.OnUpdateState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrMegamachineTimelineDevice::OnUpdateState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "OnUpdateState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.OnUpdateTimelineState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrMegamachineTimelineDevice::OnUpdateTimelineState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "OnUpdateTimelineState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.ResetGuid
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineTimelineDevice::ResetGuid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "ResetGuid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.SaveMachineState
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineTimelineDevice::SaveMachineState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "SaveMachineState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.SaveState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECrMegamachineDeviceState               InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineTimelineDevice::SaveState(ECrMegamachineDeviceState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "SaveState");

	Params::CrMegamachineTimelineDevice_SaveState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTimelineDevice.GetContaminationActorsData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TMap<class FName, float>                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, float> ACrMegamachineTimelineDevice::GetContaminationActorsData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "GetContaminationActorsData");

	Params::CrMegamachineTimelineDevice_GetContaminationActorsData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMegamachineTimelineDevice.GetGuid
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGuid                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGuid ACrMegamachineTimelineDevice::GetGuid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTimelineDevice", "GetGuid");

	Params::CrMegamachineTimelineDevice_GetGuid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrCheatManager.AddTagToSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// const class FString&                    TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::AddTagToSelf(const class FString& TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "AddTagToSelf");

	Params::CrCheatManager_AddTagToSelf Parms{};

	Parms.TagName = std::move(TagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.BugItGoWalk
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::BugItGoWalk(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "BugItGoWalk");

	Params::CrCheatManager_BugItGoWalk Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CancelActivatedAbilities
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::CancelActivatedAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CancelActivatedAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.Cheat
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::Cheat(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "Cheat");

	Params::CrCheatManager_Cheat Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatAddDataPoints
// (Exec, Native, Public)
// Parameters:
// int32                                   InPoints                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatAddDataPoints(int32 InPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatAddDataPoints");

	Params::CrCheatManager_CheatAddDataPoints Parms{};

	Parms.InPoints = InPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatAll
// (Final, Exec, Native, Public)
// Parameters:
// const class FString&                    Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatAll(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatAll");

	Params::CrCheatManager_CheatAll Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatAutoWalkInput
// (Exec, Native, Public)

void UCrCheatManager::CheatAutoWalkInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatAutoWalkInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatClaimCorporationLevelReward
// (Exec, Native, Public)
// Parameters:
// const class FString&                    CorporationName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatClaimCorporationLevelReward(const class FString& CorporationName, int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatClaimCorporationLevelReward");

	Params::CrCheatManager_CheatClaimCorporationLevelReward Parms{};

	Parms.CorporationName = std::move(CorporationName);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatGiveDefaultWeapons
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::CheatGiveDefaultWeapons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatGiveDefaultWeapons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatIgnoreBaseCore
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Ignore                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatIgnoreBaseCore(bool Ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatIgnoreBaseCore");

	Params::CrCheatManager_CheatIgnoreBaseCore Parms{};

	Parms.Ignore = Ignore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatIgnoreBuildingCost
// (Exec, Native, Public)
// Parameters:
// int32                                   Ignore                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatIgnoreBuildingCost(int32 Ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatIgnoreBuildingCost");

	Params::CrCheatManager_CheatIgnoreBuildingCost Parms{};

	Parms.Ignore = Ignore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatIncreaseCorporationLevel
// (Exec, Native, Public)
// Parameters:
// const class FString&                    CorporationName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatIncreaseCorporationLevel(const class FString& CorporationName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatIncreaseCorporationLevel");

	Params::CrCheatManager_CheatIncreaseCorporationLevel Parms{};

	Parms.CorporationName = std::move(CorporationName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatMaxAllCorporations
// (Exec, Native, Public)

void UCrCheatManager::CheatMaxAllCorporations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatMaxAllCorporations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatMaxAllSkills
// (Exec, Native, Public)

void UCrCheatManager::CheatMaxAllSkills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatMaxAllSkills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatMenu
// (Final, Exec, Native, Public, BlueprintCallable)

void UCrCheatManager::CheatMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatPauseHeatWave
// (Exec, Native, Public)

void UCrCheatManager::CheatPauseHeatWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatPauseHeatWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatProfessionSelectionMenu
// (Final, Exec, Native, Public, BlueprintCallable)

void UCrCheatManager::CheatProfessionSelectionMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatProfessionSelectionMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatQuickAddAmmo
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::CheatQuickAddAmmo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatQuickAddAmmo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatQuickAddItems
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::CheatQuickAddItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatQuickAddItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatSetAllSkillsLevel
// (Exec, Native, Public)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatSetAllSkillsLevel(int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatSetAllSkillsLevel");

	Params::CrCheatManager_CheatSetAllSkillsLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatSetBlockProgressionNotification
// (Exec, Native, Public)
// Parameters:
// bool                                    bBlock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatSetBlockProgressionNotification(bool bBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatSetBlockProgressionNotification");

	Params::CrCheatManager_CheatSetBlockProgressionNotification Parms{};

	Parms.bBlock = bBlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatSetCorporationLevel
// (Exec, Native, Public)
// Parameters:
// const class FString&                    CorporationName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatSetCorporationLevel(const class FString& CorporationName, int32 InLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatSetCorporationLevel");

	Params::CrCheatManager_CheatSetCorporationLevel Parms{};

	Parms.CorporationName = std::move(CorporationName);
	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatSetDataPoints
// (Exec, Native, Public)
// Parameters:
// int32                                   InPoints                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatSetDataPoints(int32 InPoints)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatSetDataPoints");

	Params::CrCheatManager_CheatSetDataPoints Parms{};

	Parms.InPoints = InPoints;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatShowBaseCoreRange
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatShowBaseCoreRange(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatShowBaseCoreRange");

	Params::CrCheatManager_CheatShowBaseCoreRange Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatShowZiplineConnections
// (Exec, Native, Public)

void UCrCheatManager::CheatShowZiplineConnections()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatShowZiplineConnections");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatStartHeatWave
// (Exec, Native, Public)

void UCrCheatManager::CheatStartHeatWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatStartHeatWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatStartPreHeatWave
// (Exec, Native, Public)

void UCrCheatManager::CheatStartPreHeatWave()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatStartPreHeatWave");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatSuperSpeed
// (Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatSuperSpeed(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatSuperSpeed");

	Params::CrCheatManager_CheatSuperSpeed Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatTeleportTo
// (Exec, Native, Public)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Pitch                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Yaw                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Roll                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatTeleportTo(float X, float Y, float Z, float Pitch, float Yaw, float Roll)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatTeleportTo");

	Params::CrCheatManager_CheatTeleportTo Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;
	Parms.Pitch = Pitch;
	Parms.Yaw = Yaw;
	Parms.Roll = Roll;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatUnconditionalBaseCoreUpgrade
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Upgrade                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatUnconditionalBaseCoreUpgrade(bool Upgrade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatUnconditionalBaseCoreUpgrade");

	Params::CrCheatManager_CheatUnconditionalBaseCoreUpgrade Parms{};

	Parms.Upgrade = Upgrade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatUnlockAllBuildings
// (Exec, Native, Public)
// Parameters:
// bool                                    Unlock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatUnlockAllBuildings(bool Unlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatUnlockAllBuildings");

	Params::CrCheatManager_CheatUnlockAllBuildings Parms{};

	Parms.Unlock = Unlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatUnlockAllFeatures
// (Exec, Native, Public)

void UCrCheatManager::CheatUnlockAllFeatures()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatUnlockAllFeatures");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CheatUnlockAllRecipes
// (Exec, Native, Public)
// Parameters:
// bool                                    Unlock                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::CheatUnlockAllRecipes(bool Unlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CheatUnlockAllRecipes");

	Params::CrCheatManager_CheatUnlockAllRecipes Parms{};

	Parms.Unlock = Unlock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ClearFogOfWar
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ClearValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::ClearFogOfWar(int32 ClearValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ClearFogOfWar");

	Params::CrCheatManager_ClearFogOfWar Parms{};

	Parms.ClearValue = ClearValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CycleAbilitySystemDebug
// (Exec, Native, Public)

void UCrCheatManager::CycleAbilitySystemDebug()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CycleAbilitySystemDebug");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.CycleDebugCameras
// (Exec, Native, Public)

void UCrCheatManager::CycleDebugCameras()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "CycleDebugCameras");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DamageSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DamageSelf(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DamageSelf");

	Params::CrCheatManager_DamageSelf Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DamageSelfDestruct
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::DamageSelfDestruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DamageSelfDestruct");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugContextualDialogRulesCriterionsChecks
// (Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DebugContextualDialogRulesCriterionsChecks(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugContextualDialogRulesCriterionsChecks");

	Params::CrCheatManager_DebugContextualDialogRulesCriterionsChecks Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugContextualDialogRulesInitialization
// (Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DebugContextualDialogRulesInitialization(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugContextualDialogRulesInitialization");

	Params::CrCheatManager_DebugContextualDialogRulesInitialization Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugExecFlow
// (Exec, Native, Public)
// Parameters:
// const class FString&                    InFlowName                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DebugExecFlow(const class FString& InFlowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugExecFlow");

	Params::CrCheatManager_DebugExecFlow Parms{};

	Parms.InFlowName = std::move(InFlowName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugExecuteContextualEvent
// (Exec, Native, Public)
// Parameters:
// const class FString&                    Context                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ContextValue                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ContextNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DebugExecuteContextualEvent(const class FString& Context, const class FString& ContextValue, int32 ContextNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugExecuteContextualEvent");

	Params::CrCheatManager_DebugExecuteContextualEvent Parms{};

	Parms.Context = std::move(Context);
	Parms.ContextValue = std::move(ContextValue);
	Parms.ContextNumber = ContextNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugExecutedContextualEventCalls
// (Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DebugExecutedContextualEventCalls(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugExecutedContextualEventCalls");

	Params::CrCheatManager_DebugExecutedContextualEventCalls Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugRetriggerGatherablePlantInstancedVisualisation
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::DebugRetriggerGatherablePlantInstancedVisualisation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugRetriggerGatherablePlantInstancedVisualisation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugSetAllBuildingsTemperature
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Temperature                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DebugSetAllBuildingsTemperature(float Temperature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugSetAllBuildingsTemperature");

	Params::CrCheatManager_DebugSetAllBuildingsTemperature Parms{};

	Parms.Temperature = Temperature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugSetBuildingTemperature
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Temperature                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DebugSetBuildingTemperature(float Temperature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugSetBuildingTemperature");

	Params::CrCheatManager_DebugSetBuildingTemperature Parms{};

	Parms.Temperature = Temperature;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugSetCharacterBusVolume
// (Exec, Native, Public)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DebugSetCharacterBusVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugSetCharacterBusVolume");

	Params::CrCheatManager_DebugSetCharacterBusVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugToggleCoopHudHealthInfo
// (Exec, Native, Public)

void UCrCheatManager::DebugToggleCoopHudHealthInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugToggleCoopHudHealthInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugToggleGatherablePlantRegularVisualisation
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::DebugToggleGatherablePlantRegularVisualisation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugToggleGatherablePlantRegularVisualisation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugToggleHarvesterNoDamage
// (Final, Exec, Native, Public)

void UCrCheatManager::DebugToggleHarvesterNoDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugToggleHarvesterNoDamage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugTogglePCGGatherablesGenerationEnabled
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::DebugTogglePCGGatherablesGenerationEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugTogglePCGGatherablesGenerationEnabled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugTogglePlayerProgressionExpInfo
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::DebugTogglePlayerProgressionExpInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugTogglePlayerProgressionExpInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugToggleReloadSingleBulletPrintDebugInfo
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::DebugToggleReloadSingleBulletPrintDebugInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugToggleReloadSingleBulletPrintDebugInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugToggleShowMiningResourceDurations
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::DebugToggleShowMiningResourceDurations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugToggleShowMiningResourceDurations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugTutorialSkip
// (Exec, Native, Public)

void UCrCheatManager::DebugTutorialSkip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugTutorialSkip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DebugTutorialStart
// (Exec, Native, Public)

void UCrCheatManager::DebugTutorialStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DebugTutorialStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DecreaseRadiationSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DecreaseRadiationSelf(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DecreaseRadiationSelf");

	Params::CrCheatManager_DecreaseRadiationSelf Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DecreaseShieldSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DecreaseShieldSelf(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DecreaseShieldSelf");

	Params::CrCheatManager_DecreaseShieldSelf Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DecreaseToxicitySelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::DecreaseToxicitySelf(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DecreaseToxicitySelf");

	Params::CrCheatManager_DecreaseToxicitySelf Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.DisableWatermark
// (Final, Exec, Native, Public, BlueprintCallable)

void UCrCheatManager::DisableWatermark()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "DisableWatermark");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.FlashlightShadow
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::FlashlightShadow(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "FlashlightShadow");

	Params::CrCheatManager_FlashlightShadow Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ForceHideInfectionCloud
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ForceHide                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::ForceHideInfectionCloud(bool ForceHide)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ForceHideInfectionCloud");

	Params::CrCheatManager_ForceHideInfectionCloud Parms{};

	Parms.ForceHide = ForceHide;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.HasAllKeys
// (BlueprintAuthorityOnly, Exec, Native, Public)

void UCrCheatManager::HasAllKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "HasAllKeys");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.HealSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::HealSelf(float HealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "HealSelf");

	Params::CrCheatManager_HealSelf Parms{};

	Parms.HealAmount = HealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.HealTarget
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   HealAmount                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::HealTarget(float HealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "HealTarget");

	Params::CrCheatManager_HealTarget Parms{};

	Parms.HealAmount = HealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.Hints
// (Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::Hints(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "Hints");

	Params::CrCheatManager_Hints Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.IgnoreContextualDialogExecutions
// (Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::IgnoreContextualDialogExecutions(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "IgnoreContextualDialogExecutions");

	Params::CrCheatManager_IgnoreContextualDialogExecutions Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.Immortal
// (Exec, Native, Public, BlueprintCallable)

void UCrCheatManager::Immortal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "Immortal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.IncreaseRadiationSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::IncreaseRadiationSelf(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "IncreaseRadiationSelf");

	Params::CrCheatManager_IncreaseRadiationSelf Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.IncreaseToxicitySelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::IncreaseToxicitySelf(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "IncreaseToxicitySelf");

	Params::CrCheatManager_IncreaseToxicitySelf Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.InfectTarget
// (Exec, Native, Public, BlueprintCallable)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::InfectTarget(float DamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "InfectTarget");

	Params::CrCheatManager_InfectTarget Parms{};

	Parms.DamageAmount = DamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.MapMenuUncoverPOI
// (Final, Exec, Native, Public, BlueprintCallable)

void UCrCheatManager::MapMenuUncoverPOI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "MapMenuUncoverPOI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ObjectivesActivate
// (Exec, Native, Public)
// Parameters:
// const class FString&                    ObjectiveName                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::ObjectivesActivate(const class FString& ObjectiveName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ObjectivesActivate");

	Params::CrCheatManager_ObjectivesActivate Parms{};

	Parms.ObjectiveName = std::move(ObjectiveName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ObjectivesCompleteCurrent
// (Exec, Native, Public)

void UCrCheatManager::ObjectivesCompleteCurrent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ObjectivesCompleteCurrent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ObjectivesDeactivateAll
// (Exec, Native, Public)

void UCrCheatManager::ObjectivesDeactivateAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ObjectivesDeactivateAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ObjectivesResetCurrent
// (Exec, Native, Public)

void UCrCheatManager::ObjectivesResetCurrent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ObjectivesResetCurrent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.RemoveTagFromSelf
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// const class FString&                    TagName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::RemoveTagFromSelf(const class FString& TagName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "RemoveTagFromSelf");

	Params::CrCheatManager_RemoveTagFromSelf Parms{};

	Parms.TagName = std::move(TagName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.RestrictedDrain
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::RestrictedDrain(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "RestrictedDrain");

	Params::CrCheatManager_RestrictedDrain Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.RestrictedRadiation
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::RestrictedRadiation(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "RestrictedRadiation");

	Params::CrCheatManager_RestrictedRadiation Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.RestrictedTemperature
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::RestrictedTemperature(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "RestrictedTemperature");

	Params::CrCheatManager_RestrictedTemperature Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.RestrictedToxicity
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::RestrictedToxicity(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "RestrictedToxicity");

	Params::CrCheatManager_RestrictedToxicity Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.RunFEMainEngine
// (Exec, Native, Public)

void UCrCheatManager::RunFEMainEngine()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "RunFEMainEngine");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.SetRadiationBordersLevel
// (Exec, Native, Public)
// Parameters:
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::SetRadiationBordersLevel(int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "SetRadiationBordersLevel");

	Params::CrCheatManager_SetRadiationBordersLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ShowDebugMapBorderTexture
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::ShowDebugMapBorderTexture(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ShowDebugMapBorderTexture");

	Params::CrCheatManager_ShowDebugMapBorderTexture Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ShowHUDNotificationType
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// EFAuNotificationType                    NotifycationType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::ShowHUDNotificationType(EFAuNotificationType NotifycationType, bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ShowHUDNotificationType");

	Params::CrCheatManager_ShowHUDNotificationType Parms{};

	Parms.NotifycationType = NotifycationType;
	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ShowWaveTimer
// (Final, Exec, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::ShowWaveTimer(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ShowWaveTimer");

	Params::CrCheatManager_ShowWaveTimer Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.SkipNextLoadingScreen
// (Final, Exec, Native, Public, BlueprintCallable)

void UCrCheatManager::SkipNextLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "SkipNextLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.ToggleFixedCamera
// (Exec, Native, Public)

void UCrCheatManager::ToggleFixedCamera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "ToggleFixedCamera");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedAmmo
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedAmmo(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedAmmo");

	Params::CrCheatManager_UnlimitedAmmo Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedCalories
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedCalories(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedCalories");

	Params::CrCheatManager_UnlimitedCalories Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedEnergy
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedEnergy(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedEnergy");

	Params::CrCheatManager_UnlimitedEnergy Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedGrenades
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedGrenades(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedGrenades");

	Params::CrCheatManager_UnlimitedGrenades Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedHealth
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedHealth(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedHealth");

	Params::CrCheatManager_UnlimitedHealth Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedHydration
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedHydration(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedHydration");

	Params::CrCheatManager_UnlimitedHydration Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedMedTool
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedMedTool(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedMedTool");

	Params::CrCheatManager_UnlimitedMedTool Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedOxygen
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedOxygen(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedOxygen");

	Params::CrCheatManager_UnlimitedOxygen Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedShield
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedShield(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedShield");

	Params::CrCheatManager_UnlimitedShield Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrCheatManager.UnlimitedWeaponHeat
// (BlueprintAuthorityOnly, Exec, Native, Public)
// Parameters:
// int32                                   Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrCheatManager::UnlimitedWeaponHeat(int32 Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrCheatManager", "UnlimitedWeaponHeat");

	Params::CrCheatManager_UnlimitedWeaponHeat Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineMainEngine.ServerChangeRadiationLevel
// (Net, NetReliable, Native, Event, Protected, NetServer)
// Parameters:
// int32                                   RadiationLevel                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineMainEngine::ServerChangeRadiationLevel(int32 RadiationLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineMainEngine", "ServerChangeRadiationLevel");

	Params::CrMegamachineMainEngine_ServerChangeRadiationLevel Parms{};

	Parms.RadiationLevel = RadiationLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineMissingPartDevice.OnMachineActivated
// (Native, Event, Public, BlueprintEvent)

void ACrMegamachineMissingPartDevice::OnMachineActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineMissingPartDevice", "OnMachineActivated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineMissingPartDevice.OnUI_Closed
// (Native, Event, Public, BlueprintEvent)

void ACrMegamachineMissingPartDevice::OnUI_Closed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineMissingPartDevice", "OnUI_Closed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineMissingPartDevice.OnUI_Opened
// (Native, Event, Public, BlueprintEvent)

void ACrMegamachineMissingPartDevice::OnUI_Opened()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineMissingPartDevice", "OnUI_Opened");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTeleporterDevice.ActivateTeleporter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FCrTeleportationData&      InTeleportationData                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ACrMegamachineTeleporterDevice::ActivateTeleporter(const struct FCrTeleportationData& InTeleportationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTeleporterDevice", "ActivateTeleporter");

	Params::CrMegamachineTeleporterDevice_ActivateTeleporter Parms{};

	Parms.InTeleportationData = std::move(InTeleportationData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTeleporterDevice.FadeIn
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineTeleporterDevice::FadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTeleporterDevice", "FadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTeleporterDevice.FadeOut
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FCrTeleportationData&      InTeleportationData                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UAudioComponent*                  InLoopSoundAudioComponent                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMegamachineTeleporterDevice::FadeOut(const struct FCrTeleportationData& InTeleportationData, class UAudioComponent* InLoopSoundAudioComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTeleporterDevice", "FadeOut");

	Params::CrMegamachineTeleporterDevice_FadeOut Parms{};

	Parms.InTeleportationData = std::move(InTeleportationData);
	Parms.InLoopSoundAudioComponent = InLoopSoundAudioComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTeleporterDevice.OnActorTeleported
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrMegamachineTeleporterDevice::OnActorTeleported()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTeleporterDevice", "OnActorTeleported");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTeleporterDevice.TeleportationComplete
// (Final, Native, Public, BlueprintCallable)

void ACrMegamachineTeleporterDevice::TeleportationComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTeleporterDevice", "TeleportationComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTeleporterDevice.TeleportationExecute
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FCrTeleportationData&      InTeleportationData                                    (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ACrMegamachineTeleporterDevice::TeleportationExecute(const struct FCrTeleportationData& InTeleportationData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTeleporterDevice", "TeleportationExecute");

	Params::CrMegamachineTeleporterDevice_TeleportationExecute Parms{};

	Parms.InTeleportationData = std::move(InTeleportationData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMegamachineTeleporterDevice.TeleportationExecutionComplete
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrMegamachineTeleporterDevice::TeleportationExecutionComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMegamachineTeleporterDevice", "TeleportationExecutionComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.BP_AddInstancedVisual
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                InTransform                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMeteOreActor::BP_AddInstancedVisual(class UStaticMeshComponent* InComponent, const struct FTransform& InTransform, class UStaticMesh* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "BP_AddInstancedVisual");

	Params::CrMeteOreActor_BP_AddInstancedVisual Parms{};

	Parms.InComponent = InComponent;
	Parms.InTransform = std::move(InTransform);
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.BP_HideWeakSpots
// (Final, Native, Public, BlueprintCallable)

void ACrMeteOreActor::BP_HideWeakSpots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "BP_HideWeakSpots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.BP_InitializeInstancedVisuals
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMeshComponent*             InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMeteOreActor::BP_InitializeInstancedVisuals(class UStaticMesh* InMesh, class UStaticMeshComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "BP_InitializeInstancedVisuals");

	Params::CrMeteOreActor_BP_InitializeInstancedVisuals Parms{};

	Parms.InMesh = InMesh;
	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.BP_OnPostBecameInsignificant
// (Event, Public, BlueprintEvent)

void ACrMeteOreActor::BP_OnPostBecameInsignificant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "BP_OnPostBecameInsignificant");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrMeteOreActor.BP_OnPostBecameSignificant
// (Event, Public, BlueprintEvent)

void ACrMeteOreActor::BP_OnPostBecameSignificant()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "BP_OnPostBecameSignificant");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrMeteOreActor.BP_RemoveInstancedVisual
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UStaticMeshComponent*             InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      InMesh                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrMeteOreActor::BP_RemoveInstancedVisual(class UStaticMeshComponent* InComponent, class UStaticMesh* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "BP_RemoveInstancedVisual");

	Params::CrMeteOreActor_BP_RemoveInstancedVisual Parms{};

	Parms.InComponent = InComponent;
	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.BP_ShowWeakSpots
// (Final, Native, Public, BlueprintCallable)

void ACrMeteOreActor::BP_ShowWeakSpots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "BP_ShowWeakSpots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.MulticastOnMeteOreAllWeakSpotsDepleted
// (Final, Net, NetReliable, Native, Event, NetMulticast, Private)

void ACrMeteOreActor::MulticastOnMeteOreAllWeakSpotsDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "MulticastOnMeteOreAllWeakSpotsDepleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.OnBeginPlayDepletedStateStarted
// (Event, Public, BlueprintEvent)

void ACrMeteOreActor::OnBeginPlayDepletedStateStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "OnBeginPlayDepletedStateStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrMeteOreActor.OnRep_CurrentRandomSeed
// (Final, Native, Private)

void ACrMeteOreActor::OnRep_CurrentRandomSeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "OnRep_CurrentRandomSeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.UpdateCosmeticWeakSpotDissolve
// (Final, Native, Private)

void ACrMeteOreActor::UpdateCosmeticWeakSpotDissolve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "UpdateCosmeticWeakSpotDissolve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMeteOreActor.IsListenServer
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrMeteOreActor::IsListenServer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMeteOreActor", "IsListenServer");

	Params::CrMeteOreActor_IsListenServer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.DamageWeakSpot
// (Native, Public, BlueprintCallable)
// Parameters:
// class FName                             WeakSpotSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMassMineableInterface::DamageWeakSpot(class FName WeakSpotSocketName, float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "DamageWeakSpot");

	Params::CrMassMineableInterface_DamageWeakSpot Parms{};

	Parms.WeakSpotSocketName = WeakSpotSocketName;
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.MineResourceRequest
// (Native, Public)
// Parameters:
// float                                   MiningDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MiningRPM                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           MiningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMassMineableInterface::MineResourceRequest(float MiningDamage, float MiningRPM, class AActor* MiningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "MineResourceRequest");

	Params::CrMassMineableInterface_MineResourceRequest Parms{};

	Parms.MiningDamage = MiningDamage;
	Parms.MiningRPM = MiningRPM;
	Parms.MiningActor = MiningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.MineWeakSpotResourceRequest
// (Native, Public)
// Parameters:
// int32                                   WeakSpotId                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMassMineableInterface::MineWeakSpotResourceRequest(int32 WeakSpotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "MineWeakSpotResourceRequest");

	Params::CrMassMineableInterface_MineWeakSpotResourceRequest Parms{};

	Parms.WeakSpotId = WeakSpotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.OnMiningLockedReleased
// (Native, Public)

void ICrMassMineableInterface::OnMiningLockedReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "OnMiningLockedReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.OnMiningProgressed
// (Native, Public)

void ICrMassMineableInterface::OnMiningProgressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "OnMiningProgressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.OnOreReplenished
// (Native, Public)

void ICrMassMineableInterface::OnOreReplenished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "OnOreReplenished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.OnResourceDepleted
// (Native, Public)
// Parameters:
// bool                                    bShouldSpawnCosmetics                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMassMineableInterface::OnResourceDepleted(bool bShouldSpawnCosmetics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "OnResourceDepleted");

	Params::CrMassMineableInterface_OnResourceDepleted Parms{};

	Parms.bShouldSpawnCosmetics = bShouldSpawnCosmetics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.OnResourceReplenished
// (Native, Public)
// Parameters:
// bool                                    bShouldSpawnCosmetics                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMassMineableInterface::OnResourceReplenished(bool bShouldSpawnCosmetics)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "OnResourceReplenished");

	Params::CrMassMineableInterface_OnResourceReplenished Parms{};

	Parms.bShouldSpawnCosmetics = bShouldSpawnCosmetics;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.OnWeakSpotDepleted
// (Native, Public)

void ICrMassMineableInterface::OnWeakSpotDepleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "OnWeakSpotDepleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.SetMiningGrantee
// (Native, Public)
// Parameters:
// class AActor*                           InMiningGrantee                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMassMineableInterface::SetMiningGrantee(class AActor* InMiningGrantee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "SetMiningGrantee");

	Params::CrMassMineableInterface_SetMiningGrantee Parms{};

	Parms.InMiningGrantee = InMiningGrantee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMassMineableInterface.GetCurrentResourcesCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrMassMineableInterface::GetCurrentResourcesCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetCurrentResourcesCount");

	Params::CrMassMineableInterface_GetCurrentResourcesCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.GetDamageToDealForNextResourceGranting
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMassMineableInterface::GetDamageToDealForNextResourceGranting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetDamageToDealForNextResourceGranting");

	Params::CrMassMineableInterface_GetDamageToDealForNextResourceGranting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.GetGrantingMomentResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMassMineableInterface::GetGrantingMomentResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetGrantingMomentResourceCount");

	Params::CrMassMineableInterface_GetGrantingMomentResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.GetGrantingResourceDamageThreshold
// (Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMassMineableInterface::GetGrantingResourceDamageThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetGrantingResourceDamageThreshold");

	Params::CrMassMineableInterface_GetGrantingResourceDamageThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.GetMaxResourceCount
// (Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrMassMineableInterface::GetMaxResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetMaxResourceCount");

	Params::CrMassMineableInterface_GetMaxResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.GetMiningGrantee
// (Native, Public, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ICrMassMineableInterface::GetMiningGrantee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetMiningGrantee");

	Params::CrMassMineableInterface_GetMiningGrantee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.GetResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrItemDataBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrItemDataBase* ICrMassMineableInterface::GetResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetResource");

	Params::CrMassMineableInterface_GetResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.GetWeakSpotId
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrMassMineableInterface::GetWeakSpotId(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetWeakSpotId");

	Params::CrMassMineableInterface_GetWeakSpotId Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.GetWeakSpotSocketName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ICrMassMineableInterface::GetWeakSpotSocketName(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "GetWeakSpotSocketName");

	Params::CrMassMineableInterface_GetWeakSpotSocketName Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.IsOreDepleted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMassMineableInterface::IsOreDepleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "IsOreDepleted");

	Params::CrMassMineableInterface_IsOreDepleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.IsWeakSpot
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMassMineableInterface::IsWeakSpot(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "IsWeakSpot");

	Params::CrMassMineableInterface_IsWeakSpot Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.IsWeakSpotActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMassMineableInterface::IsWeakSpotActive(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "IsWeakSpotActive");

	Params::CrMassMineableInterface_IsWeakSpotActive Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMassMineableInterface.IsWeakSpotActiveByName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             WeakSpotSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMassMineableInterface::IsWeakSpotActiveByName(class FName WeakSpotSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMassMineableInterface", "IsWeakSpotActiveByName");

	Params::CrMassMineableInterface_IsWeakSpotActiveByName Parms{};

	Parms.WeakSpotSocketName = WeakSpotSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.ClearWeakSpotMiningGrantee
// (Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InWeakSpotMiningGrantee                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMineableInterface::ClearWeakSpotMiningGrantee(class AActor* InWeakSpotMiningGrantee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "ClearWeakSpotMiningGrantee");

	Params::CrMineableInterface_ClearWeakSpotMiningGrantee Parms{};

	Parms.InWeakSpotMiningGrantee = InWeakSpotMiningGrantee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMineableInterface.DamageWeakSpot
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class FName&                      WeakSpotSocketName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InWeakSpotMiningGrantee                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMineableInterface::DamageWeakSpot(const class FName& WeakSpotSocketName, float Amount, class AActor* InWeakSpotMiningGrantee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "DamageWeakSpot");

	Params::CrMineableInterface_DamageWeakSpot Parms{};

	Parms.WeakSpotSocketName = WeakSpotSocketName;
	Parms.Amount = Amount;
	Parms.InWeakSpotMiningGrantee = InWeakSpotMiningGrantee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMineableInterface.MineResource
// (Native, Public)
// Parameters:
// float                                   MiningDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MiningRPM                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           MiningActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCrMinedResource                 ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCrMinedResource ICrMineableInterface::MineResource(float MiningDamage, float MiningRPM, class AActor* MiningActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "MineResource");

	Params::CrMineableInterface_MineResource Parms{};

	Parms.MiningDamage = MiningDamage;
	Parms.MiningRPM = MiningRPM;
	Parms.MiningActor = MiningActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.OnMiningLockedReleased
// (Native, Public)

void ICrMineableInterface::OnMiningLockedReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "OnMiningLockedReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMineableInterface.OnMiningStopped
// (Native, Public, BlueprintCallable)

void ICrMineableInterface::OnMiningStopped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "OnMiningStopped");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMineableInterface.OnOreReplenished
// (Native, Public)

void ICrMineableInterface::OnOreReplenished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "OnOreReplenished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMineableInterface.SetMiningGrantee
// (Native, Public)
// Parameters:
// class AActor*                           InMiningGrantee                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrMineableInterface::SetMiningGrantee(class AActor* InMiningGrantee)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "SetMiningGrantee");

	Params::CrMineableInterface_SetMiningGrantee Parms{};

	Parms.InMiningGrantee = InMiningGrantee;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMineableInterface.GetCurrentResourcesCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrMineableInterface::GetCurrentResourcesCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetCurrentResourcesCount");

	Params::CrMineableInterface_GetCurrentResourcesCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetDamageReceived
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMineableInterface::GetDamageReceived() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetDamageReceived");

	Params::CrMineableInterface_GetDamageReceived Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetDamageToDealForNextResourceGranting
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMineableInterface::GetDamageToDealForNextResourceGranting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetDamageToDealForNextResourceGranting");

	Params::CrMineableInterface_GetDamageToDealForNextResourceGranting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetGrantingMomentResourceCount
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMineableInterface::GetGrantingMomentResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetGrantingMomentResourceCount");

	Params::CrMineableInterface_GetGrantingMomentResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetGrantingResourceDamageThreshold
// (Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMineableInterface::GetGrantingResourceDamageThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetGrantingResourceDamageThreshold");

	Params::CrMineableInterface_GetGrantingResourceDamageThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetMaxResourceCount
// (Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ICrMineableInterface::GetMaxResourceCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetMaxResourceCount");

	Params::CrMineableInterface_GetMaxResourceCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetMiningGrantee
// (Native, Public, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ICrMineableInterface::GetMiningGrantee() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetMiningGrantee");

	Params::CrMineableInterface_GetMiningGrantee Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetResource
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrItemDataBase*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrItemDataBase* ICrMineableInterface::GetResource() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetResource");

	Params::CrMineableInterface_GetResource Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetWeakSpotCurrentHealth
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMineableInterface::GetWeakSpotCurrentHealth(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetWeakSpotCurrentHealth");

	Params::CrMineableInterface_GetWeakSpotCurrentHealth Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetWeakSpotCurrentHealthByName
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      WeakSpotSocketName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMineableInterface::GetWeakSpotCurrentHealthByName(const class FName& WeakSpotSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetWeakSpotCurrentHealthByName");

	Params::CrMineableInterface_GetWeakSpotCurrentHealthByName Parms{};

	Parms.WeakSpotSocketName = WeakSpotSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetWeakSpotMaxHealth
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMineableInterface::GetWeakSpotMaxHealth(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetWeakSpotMaxHealth");

	Params::CrMineableInterface_GetWeakSpotMaxHealth Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetWeakSpotMaxHealthByName
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      WeakSpotSocketName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ICrMineableInterface::GetWeakSpotMaxHealthByName(const class FName& WeakSpotSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetWeakSpotMaxHealthByName");

	Params::CrMineableInterface_GetWeakSpotMaxHealthByName Parms{};

	Parms.WeakSpotSocketName = WeakSpotSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.GetWeakSpotSocketName
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ICrMineableInterface::GetWeakSpotSocketName(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "GetWeakSpotSocketName");

	Params::CrMineableInterface_GetWeakSpotSocketName Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.IsOreDepleted
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMineableInterface::IsOreDepleted() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "IsOreDepleted");

	Params::CrMineableInterface_IsOreDepleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.IsWeakSpot
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMineableInterface::IsWeakSpot(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "IsWeakSpot");

	Params::CrMineableInterface_IsWeakSpot Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.IsWeakSpotActive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              HitComponent                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMineableInterface::IsWeakSpotActive(class UPrimitiveComponent* HitComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "IsWeakSpotActive");

	Params::CrMineableInterface_IsWeakSpotActive Parms{};

	Parms.HitComponent = HitComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMineableInterface.IsWeakSpotActiveByName
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FName&                      WeakSpotSocketName                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ICrMineableInterface::IsWeakSpotActiveByName(const class FName& WeakSpotSocketName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrMineableInterface", "IsWeakSpotActiveByName");

	Params::CrMineableInterface_IsWeakSpotActiveByName Parms{};

	Parms.WeakSpotSocketName = WeakSpotSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMiningBoostAttributeSet.OnRep_CurrentBoostMultiplierValue
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentBoostMultiplierValue                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMiningBoostAttributeSet::OnRep_CurrentBoostMultiplierValue(const struct FGameplayAttributeData& OldCurrentBoostMultiplierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningBoostAttributeSet", "OnRep_CurrentBoostMultiplierValue");

	Params::CrMiningBoostAttributeSet_OnRep_CurrentBoostMultiplierValue Parms{};

	Parms.OldCurrentBoostMultiplierValue = std::move(OldCurrentBoostMultiplierValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningBoostAttributeSet.OnRep_MaxBoostMultiplierValue
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxBoostMultiplierValue                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMiningBoostAttributeSet::OnRep_MaxBoostMultiplierValue(const struct FGameplayAttributeData& OldMaxBoostMultiplierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningBoostAttributeSet", "OnRep_MaxBoostMultiplierValue");

	Params::CrMiningBoostAttributeSet_OnRep_MaxBoostMultiplierValue Parms{};

	Parms.OldMaxBoostMultiplierValue = std::move(OldMaxBoostMultiplierValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningBoostAttributeSet.OnRep_MinBoostMultiplierValue
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinBoostMultiplierValue                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMiningBoostAttributeSet::OnRep_MinBoostMultiplierValue(const struct FGameplayAttributeData& OldMinBoostMultiplierValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningBoostAttributeSet", "OnRep_MinBoostMultiplierValue");

	Params::CrMiningBoostAttributeSet_OnRep_MinBoostMultiplierValue Parms{};

	Parms.OldMinBoostMultiplierValue = std::move(OldMinBoostMultiplierValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningComponent.BP_ClearMiningRequests
// (Final, Native, Public, BlueprintCallable)

void UCrMiningComponent::BP_ClearMiningRequests()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningComponent", "BP_ClearMiningRequests");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningComponent.BP_MineResourceRequestForActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           MineableActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsMiningWeakSpot                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             WeakSpotSocketName                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrMiningComponent::BP_MineResourceRequestForActor(class AActor* MineableActor, bool bIsMiningWeakSpot, class FName WeakSpotSocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningComponent", "BP_MineResourceRequestForActor");

	Params::CrMiningComponent_BP_MineResourceRequestForActor Parms{};

	Parms.MineableActor = MineableActor;
	Parms.bIsMiningWeakSpot = bIsMiningWeakSpot;
	Parms.WeakSpotSocketName = WeakSpotSocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningComponent.BP_MineResourceRequestForISM
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPhysicalMaterial*                InMineableISMPhysicalMaterial                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrMiningComponent::BP_MineResourceRequestForISM(class UPhysicalMaterial* InMineableISMPhysicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningComponent", "BP_MineResourceRequestForISM");

	Params::CrMiningComponent_BP_MineResourceRequestForISM Parms{};

	Parms.InMineableISMPhysicalMaterial = InMineableISMPhysicalMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningComponent.BP_OnMiningStopped
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           MineableActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrMiningComponent::BP_OnMiningStopped(class AActor* MineableActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningComponent", "BP_OnMiningStopped");

	Params::CrMiningComponent_BP_OnMiningStopped Parms{};

	Parms.MineableActor = MineableActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningComponent.DebugDepleteResource
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           MineableActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrMiningComponent::DebugDepleteResource(class AActor* MineableActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningComponent", "DebugDepleteResource");

	Params::CrMiningComponent_DebugDepleteResource Parms{};

	Parms.MineableActor = MineableActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningComponent.OnRepClientMiningProgress
// (Final, Native, Private)

void UCrMiningComponent::OnRepClientMiningProgress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningComponent", "OnRepClientMiningProgress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningComponent.ServerAddMinedResource
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class UCrItemDataBase*                  MinedResource                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrMiningComponent::ServerAddMinedResource(class UCrItemDataBase* MinedResource, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningComponent", "ServerAddMinedResource");

	Params::CrMiningComponent_ServerAddMinedResource Parms{};

	Parms.MinedResource = MinedResource;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningComponent.ServerDebugDepleteResource
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class AActor*                           MineableActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrMiningComponent::ServerDebugDepleteResource(class AActor* MineableActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningComponent", "ServerDebugDepleteResource");

	Params::CrMiningComponent_ServerDebugDepleteResource Parms{};

	Parms.MineableActor = MineableActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningLockingComponent.BP_RemoveLockOnAll
// (Final, Native, Public, BlueprintCallable)

void UCrMiningLockingComponent::BP_RemoveLockOnAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "BP_RemoveLockOnAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningLockingComponent.BP_RemoveLockOnAllLocalClientOnly
// (Final, Native, Public, BlueprintCallable)

void UCrMiningLockingComponent::BP_RemoveLockOnAllLocalClientOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "BP_RemoveLockOnAllLocalClientOnly");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningLockingComponent.ServerRemoveLockOnAll
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UCrMiningLockingComponent::ServerRemoveLockOnAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "ServerRemoveLockOnAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningLockingComponent.ServerTryLockingMineableTarget
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FCrMineableLockedTargetData&InMineableTargetData                                   (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCrMiningLockingComponent::ServerTryLockingMineableTarget(const struct FCrMineableLockedTargetData& InMineableTargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "ServerTryLockingMineableTarget");

	Params::CrMiningLockingComponent_ServerTryLockingMineableTarget Parms{};

	Parms.InMineableTargetData = std::move(InMineableTargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningLockingComponent.TryLockingForLocallyControlledCharacter
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                InHtResults                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrMiningLockingComponent::TryLockingForLocallyControlledCharacter(const struct FHitResult& InHtResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "TryLockingForLocallyControlledCharacter");

	Params::CrMiningLockingComponent_TryLockingForLocallyControlledCharacter Parms{};

	Parms.InHtResults = std::move(InHtResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMiningLockingComponent.GetLockedOnActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UCrMiningLockingComponent::GetLockedOnActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "GetLockedOnActor");

	Params::CrMiningLockingComponent_GetLockedOnActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMiningLockingComponent.GetLockedOnISMPhysicalMaterial
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UPhysicalMaterial*          ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UPhysicalMaterial* UCrMiningLockingComponent::GetLockedOnISMPhysicalMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "GetLockedOnISMPhysicalMaterial");

	Params::CrMiningLockingComponent_GetLockedOnISMPhysicalMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMiningLockingComponent.GetWeakSpotName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UCrMiningLockingComponent::GetWeakSpotName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "GetWeakSpotName");

	Params::CrMiningLockingComponent_GetWeakSpotName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMiningLockingComponent.IsWeakSpotLockedOn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrMiningLockingComponent::IsWeakSpotLockedOn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMiningLockingComponent", "IsWeakSpotLockedOn");

	Params::CrMiningLockingComponent_IsWeakSpotLockedOn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrModularPlaceCustom.SpawnOnStart
// (Final, Native, Public)
// Parameters:
// const class UAuActorPlacementData*      InPlacementData                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrModularPlaceCustom::SpawnOnStart(const class UAuActorPlacementData* InPlacementData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrModularPlaceCustom", "SpawnOnStart");

	Params::CrModularPlaceCustom_SpawnOnStart Parms{};

	Parms.InPlacementData = InPlacementData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerCharacterSettings.GetSoundForHitmarkType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ECrHitmarkType                          Hitmark                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class USoundCue>         ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class USoundCue> UCrPlayerCharacterSettings::GetSoundForHitmarkType(ECrHitmarkType Hitmark)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerCharacterSettings", "GetSoundForHitmarkType");

	Params::CrPlayerCharacterSettings_GetSoundForHitmarkType Parms{};

	Parms.Hitmark = Hitmark;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMovementSpeedMultiplierAttributeSet.OnRep_CurrentMovementSpeedMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentMovementSpeedMultiplier                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMovementSpeedMultiplierAttributeSet::OnRep_CurrentMovementSpeedMultiplier(const struct FGameplayAttributeData& OldCurrentMovementSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMovementSpeedMultiplierAttributeSet", "OnRep_CurrentMovementSpeedMultiplier");

	Params::CrMovementSpeedMultiplierAttributeSet_OnRep_CurrentMovementSpeedMultiplier Parms{};

	Parms.OldCurrentMovementSpeedMultiplier = std::move(OldCurrentMovementSpeedMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMovementSpeedMultiplierAttributeSet.OnRep_MaxMovementSpeedMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxMovementSpeedMultiplier                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMovementSpeedMultiplierAttributeSet::OnRep_MaxMovementSpeedMultiplier(const struct FGameplayAttributeData& OldMaxMovementSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMovementSpeedMultiplierAttributeSet", "OnRep_MaxMovementSpeedMultiplier");

	Params::CrMovementSpeedMultiplierAttributeSet_OnRep_MaxMovementSpeedMultiplier Parms{};

	Parms.OldMaxMovementSpeedMultiplier = std::move(OldMaxMovementSpeedMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMovementSpeedMultiplierAttributeSet.OnRep_MinMovementSpeedMultiplier
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinMovementSpeedMultiplier                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrMovementSpeedMultiplierAttributeSet::OnRep_MinMovementSpeedMultiplier(const struct FGameplayAttributeData& OldMinMovementSpeedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMovementSpeedMultiplierAttributeSet", "OnRep_MinMovementSpeedMultiplier");

	Params::CrMovementSpeedMultiplierAttributeSet_OnRep_MinMovementSpeedMultiplier Parms{};

	Parms.OldMinMovementSpeedMultiplier = std::move(OldMinMovementSpeedMultiplier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMultisample.DestroyWithFade
// (Final, Native, Public, BlueprintCallable)

void ACrMultisample::DestroyWithFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMultisample", "DestroyWithFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMultisample.PauseAll
// (Final, Native, Public, BlueprintCallable)

void ACrMultisample::PauseAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMultisample", "PauseAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMultisample.ResumeAll
// (Final, Native, Public, BlueprintCallable)

void ACrMultisample::ResumeAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMultisample", "ResumeAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBorderVisualSubsystem.OnRadiationLevelSet
// (Final, Native, Public)
// Parameters:
// int32                                   CurrentRadiationLevel                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewRadiationLevel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Immediately                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrRadiationBorderVisualSubsystem::OnRadiationLevelSet(int32 CurrentRadiationLevel, int32 NewRadiationLevel, bool Immediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBorderVisualSubsystem", "OnRadiationLevelSet");

	Params::CrRadiationBorderVisualSubsystem_OnRadiationLevelSet Parms{};

	Parms.CurrentRadiationLevel = CurrentRadiationLevel;
	Parms.NewRadiationLevel = NewRadiationLevel;
	Parms.Immediately = Immediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRadiationBorderVisualSubsystem.GetDefaultRadiationBordersSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UCrRadiationBordersSystemSettings*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UCrRadiationBordersSystemSettings* UCrRadiationBorderVisualSubsystem::GetDefaultRadiationBordersSettings(class UObject* Context) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRadiationBorderVisualSubsystem", "GetDefaultRadiationBordersSettings");

	Params::CrRadiationBorderVisualSubsystem_GetDefaultRadiationBordersSettings Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMultisampleMultiSensor.DecreaseOverlapNum
// (Final, Native, Public, BlueprintCallable)

void UCrMultisampleMultiSensor::DecreaseOverlapNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMultisampleMultiSensor", "DecreaseOverlapNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMultisampleMultiSensor.IncreaseOverlapNum
// (Final, Native, Public, BlueprintCallable)

void UCrMultisampleMultiSensor::IncreaseOverlapNum()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMultisampleMultiSensor", "IncreaseOverlapNum");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMultisampleMultiSensor.IsInAnySensor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrMultisampleMultiSensor::IsInAnySensor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMultisampleMultiSensor", "IsInAnySensor");

	Params::CrMultisampleMultiSensor_IsInAnySensor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrMultisampleSpawnComponent.DestroyMultisampleWithFade
// (Final, Native, Public, BlueprintCallable)

void UCrMultisampleSpawnComponent::DestroyMultisampleWithFade()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMultisampleSpawnComponent", "DestroyMultisampleWithFade");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrMultisampleSpawnComponent.SpawnMultisample
// (Final, Native, Public, BlueprintCallable)

void UCrMultisampleSpawnComponent::SpawnMultisample()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrMultisampleSpawnComponent", "SpawnMultisample");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrObjectivesOwner.OnObjectiveStatusChanged
// (Final, Native, Public)
// Parameters:
// const struct FCrObjectiveEntryStatus&   EntryStatus                                            (ConstParm, Parm, NativeAccessSpecifierPublic)

void ACrObjectivesOwner::OnObjectiveStatusChanged(const struct FCrObjectiveEntryStatus& EntryStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrObjectivesOwner", "OnObjectiveStatusChanged");

	Params::CrObjectivesOwner_OnObjectiveStatusChanged Parms{};

	Parms.EntryStatus = std::move(EntryStatus);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrObjectivesOwner.PostSaveLoaded
// (Final, Native, Public)

void ACrObjectivesOwner::PostSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrObjectivesOwner", "PostSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrObjectivesSubsystem.ActivatePendingObjective
// (Final, Native, Public)

void UCrObjectivesSubsystem::ActivatePendingObjective()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrObjectivesSubsystem", "ActivatePendingObjective");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrObjectivesSubsystem.ActivationObjectiveExec
// (Final, Native, Public, HasDefaults)
// Parameters:
// const struct FGuid&                     EntryID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrObjectivesSubsystem::ActivationObjectiveExec(const struct FGuid& EntryID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrObjectivesSubsystem", "ActivationObjectiveExec");

	Params::CrObjectivesSubsystem_ActivationObjectiveExec Parms{};

	Parms.EntryID = std::move(EntryID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrObjectivesSubsystem.OnContextualEventExecuted
// (Final, Native, Protected)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ContextValue                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrObjectivesSubsystem::OnContextualEventExecuted(class AActor* Target, class FName Context, class FName ContextValue, class AActor* TargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrObjectivesSubsystem", "OnContextualEventExecuted");

	Params::CrObjectivesSubsystem_OnContextualEventExecuted Parms{};

	Parms.Target = Target;
	Parms.Context = Context;
	Parms.ContextValue = ContextValue;
	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrObjectivesSubsystem.TryActivateObjective
// (Final, Native, Public, HasDefaults)
// Parameters:
// const struct FGuid&                     EntryID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitForDialogue                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrObjectivesSubsystem::TryActivateObjective(const struct FGuid& EntryID, bool bWaitForDialogue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrObjectivesSubsystem", "TryActivateObjective");

	Params::CrObjectivesSubsystem_TryActivateObjective Parms{};

	Parms.EntryID = std::move(EntryID);
	Parms.bWaitForDialogue = bWaitForDialogue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreSubsystem.BP_IsInfiniteOreHarvestableByPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UPhysicalMaterial*          InPhysMat                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrOreSubsystem::BP_IsInfiniteOreHarvestableByPlayer(const class UPhysicalMaterial* InPhysMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreSubsystem", "BP_IsInfiniteOreHarvestableByPlayer");

	Params::CrOreSubsystem_BP_IsInfiniteOreHarvestableByPlayer Parms{};

	Parms.InPhysMat = InPhysMat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrOreSubsystem.OnEnviroWaveFinihed
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEnviroWave                             WaveType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     WaveSettings                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCrOreSubsystem::OnEnviroWaveFinihed(EEnviroWave WaveType, const struct FCrEnviroWaveSettings& WaveSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreSubsystem", "OnEnviroWaveFinihed");

	Params::CrOreSubsystem_OnEnviroWaveFinihed Parms{};

	Parms.WaveType = WaveType;
	Parms.WaveSettings = std::move(WaveSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOreSubsystem.OnEnviroWaveStarted
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEnviroWave                             InWaveType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        InWaveStage                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     InWaveSettings                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   InWaveProgress                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrOreSubsystem::OnEnviroWaveStarted(EEnviroWave InWaveType, EEnviroWaveStage InWaveStage, const struct FCrEnviroWaveSettings& InWaveSettings, float InWaveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOreSubsystem", "OnEnviroWaveStarted");

	Params::CrOreSubsystem_OnEnviroWaveStarted Parms{};

	Parms.InWaveType = InWaveType;
	Parms.InWaveStage = InWaveStage;
	Parms.InWaveSettings = std::move(InWaveSettings);
	Parms.InWaveProgress = InWaveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTeleportReplicator.OnRep_Teleporters
// (Final, Native, Private)

void ACrTeleportReplicator::OnRep_Teleporters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTeleportReplicator", "OnRep_Teleporters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOverlapTriggerComponent.OnBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrOverlapTriggerComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOverlapTriggerComponent", "OnBeginOverlap");

	Params::CrOverlapTriggerComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOverlapTriggerComponent.OnEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrOverlapTriggerComponent::OnEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOverlapTriggerComponent", "OnEndOverlap");

	Params::CrOverlapTriggerComponent_OnEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOxygenAttributeSet.OnRep_CurrentOxygen
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentOxygen                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrOxygenAttributeSet::OnRep_CurrentOxygen(const struct FGameplayAttributeData& OldCurrentOxygen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOxygenAttributeSet", "OnRep_CurrentOxygen");

	Params::CrOxygenAttributeSet_OnRep_CurrentOxygen Parms{};

	Parms.OldCurrentOxygen = std::move(OldCurrentOxygen);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOxygenAttributeSet.OnRep_MaxOxygen
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxOxygen                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrOxygenAttributeSet::OnRep_MaxOxygen(const struct FGameplayAttributeData& OldMaxOxygen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOxygenAttributeSet", "OnRep_MaxOxygen");

	Params::CrOxygenAttributeSet_OnRep_MaxOxygen Parms{};

	Parms.OldMaxOxygen = std::move(OldMaxOxygen);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrOxygenAttributeSet.OnRep_MinOxygen
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinOxygen                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrOxygenAttributeSet::OnRep_MinOxygen(const struct FGameplayAttributeData& OldMinOxygen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrOxygenAttributeSet", "OnRep_MinOxygen");

	Params::CrOxygenAttributeSet_OnRep_MinOxygen Parms{};

	Parms.OldMinOxygen = std::move(OldMinOxygen);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrZiplinePoint.NativeOnNeighbourRemoved
// (Final, Native, Private)
// Parameters:
// const struct FCrMassEntityReplicationHelper&InZipline                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::NativeOnNeighbourRemoved(const struct FCrMassEntityReplicationHelper& InZipline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "NativeOnNeighbourRemoved");

	Params::CrZiplinePoint_NativeOnNeighbourRemoved Parms{};

	Parms.InZipline = std::move(InZipline);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrZiplinePoint.OnActivityModified
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bActive                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnActivityModified(bool bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnActivityModified");

	Params::CrZiplinePoint_OnActivityModified Parms{};

	Parms.bActive = bActive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnConnectionsModified
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FVector_NetQuantize>&ActiveLocations                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FVector_NetQuantize>&InactiveLocations                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnConnectionsModified(const TArray<struct FVector_NetQuantize>& ActiveLocations, const TArray<struct FVector_NetQuantize>& InactiveLocations)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnConnectionsModified");

	Params::CrZiplinePoint_OnConnectionsModified Parms{};

	Parms.ActiveLocations = std::move(ActiveLocations);
	Parms.InactiveLocations = std::move(InactiveLocations);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnHideBlockingSphere
// (Event, Public, BlueprintEvent)

void ACrZiplinePoint::OnHideBlockingSphere()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnHideBlockingSphere");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrZiplinePoint.OnObstructionChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bObstructed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnObstructionChanged(bool bObstructed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnObstructionChanged");

	Params::CrZiplinePoint_OnObstructionChanged Parms{};

	Parms.bObstructed = bObstructed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnOccupied
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnOccupied(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnOccupied");

	Params::CrZiplinePoint_OnOccupied Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnPlayerRotationChanged
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FRotator&                  PlayerRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnPlayerRotationChanged(const struct FRotator& PlayerRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnPlayerRotationChanged");

	Params::CrZiplinePoint_OnPlayerRotationChanged Parms{};

	Parms.PlayerRotation = std::move(PlayerRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnPlayerRotationFinished
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector_NetQuantize&       NewTargetLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  NewRotation                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnPlayerRotationFinished(const struct FVector_NetQuantize& NewTargetLocation, const struct FRotator& NewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnPlayerRotationFinished");

	Params::CrZiplinePoint_OnPlayerRotationFinished Parms{};

	Parms.NewTargetLocation = std::move(NewTargetLocation);
	Parms.NewRotation = std::move(NewRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnPlayerRotationStarted
// (Event, Public, BlueprintEvent)

void ACrZiplinePoint::OnPlayerRotationStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnPlayerRotationStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrZiplinePoint.OnShowBlockingSphere
// (Event, Public, BlueprintEvent)

void ACrZiplinePoint::OnShowBlockingSphere()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnShowBlockingSphere");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrZiplinePoint.OnStopTravellingTo
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bCancelled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnStopTravellingTo(class ACrCharacterPlayerBase* InPlayer, bool bCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnStopTravellingTo");

	Params::CrZiplinePoint_OnStopTravellingTo Parms{};

	Parms.InPlayer = InPlayer;
	Parms.bCancelled = bCancelled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnTargeted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnTargeted(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnTargeted");

	Params::CrZiplinePoint_OnTargeted Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnTravelBlocked
// (Event, Protected, BlueprintEvent)

void ACrZiplinePoint::OnTravelBlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnTravelBlocked");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrZiplinePoint.OnTravelEnded
// (Event, Protected, BlueprintEvent)

void ACrZiplinePoint::OnTravelEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnTravelEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrZiplinePoint.OnTravellingTo
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnTravellingTo(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnTravellingTo");

	Params::CrZiplinePoint_OnTravellingTo Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnTravelStarted
// (Event, Protected, BlueprintEvent)

void ACrZiplinePoint::OnTravelStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnTravelStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrZiplinePoint.OnUnoccupied
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnUnoccupied(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnUnoccupied");

	Params::CrZiplinePoint_OnUnoccupied Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnUntargeted
// (Event, Protected, BlueprintEvent)
// Parameters:
// class ACrCharacterPlayerBase*           InPlayer                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrZiplinePoint::OnUntargeted(class ACrCharacterPlayerBase* InPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnUntargeted");

	Params::CrZiplinePoint_OnUntargeted Parms{};

	Parms.InPlayer = InPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrZiplinePoint.OnZiplineLocallyCancelled
// (Event, Public, BlueprintEvent)

void ACrZiplinePoint::OnZiplineLocallyCancelled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnZiplineLocallyCancelled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrZiplinePoint.OnZiplineModeLocallyStarted
// (Event, Public, BlueprintEvent)

void ACrZiplinePoint::OnZiplineModeLocallyStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnZiplineModeLocallyStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrZiplinePoint.OnZiplineTravelLocallyStarted
// (Event, Public, BlueprintEvent)

void ACrZiplinePoint::OnZiplineTravelLocallyStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrZiplinePoint", "OnZiplineTravelLocallyStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrPackageTransportReplicator.OnPreSaveStart
// (Final, Native, Private)

void ACrPackageTransportReplicator::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPackageTransportReplicator", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPackageTransportReplicator.OnSaveLoaded
// (Final, Native, Private)

void ACrPackageTransportReplicator::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPackageTransportReplicator", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPackageTransportSubsystem.CheckSendingProgress
// (Final, Native, Private)
// Parameters:
// const struct FCrMassEntityReplicationHelper&InSender                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPackageTransportSubsystem::CheckSendingProgress(const struct FCrMassEntityReplicationHelper& InSender)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPackageTransportSubsystem", "CheckSendingProgress");

	Params::CrPackageTransportSubsystem_CheckSendingProgress Parms{};

	Parms.InSender = std::move(InSender);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPackageTransportSubsystem.OnReceiverInventoryChanged
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         InReceiver                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPackageTransportSubsystem::OnReceiverInventoryChanged(const struct FMassEntityHandle& InReceiver, class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPackageTransportSubsystem", "OnReceiverInventoryChanged");

	Params::CrPackageTransportSubsystem_OnReceiverInventoryChanged Parms{};

	Parms.InReceiver = std::move(InReceiver);
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPackageTransportSubsystem.OnReceiverStateChanged
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         InReceiver                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPackageTransportSubsystem::OnReceiverStateChanged(const struct FMassEntityHandle& InReceiver, class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPackageTransportSubsystem", "OnReceiverStateChanged");

	Params::CrPackageTransportSubsystem_OnReceiverStateChanged Parms{};

	Parms.InReceiver = std::move(InReceiver);
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPackageTransportSubsystem.OnSenderInventoryChanged
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         InSender                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPackageTransportSubsystem::OnSenderInventoryChanged(const struct FMassEntityHandle& InSender, class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPackageTransportSubsystem", "OnSenderInventoryChanged");

	Params::CrPackageTransportSubsystem_OnSenderInventoryChanged Parms{};

	Parms.InSender = std::move(InSender);
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPackageTransportSubsystem.OnSenderStateChanged
// (Final, Native, Private)
// Parameters:
// const struct FMassEntityHandle&         InSender                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InName                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPackageTransportSubsystem::OnSenderStateChanged(const struct FMassEntityHandle& InSender, class FName InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPackageTransportSubsystem", "OnSenderStateChanged");

	Params::CrPackageTransportSubsystem_OnSenderStateChanged Parms{};

	Parms.InSender = std::move(InSender);
	Parms.InName = InName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStorageBox.OnRep_StoredItems
// (Final, Native, Private)

void ACrStorageBox::OnRep_StoredItems()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStorageBox", "OnRep_StoredItems");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStorageBox.ServerRemoveItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// const struct FAuItemId&                 InItemId                                               (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrStorageBox::ServerRemoveItem(const struct FAuItemId& InItemId, int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStorageBox", "ServerRemoveItem");

	Params::CrStorageBox_ServerRemoveItem Parms{};

	Parms.InItemId = std::move(InItemId);
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPCGActorBase.BP_OnPostSeedChanged
// (Event, Protected, BlueprintEvent)

void ACrPCGActorBase::BP_OnPostSeedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPCGActorBase", "BP_OnPostSeedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrPCGActorBase.BP_OnPreSeedChanged
// (Event, Protected, BlueprintEvent)

void ACrPCGActorBase::BP_OnPreSeedChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPCGActorBase", "BP_OnPreSeedChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrPCGActorBase.OnCellSpawnedCheckTimerElapsed
// (Final, Native, Private)

void ACrPCGActorBase::OnCellSpawnedCheckTimerElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPCGActorBase", "OnCellSpawnedCheckTimerElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPCGActorBase.TriggerGeneration
// (Final, Native, Private)

void ACrPCGActorBase::TriggerGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPCGActorBase", "TriggerGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTargetingBPF.MakeConeTraceRandomPatternTraceData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPelletsCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRandomSeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAuCustomTraceDataHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuCustomTraceDataHandle UCrTargetingBPF::MakeConeTraceRandomPatternTraceData(float InRange, int32 InPelletsCount, float InRandomSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrTargetingBPF", "MakeConeTraceRandomPatternTraceData");

	Params::CrTargetingBPF_MakeConeTraceRandomPatternTraceData Parms{};

	Parms.InRange = InRange;
	Parms.InPelletsCount = InPelletsCount;
	Parms.InRandomSeed = InRandomSeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrTargetingBPF.MakeConeTraceSpecificPatternTraceData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UCrPelletsSpreadDataAsset>&InPattern                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCameraTraceCutoff                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAuCustomTraceDataHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuCustomTraceDataHandle UCrTargetingBPF::MakeConeTraceSpecificPatternTraceData(float InRange, const TSoftObjectPtr<class UCrPelletsSpreadDataAsset>& InPattern, float InCameraTraceCutoff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrTargetingBPF", "MakeConeTraceSpecificPatternTraceData");

	Params::CrTargetingBPF_MakeConeTraceSpecificPatternTraceData Parms{};

	Parms.InRange = InRange;
	Parms.InPattern = InPattern;
	Parms.InCameraTraceCutoff = InCameraTraceCutoff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrTargetingBPF.MakePiercingTraceData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PossibleEnemyPiercings                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        OriginalTraceResults                                   (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FAuCustomTraceDataHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuCustomTraceDataHandle UCrTargetingBPF::MakePiercingTraceData(float InRange, int32 PossibleEnemyPiercings, const TArray<struct FHitResult>& OriginalTraceResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrTargetingBPF", "MakePiercingTraceData");

	Params::CrTargetingBPF_MakePiercingTraceData Parms{};

	Parms.InRange = InRange;
	Parms.PossibleEnemyPiercings = PossibleEnemyPiercings;
	Parms.OriginalTraceResults = std::move(OriginalTraceResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrTargetingBPF.MakeTraceDataByPiercingTraceConfig
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAbilitySystemComponent*          InASC                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuCustomTargetHandle&     InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PossibleEnemyPiercings                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FHitResult>&        OriginalHitResults                                     (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FAuCustomTraceDataHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuCustomTraceDataHandle UCrTargetingBPF::MakeTraceDataByPiercingTraceConfig(class UAbilitySystemComponent* InASC, const struct FAuCustomTargetHandle& InHandle, float InRange, int32 PossibleEnemyPiercings, const TArray<struct FHitResult>& OriginalHitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrTargetingBPF", "MakeTraceDataByPiercingTraceConfig");

	Params::CrTargetingBPF_MakeTraceDataByPiercingTraceConfig Parms{};

	Parms.InASC = InASC;
	Parms.InHandle = std::move(InHandle);
	Parms.InRange = InRange;
	Parms.PossibleEnemyPiercings = PossibleEnemyPiercings;
	Parms.OriginalHitResults = std::move(OriginalHitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrTargetingBPF.MakeTraceDataByTraceConfig
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAbilitySystemComponent*          InASC                                                  (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuCustomTargetHandle&     InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRange                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InPelletsCount                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InRandomSeed                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSoftObjectPtr<class UCrPelletsSpreadDataAsset>&InPattern                                              (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCameraTraceCutoff                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAuCustomTraceDataHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAuCustomTraceDataHandle UCrTargetingBPF::MakeTraceDataByTraceConfig(class UAbilitySystemComponent* InASC, const struct FAuCustomTargetHandle& InHandle, float InRange, int32 InPelletsCount, float InRandomSeed, const TSoftObjectPtr<class UCrPelletsSpreadDataAsset>& InPattern, float InCameraTraceCutoff)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrTargetingBPF", "MakeTraceDataByTraceConfig");

	Params::CrTargetingBPF_MakeTraceDataByTraceConfig Parms{};

	Parms.InASC = InASC;
	Parms.InHandle = std::move(InHandle);
	Parms.InRange = InRange;
	Parms.InPelletsCount = InPelletsCount;
	Parms.InRandomSeed = InRandomSeed;
	Parms.InPattern = InPattern;
	Parms.InCameraTraceCutoff = InCameraTraceCutoff;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPCGGatherableSpawnerVolume.OnCleanupFinished
// (Final, Native, Private)
// Parameters:
// class UPCGComponent*                    InPCGComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPCGGatherableSpawnerVolume::OnCleanupFinished(class UPCGComponent* InPCGComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPCGGatherableSpawnerVolume", "OnCleanupFinished");

	Params::CrPCGGatherableSpawnerVolume_OnCleanupFinished Parms{};

	Parms.InPCGComponent = InPCGComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingValueDiscreteDynamic_AudioOutputDevice.DefaultDeviceChanged
// (Final, Native, Public)
// Parameters:
// EAudioDeviceChangedRole                 InRole                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingValueDiscreteDynamic_AudioOutputDevice::DefaultDeviceChanged(EAudioDeviceChangedRole InRole, const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingValueDiscreteDynamic_AudioOutputDevice", "DefaultDeviceChanged");

	Params::CrSettingValueDiscreteDynamic_AudioOutputDevice_DefaultDeviceChanged Parms{};

	Parms.InRole = InRole;
	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingValueDiscreteDynamic_AudioOutputDevice.DeviceAddedOrRemoved
// (Final, Native, Public)
// Parameters:
// const class FString&                    DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingValueDiscreteDynamic_AudioOutputDevice::DeviceAddedOrRemoved(const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingValueDiscreteDynamic_AudioOutputDevice", "DeviceAddedOrRemoved");

	Params::CrSettingValueDiscreteDynamic_AudioOutputDevice_DeviceAddedOrRemoved Parms{};

	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingValueDiscreteDynamic_AudioOutputDevice.OnAudioOutputDevicesObtained
// (Final, Native, Public, HasOutParams)
// Parameters:
// const TArray<struct FAudioOutputDeviceInfo>&AvailableDevices                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UCrSettingValueDiscreteDynamic_AudioOutputDevice::OnAudioOutputDevicesObtained(const TArray<struct FAudioOutputDeviceInfo>& AvailableDevices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingValueDiscreteDynamic_AudioOutputDevice", "OnAudioOutputDevicesObtained");

	Params::CrSettingValueDiscreteDynamic_AudioOutputDevice_OnAudioOutputDevicesObtained Parms{};

	Parms.AvailableDevices = std::move(AvailableDevices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingValueDiscreteDynamic_AudioOutputDevice.OnCompletedDeviceSwap
// (Final, Native, Public, HasOutParams)
// Parameters:
// const struct FSwapAudioOutputResult&    SwapResult                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrSettingValueDiscreteDynamic_AudioOutputDevice::OnCompletedDeviceSwap(const struct FSwapAudioOutputResult& SwapResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingValueDiscreteDynamic_AudioOutputDevice", "OnCompletedDeviceSwap");

	Params::CrSettingValueDiscreteDynamic_AudioOutputDevice_OnCompletedDeviceSwap Parms{};

	Parms.SwapResult = std::move(SwapResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPointOfInterestMarkerActor.SwitchPointOfInterestState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPointOfInterestState                   NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ForceDowngrade                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrPointOfInterestMarkerActor::SwitchPointOfInterestState(EPointOfInterestState NewState, bool ForceDowngrade)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPointOfInterestMarkerActor", "SwitchPointOfInterestState");

	Params::CrPointOfInterestMarkerActor_SwitchPointOfInterestState Parms{};

	Parms.NewState = NewState;
	Parms.ForceDowngrade = ForceDowngrade;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPointOfInterestMarkerActor.GetPointOfInterestState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPointOfInterestState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPointOfInterestState ACrPointOfInterestMarkerActor::GetPointOfInterestState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPointOfInterestMarkerActor", "GetPointOfInterestState");

	Params::CrPointOfInterestMarkerActor_GetPointOfInterestState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPointOfInterestMarkerActor.GetPointOfInterestType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECrPointOfInterestType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrPointOfInterestType ACrPointOfInterestMarkerActor::GetPointOfInterestType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPointOfInterestMarkerActor", "GetPointOfInterestType");

	Params::CrPointOfInterestMarkerActor_GetPointOfInterestType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSplineBasedBuildingActorsVisualsSpawnerWorldSubsystem.RegisterSplineBasedBuildingActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrBuildingSplineActorBase*       BuildingSplineActorBase                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSplineBasedBuildingActorsVisualsSpawnerWorldSubsystem::RegisterSplineBasedBuildingActor(class ACrBuildingSplineActorBase* BuildingSplineActorBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSplineBasedBuildingActorsVisualsSpawnerWorldSubsystem", "RegisterSplineBasedBuildingActor");

	Params::CrSplineBasedBuildingActorsVisualsSpawnerWorldSubsystem_RegisterSplineBasedBuildingActor Parms{};

	Parms.BuildingSplineActorBase = BuildingSplineActorBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSplineBasedBuildingActorsVisualsSpawnerWorldSubsystem.UnRegisterSplineBasedBuildingActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACrBuildingSplineActorBase*       BuildingSplineActorBase                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSplineBasedBuildingActorsVisualsSpawnerWorldSubsystem::UnRegisterSplineBasedBuildingActor(class ACrBuildingSplineActorBase* BuildingSplineActorBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSplineBasedBuildingActorsVisualsSpawnerWorldSubsystem", "UnRegisterSplineBasedBuildingActor");

	Params::CrSplineBasedBuildingActorsVisualsSpawnerWorldSubsystem_UnRegisterSplineBasedBuildingActor Parms{};

	Parms.BuildingSplineActorBase = BuildingSplineActorBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPCGVolume.OnCleanupFinished
// (Final, Native, Private)
// Parameters:
// class UPCGComponent*                    InPCGComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrPCGVolume::OnCleanupFinished(class UPCGComponent* InPCGComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPCGVolume", "OnCleanupFinished");

	Params::CrPCGVolume_OnCleanupFinished Parms{};

	Parms.InPCGComponent = InPCGComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlatformEmulationSettings.GetKnownDeviceProfiles
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCrPlatformEmulationSettings::GetKnownDeviceProfiles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlatformEmulationSettings", "GetKnownDeviceProfiles");

	Params::CrPlatformEmulationSettings_GetKnownDeviceProfiles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlatformEmulationSettings.GetKnownPlatformIds
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UCrPlatformEmulationSettings::GetKnownPlatformIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlatformEmulationSettings", "GetKnownPlatformIds");

	Params::CrPlatformEmulationSettings_GetKnownPlatformIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPlayerDialogueComponent.OnDialogueFinished
// (Final, Native, Protected)

void UCrPlayerDialogueComponent::OnDialogueFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerDialogueComponent", "OnDialogueFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerSoundSubsystem.AddAdditionalTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPlayerSoundSubsystem::AddAdditionalTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerSoundSubsystem", "AddAdditionalTag");

	Params::CrPlayerSoundSubsystem_AddAdditionalTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerSoundSubsystem.OnPawnPossessedChanged
// (Final, Native, Private)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPlayerSoundSubsystem::OnPawnPossessedChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerSoundSubsystem", "OnPawnPossessedChanged");

	Params::CrPlayerSoundSubsystem_OnPawnPossessedChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerSoundSubsystem.PauseAll
// (Final, Native, Public, BlueprintCallable)

void UCrPlayerSoundSubsystem::PauseAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerSoundSubsystem", "PauseAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerSoundSubsystem.RemoveAdditionalTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrPlayerSoundSubsystem::RemoveAdditionalTag(const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerSoundSubsystem", "RemoveAdditionalTag");

	Params::CrPlayerSoundSubsystem_RemoveAdditionalTag Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPlayerSoundSubsystem.ResumeAll
// (Final, Native, Public, BlueprintCallable)

void UCrPlayerSoundSubsystem::ResumeAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPlayerSoundSubsystem", "ResumeAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrRecoilComponent.BP_GetRealCurrentSpread
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrRecoilComponent::BP_GetRealCurrentSpread() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrRecoilComponent", "BP_GetRealCurrentSpread");

	Params::CrRecoilComponent_BP_GetRealCurrentSpread Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrShieldAttributeSet.OnRep_CurrentShield
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentShield                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrShieldAttributeSet::OnRep_CurrentShield(const struct FGameplayAttributeData& OldCurrentShield)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrShieldAttributeSet", "OnRep_CurrentShield");

	Params::CrShieldAttributeSet_OnRep_CurrentShield Parms{};

	Parms.OldCurrentShield = std::move(OldCurrentShield);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrShieldAttributeSet.OnRep_MaxShield
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxShield                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrShieldAttributeSet::OnRep_MaxShield(const struct FGameplayAttributeData& OldMaxShield)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrShieldAttributeSet", "OnRep_MaxShield");

	Params::CrShieldAttributeSet_OnRep_MaxShield Parms{};

	Parms.OldMaxShield = std::move(OldMaxShield);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrShieldAttributeSet.OnRep_MinShield
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinShield                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrShieldAttributeSet::OnRep_MinShield(const struct FGameplayAttributeData& OldMinShield)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrShieldAttributeSet", "OnRep_MinShield");

	Params::CrShieldAttributeSet_OnRep_MinShield Parms{};

	Parms.OldMinShield = std::move(OldMinShield);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStartScreenWidget.OnAnimationEnd
// (Final, Native, Private)

void UCrStartScreenWidget::OnAnimationEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStartScreenWidget", "OnAnimationEnd");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrStartScreenWidget.OnButtonClicked
// (Final, Native, Private)

void UCrStartScreenWidget::OnButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrStartScreenWidget", "OnButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTeleporter.OnPlayerArrived
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bLocalPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTeleporter::OnPlayerArrived(bool bLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTeleporter", "OnPlayerArrived");

	Params::CrTeleporter_OnPlayerArrived Parms{};

	Parms.bLocalPlayer = bLocalPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrTeleporter.OnTeleporterUsed
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bLocalPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrTeleporter::OnTeleporterUsed(bool bLocalPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTeleporter", "OnTeleporterUsed");

	Params::CrTeleporter_OnTeleporterUsed Parms{};

	Parms.bLocalPlayer = bLocalPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrTemperatureAttributeSet.OnRep_CurrentTemperature
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentTemperature                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrTemperatureAttributeSet::OnRep_CurrentTemperature(const struct FGameplayAttributeData& OldCurrentTemperature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTemperatureAttributeSet", "OnRep_CurrentTemperature");

	Params::CrTemperatureAttributeSet_OnRep_CurrentTemperature Parms{};

	Parms.OldCurrentTemperature = std::move(OldCurrentTemperature);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTemperatureAttributeSet.OnRep_MaxTemperature
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxTemperature                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrTemperatureAttributeSet::OnRep_MaxTemperature(const struct FGameplayAttributeData& OldMaxTemperature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTemperatureAttributeSet", "OnRep_MaxTemperature");

	Params::CrTemperatureAttributeSet_OnRep_MaxTemperature Parms{};

	Parms.OldMaxTemperature = std::move(OldMaxTemperature);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrTemperatureAttributeSet.OnRep_MinTemperature
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinTemperature                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrTemperatureAttributeSet::OnRep_MinTemperature(const struct FGameplayAttributeData& OldMinTemperature)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrTemperatureAttributeSet", "OnRep_MinTemperature");

	Params::CrTemperatureAttributeSet_OnRep_MinTemperature Parms{};

	Parms.OldMinTemperature = std::move(OldMinTemperature);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrToxicityAttributeSet.OnRep_CurrentToxicity
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldCurrentToxicity                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrToxicityAttributeSet::OnRep_CurrentToxicity(const struct FGameplayAttributeData& OldCurrentToxicity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrToxicityAttributeSet", "OnRep_CurrentToxicity");

	Params::CrToxicityAttributeSet_OnRep_CurrentToxicity Parms{};

	Parms.OldCurrentToxicity = std::move(OldCurrentToxicity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrToxicityAttributeSet.OnRep_MaxToxicity
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMaxToxicity                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrToxicityAttributeSet::OnRep_MaxToxicity(const struct FGameplayAttributeData& OldMaxToxicity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrToxicityAttributeSet", "OnRep_MaxToxicity");

	Params::CrToxicityAttributeSet_OnRep_MaxToxicity Parms{};

	Parms.OldMaxToxicity = std::move(OldMaxToxicity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrToxicityAttributeSet.OnRep_MinToxicity
// (Native, Protected, HasOutParams)
// Parameters:
// const struct FGameplayAttributeData&    OldMinToxicity                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrToxicityAttributeSet::OnRep_MinToxicity(const struct FGameplayAttributeData& OldMinToxicity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrToxicityAttributeSet", "OnRep_MinToxicity");

	Params::CrToxicityAttributeSet_OnRep_MinToxicity Parms{};

	Parms.OldMinToxicity = std::move(OldMinToxicity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrUW_BuildingSelection.OnBuildingNameChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const class FText&                      InName                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UCrUW_BuildingSelection::OnBuildingNameChanged(const class FText& InName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrUW_BuildingSelection", "OnBuildingNameChanged");

	Params::CrUW_BuildingSelection_OnBuildingNameChanged Parms{};

	Parms.InName = std::move(InName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrUW_BuildingSelection.OnTypeChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// ECrBuildingType                         InType                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrUW_BuildingSelection::OnTypeChanged(ECrBuildingType InType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrUW_BuildingSelection", "OnTypeChanged");

	Params::CrUW_BuildingSelection_OnTypeChanged Parms{};

	Parms.InType = InType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrWeaponActor.DebugShowCosmeticImpactHitResultTrace
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                InHitResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrWeaponActor::DebugShowCosmeticImpactHitResultTrace(const struct FHitResult& InHitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "DebugShowCosmeticImpactHitResultTrace");

	Params::CrWeaponActor_DebugShowCosmeticImpactHitResultTrace Parms{};

	Parms.InHitResult = std::move(InHitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponActor.GetAimSocketTransformForADS
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ACrWeaponActor::GetAimSocketTransformForADS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "GetAimSocketTransformForADS");

	Params::CrWeaponActor_GetAimSocketTransformForADS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.GetLeftHandIKSocketTransform
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform*                      OutTransform                                           (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrWeaponActor::GetLeftHandIKSocketTransform(class FName SocketName, struct FTransform* OutTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "GetLeftHandIKSocketTransform");

	Params::CrWeaponActor_GetLeftHandIKSocketTransform Parms{};

	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTransform != nullptr)
		*OutTransform = std::move(Parms.OutTransform);

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.GetModsData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<TSoftObjectPtr<class UCrWeaponModDataAsset>>*OutCurrentlyAppliedMods                                (Parm, OutParm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrWeaponActor::GetModsData(TArray<TSoftObjectPtr<class UCrWeaponModDataAsset>>* OutCurrentlyAppliedMods)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "GetModsData");

	Params::CrWeaponActor_GetModsData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCurrentlyAppliedMods != nullptr)
		*OutCurrentlyAppliedMods = std::move(Parms.OutCurrentlyAppliedMods);

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.GetWeaponPartsByIdentifierTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              IdentifierTag                                          (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPrimitiveComponent*> ACrWeaponActor::GetWeaponPartsByIdentifierTag(const struct FGameplayTag& IdentifierTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "GetWeaponPartsByIdentifierTag");

	Params::CrWeaponActor_GetWeaponPartsByIdentifierTag Parms{};

	Parms.IdentifierTag = std::move(IdentifierTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.GetWeaponPartsBySlotTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              SlotTag                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPrimitiveComponent*>      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPrimitiveComponent*> ACrWeaponActor::GetWeaponPartsBySlotTag(const struct FGameplayTag& SlotTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "GetWeaponPartsBySlotTag");

	Params::CrWeaponActor_GetWeaponPartsBySlotTag Parms{};

	Parms.SlotTag = std::move(SlotTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.GetWeaponSocketTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ERelativeTransformSpace                 TransformSpace                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ACrWeaponActor::GetWeaponSocketTransform(class FName SocketName, ERelativeTransformSpace TransformSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "GetWeaponSocketTransform");

	Params::CrWeaponActor_GetWeaponSocketTransform Parms{};

	Parms.SocketName = SocketName;
	Parms.TransformSpace = TransformSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.LocalPiercingTraceForSimulatedProxies
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FHitResult>&        OriginalHits                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FAuCustomTargetHandle&     InHandle                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWeaponActor::LocalPiercingTraceForSimulatedProxies(const TArray<struct FHitResult>& OriginalHits, const struct FAuCustomTargetHandle& InHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "LocalPiercingTraceForSimulatedProxies");

	Params::CrWeaponActor_LocalPiercingTraceForSimulatedProxies Parms{};

	Parms.OriginalHits = std::move(OriginalHits);
	Parms.InHandle = std::move(InHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponActor.OnBPCameraChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bIsFirstPersonView                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWeaponActor::OnBPCameraChanged(bool bIsFirstPersonView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnBPCameraChanged");

	Params::CrWeaponActor_OnBPCameraChanged Parms{};

	Parms.bIsFirstPersonView = bIsFirstPersonView;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrWeaponActor.OnBPPassiveAbilitiesLocallyGranted
// (Event, Public, BlueprintEvent)

void ACrWeaponActor::OnBPPassiveAbilitiesLocallyGranted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnBPPassiveAbilitiesLocallyGranted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrWeaponActor.OnBPWeaponPostEquip
// (Event, Public, BlueprintEvent)

void ACrWeaponActor::OnBPWeaponPostEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnBPWeaponPostEquip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrWeaponActor.OnBPWeaponPreUnequip
// (Event, Public, BlueprintEvent)

void ACrWeaponActor::OnBPWeaponPreUnequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnBPWeaponPreUnequip");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Chimera.CrWeaponActor.OnBuildingToolApplyEffects
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsDeconstructing                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWeaponActor::OnBuildingToolApplyEffects(bool bIsDeconstructing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnBuildingToolApplyEffects");

	Params::CrWeaponActor_OnBuildingToolApplyEffects Parms{};

	Parms.bIsDeconstructing = bIsDeconstructing;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrWeaponActor.OnBuildingToolNiagaraStart
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bStartDeconstructEffect                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWeaponActor::OnBuildingToolNiagaraStart(bool bStartDeconstructEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnBuildingToolNiagaraStart");

	Params::CrWeaponActor_OnBuildingToolNiagaraStart Parms{};

	Parms.bStartDeconstructEffect = bStartDeconstructEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrWeaponActor.OnBuildingToolNiagaraStop
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bStopDeconstructEffect                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWeaponActor::OnBuildingToolNiagaraStop(bool bStopDeconstructEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnBuildingToolNiagaraStop");

	Params::CrWeaponActor_OnBuildingToolNiagaraStop Parms{};

	Parms.bStopDeconstructEffect = bStopDeconstructEffect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrWeaponActor.OnCameraChanged
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsFirstPersonView                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACrWeaponActor::OnCameraChanged(bool bIsFirstPersonView)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnCameraChanged");

	Params::CrWeaponActor_OnCameraChanged Parms{};

	Parms.bIsFirstPersonView = bIsFirstPersonView;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponActor.OnPiercingCommitedCosmeticEffects
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const TArray<struct FHitResult>&        Hits                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrWeaponActor::OnPiercingCommitedCosmeticEffects(const TArray<struct FHitResult>& Hits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnPiercingCommitedCosmeticEffects");

	Params::CrWeaponActor_OnPiercingCommitedCosmeticEffects Parms{};

	Parms.Hits = std::move(Hits);

	UObject::ProcessEvent(Func, &Parms);
}


// Function Chimera.CrWeaponActor.OnWeaponInstanceDataReplicated
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void ACrWeaponActor::OnWeaponInstanceDataReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "OnWeaponInstanceDataReplicated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponActor.SetModsData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<TSoftObjectPtr<class UCrWeaponModDataAsset>>&CurrentlyAppliedMods                                   (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrWeaponActor::SetModsData(const TArray<TSoftObjectPtr<class UCrWeaponModDataAsset>>& CurrentlyAppliedMods)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "SetModsData");

	Params::CrWeaponActor_SetModsData Parms{};

	Parms.CurrentlyAppliedMods = std::move(CurrentlyAppliedMods);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.SpawnFireHitImpactCosmetics
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                InHitResults                                           (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ACrWeaponActor::SpawnFireHitImpactCosmetics(const struct FHitResult& InHitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "SpawnFireHitImpactCosmetics");

	Params::CrWeaponActor_SpawnFireHitImpactCosmetics Parms{};

	Parms.InHitResults = std::move(InHitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponActor.UpdateShadowCastingOnMeshes
// (Final, Native, Public, BlueprintCallable)

void ACrWeaponActor::UpdateShadowCastingOnMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "UpdateShadowCastingOnMeshes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrWeaponActor.UpdateWeaponVisualsForMods
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrWeaponActor::UpdateWeaponVisualsForMods()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "UpdateWeaponVisualsForMods");

	Params::CrWeaponActor_UpdateWeaponVisualsForMods Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.GetCurrentSignificance
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ACrWeaponActor::GetCurrentSignificance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "GetCurrentSignificance");

	Params::CrWeaponActor_GetCurrentSignificance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.IsOverCosmeticsReplicationDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrWeaponActor::IsOverCosmeticsReplicationDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "IsOverCosmeticsReplicationDistance");

	Params::CrWeaponActor_IsOverCosmeticsReplicationDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponActor.IsSingleFireTypeWeapon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACrWeaponActor::IsSingleFireTypeWeapon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponActor", "IsSingleFireTypeWeapon");

	Params::CrWeaponActor_IsSingleFireTypeWeapon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponItemDataBase.GetDefaultMods
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TMap<struct FGameplayTag, TSoftObjectPtr<class UCrWeaponModDataAsset>>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TMap<struct FGameplayTag, TSoftObjectPtr<class UCrWeaponModDataAsset>> UCrWeaponItemDataBase::GetDefaultMods() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponItemDataBase", "GetDefaultMods");

	Params::CrWeaponItemDataBase_GetDefaultMods Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponItemDataBase.GetWeaponType
// (Final, Native, Public, Const)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> UCrWeaponItemDataBase::GetWeaponType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrWeaponItemDataBase", "GetWeaponType");

	Params::CrWeaponItemDataBase_GetWeaponType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponModsFunctionLibrary.GetModMaterialsOverrideForTagWeaponPart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              WeaponPartGameplayTag                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FName, class UMaterialInterface*>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FName, class UMaterialInterface*> UCrWeaponModsFunctionLibrary::GetModMaterialsOverrideForTagWeaponPart(const struct FGameplayTag& WeaponPartGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrWeaponModsFunctionLibrary", "GetModMaterialsOverrideForTagWeaponPart");

	Params::CrWeaponModsFunctionLibrary_GetModMaterialsOverrideForTagWeaponPart Parms{};

	Parms.WeaponPartGameplayTag = std::move(WeaponPartGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponModsFunctionLibrary.GetWeaponModSceneComponentByName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACrWeaponModVisualData>ModVisualDataActorClass                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             Name_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UCrWeaponModsFunctionLibrary::GetWeaponModSceneComponentByName(TSubclassOf<class ACrWeaponModVisualData> ModVisualDataActorClass, class FName Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrWeaponModsFunctionLibrary", "GetWeaponModSceneComponentByName");

	Params::CrWeaponModsFunctionLibrary_GetWeaponModSceneComponentByName Parms{};

	Parms.ModVisualDataActorClass = ModVisualDataActorClass;
	Parms.Name_0 = Name_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponModsFunctionLibrary.GetWeaponModSceneComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACrWeaponModVisualData>ModVisualDataActorClass                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class USceneComponent*>    ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class USceneComponent*> UCrWeaponModsFunctionLibrary::GetWeaponModSceneComponents(TSubclassOf<class ACrWeaponModVisualData> ModVisualDataActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrWeaponModsFunctionLibrary", "GetWeaponModSceneComponents");

	Params::CrWeaponModsFunctionLibrary_GetWeaponModSceneComponents Parms{};

	Parms.ModVisualDataActorClass = ModVisualDataActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWeaponModsFunctionLibrary.GetWeaponModSkeletalSceneComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACrWeaponModVisualData>ModVisualDataActorClass                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class UCrWeaponSkeletalMeshComponent*>ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

const TArray<class UCrWeaponSkeletalMeshComponent*> UCrWeaponModsFunctionLibrary::GetWeaponModSkeletalSceneComponents(TSubclassOf<class ACrWeaponModVisualData> ModVisualDataActorClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrWeaponModsFunctionLibrary", "GetWeaponModSkeletalSceneComponents");

	Params::CrWeaponModsFunctionLibrary_GetWeaponModSkeletalSceneComponents Parms{};

	Parms.ModVisualDataActorClass = ModVisualDataActorClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrWorldInteractablesLibrary.GetCookedEnvelopeDataForSoundWave
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USoundWave*                       SoundWave                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnCount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UCrWorldInteractablesLibrary::GetCookedEnvelopeDataForSoundWave(class USoundWave* SoundWave, int32 ReturnCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrWorldInteractablesLibrary", "GetCookedEnvelopeDataForSoundWave");

	Params::CrWorldInteractablesLibrary_GetCookedEnvelopeDataForSoundWave Parms{};

	Parms.SoundWave = SoundWave;
	Parms.ReturnCount = ReturnCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.IdentificationLibrary.GetActorUniqueName
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            OutName                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIdentificationLibrary::GetActorUniqueName(class AActor* TargetActor, class FName* OutName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IdentificationLibrary", "GetActorUniqueName");

	Params::IdentificationLibrary_GetActorUniqueName Parms{};

	Parms.TargetActor = TargetActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutName != nullptr)
		*OutName = Parms.OutName;

	return Parms.ReturnValue;
}


// Function Chimera.IdentificationLibrary.GetAllCategoriesNames
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UIdentificationLibrary::GetAllCategoriesNames()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IdentificationLibrary", "GetAllCategoriesNames");

	Params::IdentificationLibrary_GetAllCategoriesNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPawnExtensionComponent.FindPawnExtensionComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrPawnExtensionComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrPawnExtensionComponent* UCrPawnExtensionComponent::FindPawnExtensionComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrPawnExtensionComponent", "FindPawnExtensionComponent");

	Params::CrPawnExtensionComponent_FindPawnExtensionComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrPawnExtensionComponent.OnRep_PawnData
// (Final, Native, Protected)

void UCrPawnExtensionComponent::OnRep_PawnData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPawnExtensionComponent", "OnRep_PawnData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrPawnExtensionComponent.GetCrAbilitySystemComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UCrAbilitySystemComponent*        ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAbilitySystemComponent* UCrPawnExtensionComponent::GetCrAbilitySystemComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrPawnExtensionComponent", "GetCrAbilitySystemComponent");

	Params::CrPawnExtensionComponent_GetCrAbilitySystemComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrHeroComponent.FindHeroComponent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrHeroComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrHeroComponent* UCrHeroComponent::FindHeroComponent(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrHeroComponent", "FindHeroComponent");

	Params::CrHeroComponent_FindHeroComponent Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrHeroComponent.BindContextualMapping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ConfigTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrHeroComponent::BindContextualMapping(const struct FGameplayTag& ConfigTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHeroComponent", "BindContextualMapping");

	Params::CrHeroComponent_BindContextualMapping Parms{};

	Parms.ConfigTag = std::move(ConfigTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHeroComponent.BindExclusiveMapping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ConfigTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrHeroComponent::BindExclusiveMapping(const struct FGameplayTag& ConfigTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHeroComponent", "BindExclusiveMapping");

	Params::CrHeroComponent_BindExclusiveMapping Parms{};

	Parms.ConfigTag = std::move(ConfigTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHeroComponent.OnControllerChanged
// (Final, Native, Protected)
// Parameters:
// class APawn*                            InPawn                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      InController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrHeroComponent::OnControllerChanged(class APawn* InPawn, class AController* InController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHeroComponent", "OnControllerChanged");

	Params::CrHeroComponent_OnControllerChanged Parms{};

	Parms.InPawn = InPawn;
	Parms.InController = InController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHeroComponent.UnbindContextualMapping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ConfigTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrHeroComponent::UnbindContextualMapping(const struct FGameplayTag& ConfigTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHeroComponent", "UnbindContextualMapping");

	Params::CrHeroComponent_UnbindContextualMapping Parms{};

	Parms.ConfigTag = std::move(ConfigTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrHeroComponent.UnbindExclusiveMapping
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              ConfigTag                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrHeroComponent::UnbindExclusiveMapping(const struct FGameplayTag& ConfigTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrHeroComponent", "UnbindExclusiveMapping");

	Params::CrHeroComponent_UnbindExclusiveMapping Parms{};

	Parms.ConfigTag = std::move(ConfigTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetADSToggle
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetADSToggle(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetADSToggle");

	Params::CrSettingsShared_SetADSToggle Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetAimAssistStrength
// (Final, Native, Public)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetAimAssistStrength(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetAimAssistStrength");

	Params::CrSettingsShared_SetAimAssistStrength Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetAimAssistType
// (Final, Native, Public)
// Parameters:
// ECrAimAssistType                        NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetAimAssistType(ECrAimAssistType NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetAimAssistType");

	Params::CrSettingsShared_SetAimAssistType Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetAllowAudioInBackgroundSetting
// (Final, Native, Public)
// Parameters:
// ECrAllowBackgroundAudioSetting          NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetAllowAudioInBackgroundSetting(ECrAllowBackgroundAudioSetting NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetAllowAudioInBackgroundSetting");

	Params::CrSettingsShared_SetAllowAudioInBackgroundSetting Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetBuildingDroneActivateMode
// (Final, Native, Public)
// Parameters:
// EBuildingDroneActivateMode              NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetBuildingDroneActivateMode(EBuildingDroneActivateMode NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetBuildingDroneActivateMode");

	Params::CrSettingsShared_SetBuildingDroneActivateMode Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetColorBlindMode
// (Final, Native, Public)
// Parameters:
// EColorBlindMode                         InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetColorBlindMode(EColorBlindMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetColorBlindMode");

	Params::CrSettingsShared_SetColorBlindMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetColorBlindStrength
// (Final, Native, Public)
// Parameters:
// int32                                   InColorBlindStrength                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetColorBlindStrength(int32 InColorBlindStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetColorBlindStrength");

	Params::CrSettingsShared_SetColorBlindStrength Parms{};

	Parms.InColorBlindStrength = InColorBlindStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetConsoleGraphicsMode
// (Final, Native, Public)
// Parameters:
// EConsoleGraphicsMode                    InConsoleMode                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetConsoleGraphicsMode(EConsoleGraphicsMode InConsoleMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetConsoleGraphicsMode");

	Params::CrSettingsShared_SetConsoleGraphicsMode Parms{};

	Parms.InConsoleMode = InConsoleMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetCoopInfoCollision
// (Final, Native, Public)
// Parameters:
// ECoopInfoCollision                      NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetCoopInfoCollision(ECoopInfoCollision NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetCoopInfoCollision");

	Params::CrSettingsShared_SetCoopInfoCollision Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetCrouchToggle
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetCrouchToggle(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetCrouchToggle");

	Params::CrSettingsShared_SetCrouchToggle Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetForceFeedbackEnabled
// (Final, Native, Public)
// Parameters:
// const bool                              NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetForceFeedbackEnabled(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetForceFeedbackEnabled");

	Params::CrSettingsShared_SetForceFeedbackEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetGamepadLookStickDeadZone
// (Final, Native, Public)
// Parameters:
// const float                             NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetGamepadLookStickDeadZone(const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetGamepadLookStickDeadZone");

	Params::CrSettingsShared_SetGamepadLookStickDeadZone Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetGamepadMoveStickDeadZone
// (Final, Native, Public)
// Parameters:
// const float                             NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetGamepadMoveStickDeadZone(const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetGamepadMoveStickDeadZone");

	Params::CrSettingsShared_SetGamepadMoveStickDeadZone Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetGamepadTargetingSensitivityPreset
// (Final, Native, Public)
// Parameters:
// ECrGamepadSensitivity                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetGamepadTargetingSensitivityPreset(ECrGamepadSensitivity NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetGamepadTargetingSensitivityPreset");

	Params::CrSettingsShared_SetGamepadTargetingSensitivityPreset Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetHasCompletedTutorial
// (Final, Native, Public)
// Parameters:
// bool                                    NewHasCompletedTutorial                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetHasCompletedTutorial(bool NewHasCompletedTutorial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetHasCompletedTutorial");

	Params::CrSettingsShared_SetHasCompletedTutorial Parms{};

	Parms.NewHasCompletedTutorial = NewHasCompletedTutorial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetInvertHorizontalAxis
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetInvertHorizontalAxis(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetInvertHorizontalAxis");

	Params::CrSettingsShared_SetInvertHorizontalAxis Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetInvertVerticalAxis
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetInvertVerticalAxis(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetInvertVerticalAxis");

	Params::CrSettingsShared_SetInvertVerticalAxis Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetLookAcceleration
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetLookAcceleration(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetLookAcceleration");

	Params::CrSettingsShared_SetLookAcceleration Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetLookSensitivityPreset
// (Final, Native, Public)
// Parameters:
// ECrGamepadSensitivity                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetLookSensitivityPreset(ECrGamepadSensitivity NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetLookSensitivityPreset");

	Params::CrSettingsShared_SetLookSensitivityPreset Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetMouseSensitivityX
// (Final, Native, Public)
// Parameters:
// double                                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetMouseSensitivityX(double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetMouseSensitivityX");

	Params::CrSettingsShared_SetMouseSensitivityX Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetMouseSensitivityY
// (Final, Native, Public)
// Parameters:
// double                                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetMouseSensitivityY(double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetMouseSensitivityY");

	Params::CrSettingsShared_SetMouseSensitivityY Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetSkipTutorialChecked
// (Final, Native, Public)
// Parameters:
// bool                                    InSkipTutorialChecked                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetSkipTutorialChecked(bool InSkipTutorialChecked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetSkipTutorialChecked");

	Params::CrSettingsShared_SetSkipTutorialChecked Parms{};

	Parms.InSkipTutorialChecked = InSkipTutorialChecked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetSprintInputToggleMode
// (Final, Native, Public)
// Parameters:
// ESprintInputToggleMode                  InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetSprintInputToggleMode(ESprintInputToggleMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetSprintInputToggleMode");

	Params::CrSettingsShared_SetSprintInputToggleMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetSubtitlesBackgroundOpacity
// (Final, Native, Public)
// Parameters:
// ESubtitleDisplayBackgroundOpacity       Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetSubtitlesBackgroundOpacity(ESubtitleDisplayBackgroundOpacity Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetSubtitlesBackgroundOpacity");

	Params::CrSettingsShared_SetSubtitlesBackgroundOpacity Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetSubtitlesEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetSubtitlesEnabled(bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetSubtitlesEnabled");

	Params::CrSettingsShared_SetSubtitlesEnabled Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetSubtitlesTextBorder
// (Final, Native, Public)
// Parameters:
// ESubtitleDisplayTextBorder              Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetSubtitlesTextBorder(ESubtitleDisplayTextBorder Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetSubtitlesTextBorder");

	Params::CrSettingsShared_SetSubtitlesTextBorder Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetSubtitlesTextColor
// (Final, Native, Public)
// Parameters:
// ESubtitleDisplayTextColor               Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetSubtitlesTextColor(ESubtitleDisplayTextColor Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetSubtitlesTextColor");

	Params::CrSettingsShared_SetSubtitlesTextColor Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetSubtitlesTextSize
// (Final, Native, Public)
// Parameters:
// ESubtitleDisplayTextSize                Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetSubtitlesTextSize(ESubtitleDisplayTextSize Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetSubtitlesTextSize");

	Params::CrSettingsShared_SetSubtitlesTextSize Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetTargetingMultiplier
// (Final, Native, Public)
// Parameters:
// double                                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetTargetingMultiplier(double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetTargetingMultiplier");

	Params::CrSettingsShared_SetTargetingMultiplier Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetTriggerHapticsEnabled
// (Final, Native, Public)
// Parameters:
// const bool                              NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetTriggerHapticsEnabled(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetTriggerHapticsEnabled");

	Params::CrSettingsShared_SetTriggerHapticsEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetTriggerHapticStartPosition
// (Final, Native, Public)
// Parameters:
// const uint8                             NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetTriggerHapticStartPosition(const uint8 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetTriggerHapticStartPosition");

	Params::CrSettingsShared_SetTriggerHapticStartPosition Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetTriggerHapticStrength
// (Final, Native, Public)
// Parameters:
// const uint8                             NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetTriggerHapticStrength(const uint8 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetTriggerHapticStrength");

	Params::CrSettingsShared_SetTriggerHapticStrength Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.SetTriggerPullUsesHapticThreshold
// (Final, Native, Public)
// Parameters:
// const bool                              NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSettingsShared::SetTriggerPullUsesHapticThreshold(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "SetTriggerPullUsesHapticThreshold");

	Params::CrSettingsShared_SetTriggerPullUsesHapticThreshold Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSettingsShared.GetADSToggle
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetADSToggle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetADSToggle");

	Params::CrSettingsShared_GetADSToggle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetAimAssistStrength
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrSettingsShared::GetAimAssistStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetAimAssistStrength");

	Params::CrSettingsShared_GetAimAssistStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetAimAssistType
// (Final, Native, Public, Const)
// Parameters:
// ECrAimAssistType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrAimAssistType UCrSettingsShared::GetAimAssistType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetAimAssistType");

	Params::CrSettingsShared_GetAimAssistType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetAllowAudioInBackgroundSetting
// (Final, Native, Public, Const)
// Parameters:
// ECrAllowBackgroundAudioSetting          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrAllowBackgroundAudioSetting UCrSettingsShared::GetAllowAudioInBackgroundSetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetAllowAudioInBackgroundSetting");

	Params::CrSettingsShared_GetAllowAudioInBackgroundSetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetBuildingDroneActivateMode
// (Final, Native, Public, Const)
// Parameters:
// EBuildingDroneActivateMode              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EBuildingDroneActivateMode UCrSettingsShared::GetBuildingDroneActivateMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetBuildingDroneActivateMode");

	Params::CrSettingsShared_GetBuildingDroneActivateMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetColorBlindMode
// (Final, Native, Public, Const)
// Parameters:
// EColorBlindMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EColorBlindMode UCrSettingsShared::GetColorBlindMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetColorBlindMode");

	Params::CrSettingsShared_GetColorBlindMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetColorBlindStrength
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCrSettingsShared::GetColorBlindStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetColorBlindStrength");

	Params::CrSettingsShared_GetColorBlindStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetCoopInfoCollision
// (Final, Native, Public, Const)
// Parameters:
// ECoopInfoCollision                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECoopInfoCollision UCrSettingsShared::GetCoopInfoCollision() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetCoopInfoCollision");

	Params::CrSettingsShared_GetCoopInfoCollision Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetCrouchToggle
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetCrouchToggle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetCrouchToggle");

	Params::CrSettingsShared_GetCrouchToggle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetCurrentConsoleGraphicsMode
// (Final, Native, Public, Const)
// Parameters:
// EConsoleGraphicsMode                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EConsoleGraphicsMode UCrSettingsShared::GetCurrentConsoleGraphicsMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetCurrentConsoleGraphicsMode");

	Params::CrSettingsShared_GetCurrentConsoleGraphicsMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetForceFeedbackEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetForceFeedbackEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetForceFeedbackEnabled");

	Params::CrSettingsShared_GetForceFeedbackEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetGamepadLookSensitivityPreset
// (Final, Native, Public, Const)
// Parameters:
// ECrGamepadSensitivity                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrGamepadSensitivity UCrSettingsShared::GetGamepadLookSensitivityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetGamepadLookSensitivityPreset");

	Params::CrSettingsShared_GetGamepadLookSensitivityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetGamepadLookStickDeadZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrSettingsShared::GetGamepadLookStickDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetGamepadLookStickDeadZone");

	Params::CrSettingsShared_GetGamepadLookStickDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetGamepadMoveStickDeadZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCrSettingsShared::GetGamepadMoveStickDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetGamepadMoveStickDeadZone");

	Params::CrSettingsShared_GetGamepadMoveStickDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetGamepadTargetingSensitivityPreset
// (Final, Native, Public, Const)
// Parameters:
// ECrGamepadSensitivity                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrGamepadSensitivity UCrSettingsShared::GetGamepadTargetingSensitivityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetGamepadTargetingSensitivityPreset");

	Params::CrSettingsShared_GetGamepadTargetingSensitivityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetHasCompletedTutorial
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetHasCompletedTutorial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetHasCompletedTutorial");

	Params::CrSettingsShared_GetHasCompletedTutorial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetInvertHorizontalAxis
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetInvertHorizontalAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetInvertHorizontalAxis");

	Params::CrSettingsShared_GetInvertHorizontalAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetInvertVerticalAxis
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetInvertVerticalAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetInvertVerticalAxis");

	Params::CrSettingsShared_GetInvertVerticalAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetLookAcceleration
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetLookAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetLookAcceleration");

	Params::CrSettingsShared_GetLookAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetMouseSensitivityX
// (Final, Native, Public, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UCrSettingsShared::GetMouseSensitivityX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetMouseSensitivityX");

	Params::CrSettingsShared_GetMouseSensitivityX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetMouseSensitivityY
// (Final, Native, Public, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UCrSettingsShared::GetMouseSensitivityY() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetMouseSensitivityY");

	Params::CrSettingsShared_GetMouseSensitivityY Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetSkipTutorialChecked
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetSkipTutorialChecked() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetSkipTutorialChecked");

	Params::CrSettingsShared_GetSkipTutorialChecked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetSprintInputToggleMode
// (Final, Native, Public, Const)
// Parameters:
// ESprintInputToggleMode                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESprintInputToggleMode UCrSettingsShared::GetSprintInputToggleMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetSprintInputToggleMode");

	Params::CrSettingsShared_GetSprintInputToggleMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetSubtitlesBackgroundOpacity
// (Final, Native, Public, Const)
// Parameters:
// ESubtitleDisplayBackgroundOpacity       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESubtitleDisplayBackgroundOpacity UCrSettingsShared::GetSubtitlesBackgroundOpacity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetSubtitlesBackgroundOpacity");

	Params::CrSettingsShared_GetSubtitlesBackgroundOpacity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetSubtitlesEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetSubtitlesEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetSubtitlesEnabled");

	Params::CrSettingsShared_GetSubtitlesEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetSubtitlesTextBorder
// (Final, Native, Public, Const)
// Parameters:
// ESubtitleDisplayTextBorder              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESubtitleDisplayTextBorder UCrSettingsShared::GetSubtitlesTextBorder() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetSubtitlesTextBorder");

	Params::CrSettingsShared_GetSubtitlesTextBorder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetSubtitlesTextColor
// (Final, Native, Public, Const)
// Parameters:
// ESubtitleDisplayTextColor               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESubtitleDisplayTextColor UCrSettingsShared::GetSubtitlesTextColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetSubtitlesTextColor");

	Params::CrSettingsShared_GetSubtitlesTextColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetSubtitlesTextSize
// (Final, Native, Public, Const)
// Parameters:
// ESubtitleDisplayTextSize                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESubtitleDisplayTextSize UCrSettingsShared::GetSubtitlesTextSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetSubtitlesTextSize");

	Params::CrSettingsShared_GetSubtitlesTextSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetTargetingMultiplier
// (Final, Native, Public, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UCrSettingsShared::GetTargetingMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetTargetingMultiplier");

	Params::CrSettingsShared_GetTargetingMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetTriggerHapticsEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetTriggerHapticsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetTriggerHapticsEnabled");

	Params::CrSettingsShared_GetTriggerHapticsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetTriggerHapticStartPosition
// (Final, Native, Public, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UCrSettingsShared::GetTriggerHapticStartPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetTriggerHapticStartPosition");

	Params::CrSettingsShared_GetTriggerHapticStartPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetTriggerHapticStrength
// (Final, Native, Public, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UCrSettingsShared::GetTriggerHapticStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetTriggerHapticStrength");

	Params::CrSettingsShared_GetTriggerHapticStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSettingsShared.GetTriggerPullUsesHapticThreshold
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCrSettingsShared::GetTriggerPullUsesHapticThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrSettingsShared", "GetTriggerPullUsesHapticThreshold");

	Params::CrSettingsShared_GetTriggerPullUsesHapticThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSystemStatics.FindComponentsByClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCrSystemStatics::FindComponentsByClass(class AActor* TargetActor, TSubclassOf<class UActorComponent> ComponentClass, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "FindComponentsByClass");

	Params::CrSystemStatics_FindComponentsByClass Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ComponentClass = ComponentClass;
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSystemStatics.GetBlueprintComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBlueprint*                       Blueprint                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              ExcludeInherited                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCrSystemStatics::GetBlueprintComponents(class UBlueprint* Blueprint, const bool ExcludeInherited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "GetBlueprintComponents");

	Params::CrSystemStatics_GetBlueprintComponents Parms{};

	Parms.Blueprint = Blueprint;
	Parms.ExcludeInherited = ExcludeInherited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSystemStatics.GetBlueprintComponentsOfClass
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UBlueprint*                       Blueprint                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UActorComponent>      ComponentClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ExcludeInherited                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UActorComponent*>          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UActorComponent*> UCrSystemStatics::GetBlueprintComponentsOfClass(class UBlueprint* Blueprint, TSubclassOf<class UActorComponent> ComponentClass, bool ExcludeInherited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "GetBlueprintComponentsOfClass");

	Params::CrSystemStatics_GetBlueprintComponentsOfClass Parms{};

	Parms.Blueprint = Blueprint;
	Parms.ComponentClass = ComponentClass;
	Parms.ExcludeInherited = ExcludeInherited;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSystemStatics.GetPrimaryAssetIdFromUserFacingExperienceName
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class FString&                    AdvertisedExperienceID                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPrimaryAssetId                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FPrimaryAssetId UCrSystemStatics::GetPrimaryAssetIdFromUserFacingExperienceName(const class FString& AdvertisedExperienceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "GetPrimaryAssetIdFromUserFacingExperienceName");

	Params::CrSystemStatics_GetPrimaryAssetIdFromUserFacingExperienceName Parms{};

	Parms.AdvertisedExperienceID = std::move(AdvertisedExperienceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSystemStatics.GetTypedSoftObjectReferenceFromPrimaryAssetId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FPrimaryAssetId&           PrimaryAssetId                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              ExpectedAssetType                                      (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UObject>           ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UObject> UCrSystemStatics::GetTypedSoftObjectReferenceFromPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId, TSubclassOf<class UObject> ExpectedAssetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "GetTypedSoftObjectReferenceFromPrimaryAssetId");

	Params::CrSystemStatics_GetTypedSoftObjectReferenceFromPrimaryAssetId Parms{};

	Parms.PrimaryAssetId = std::move(PrimaryAssetId);
	Parms.ExpectedAssetType = ExpectedAssetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Chimera.CrSystemStatics.PlayNextGame
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSystemStatics::PlayNextGame(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "PlayNextGame");

	Params::CrSystemStatics_PlayNextGame Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSystemStatics.ReplaceStaticMeshSockets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      Dest                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSystemStatics::ReplaceStaticMeshSockets(class UStaticMesh* Source, class UStaticMesh* Dest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "ReplaceStaticMeshSockets");

	Params::CrSystemStatics_ReplaceStaticMeshSockets Parms{};

	Parms.Source = Source;
	Parms.Dest = Dest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSystemStatics.SetColorParameterValueOnAllMeshComponents
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLinearColor&              ParameterValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSystemStatics::SetColorParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const struct FLinearColor& ParameterValue, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "SetColorParameterValueOnAllMeshComponents");

	Params::CrSystemStatics_SetColorParameterValueOnAllMeshComponents Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = std::move(ParameterValue);
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSystemStatics.SetScalarParameterValueOnAllMeshComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             ParameterValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSystemStatics::SetScalarParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const float ParameterValue, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "SetScalarParameterValueOnAllMeshComponents");

	Params::CrSystemStatics_SetScalarParameterValueOnAllMeshComponents Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = ParameterValue;
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Chimera.CrSystemStatics.SetVectorParameterValueOnAllMeshComponents
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       ParameterName                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ParameterValue                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIncludeChildActors                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrSystemStatics::SetVectorParameterValueOnAllMeshComponents(class AActor* TargetActor, const class FName ParameterName, const struct FVector& ParameterValue, bool bIncludeChildActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrSystemStatics", "SetVectorParameterValueOnAllMeshComponents");

	Params::CrSystemStatics_SetVectorParameterValueOnAllMeshComponents Parms{};

	Parms.TargetActor = TargetActor;
	Parms.ParameterName = ParameterName;
	Parms.ParameterValue = std::move(ParameterValue);
	Parms.bIncludeChildActors = bIncludeChildActors;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

