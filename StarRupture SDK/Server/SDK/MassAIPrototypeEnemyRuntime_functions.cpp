#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: MassAIPrototypeEnemyRuntime

#include "Basic.hpp"

#include "MassAIPrototypeEnemyRuntime_classes.hpp"
#include "MassAIPrototypeEnemyRuntime_parameters.hpp"


namespace SDK
{

// Function MassAIPrototypeEnemyRuntime.AbstractMassEnemySpawner.ActivateSpawner
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    bDisableAggroLock                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAbstractMassEnemySpawner::ActivateSpawner(bool bDisableAggroLock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbstractMassEnemySpawner", "ActivateSpawner");

	Params::AbstractMassEnemySpawner_ActivateSpawner Parms{};

	Parms.bDisableAggroLock = bDisableAggroLock;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AbstractMassEnemySpawner.ActivateTrigger
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Active                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAbstractMassEnemySpawner::ActivateTrigger(bool Active)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbstractMassEnemySpawner", "ActivateTrigger");

	Params::AbstractMassEnemySpawner_ActivateTrigger Parms{};

	Parms.Active = Active;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AbstractMassEnemySpawner.DeactivateSpawner
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    bPermanently                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAbstractMassEnemySpawner::DeactivateSpawner(bool bPermanently)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbstractMassEnemySpawner", "DeactivateSpawner");

	Params::AbstractMassEnemySpawner_DeactivateSpawner Parms{};

	Parms.bPermanently = bPermanently;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AbstractMassEnemySpawner.SetState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EMassEnemySpawnerState                  NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AAbstractMassEnemySpawner::SetState(EMassEnemySpawnerState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbstractMassEnemySpawner", "SetState");

	Params::AbstractMassEnemySpawner_SetState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AbstractMassEnemySpawner.IsDebugEnabled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAbstractMassEnemySpawner::IsDebugEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbstractMassEnemySpawner", "IsDebugEnabled");

	Params::AbstractMassEnemySpawner_IsDebugEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AbstractMassEnemySpawner.IsTriggerActive
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AAbstractMassEnemySpawner::IsTriggerActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbstractMassEnemySpawner", "IsTriggerActive");

	Params::AbstractMassEnemySpawner_IsTriggerActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.AddLooseGameplayTagToEnemyCharacter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAiFunctionLibrary::AddLooseGameplayTagToEnemyCharacter(class AMassEnemyCharacterBase* Character, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "AddLooseGameplayTagToEnemyCharacter");

	Params::AiFunctionLibrary_AddLooseGameplayTagToEnemyCharacter Parms{};

	Parms.Character = Character;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.AoEAttack
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     Attacker                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoredActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   AttackLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      PlayerDamageEffect                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      AiDamageEffect                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BuildingDamageAmount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPushDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PushDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EnemyActorPushVelocity                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EnemyEntityPushVelocity                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetPushZAxis                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::AoEAttack(const class AActor* Attacker, const TArray<class AActor*>& IgnoredActors, const struct FVector& AttackLocation, float AttackRadius, TSubclassOf<class UGameplayEffect> PlayerDamageEffect, TSubclassOf<class UGameplayEffect> AiDamageEffect, float BuildingDamageAmount, float MaxPushDistance, float PushDuration, float EnemyActorPushVelocity, float EnemyEntityPushVelocity, bool bResetPushZAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "AoEAttack");

	Params::AiFunctionLibrary_AoEAttack Parms{};

	Parms.Attacker = Attacker;
	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.AttackLocation = std::move(AttackLocation);
	Parms.AttackRadius = AttackRadius;
	Parms.PlayerDamageEffect = PlayerDamageEffect;
	Parms.AiDamageEffect = AiDamageEffect;
	Parms.BuildingDamageAmount = BuildingDamageAmount;
	Parms.MaxPushDistance = MaxPushDistance;
	Parms.PushDuration = PushDuration;
	Parms.EnemyActorPushVelocity = EnemyActorPushVelocity;
	Parms.EnemyEntityPushVelocity = EnemyEntityPushVelocity;
	Parms.bResetPushZAxis = bResetPushZAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.BPFindClosestPointOnNavmesh
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   OriginalLocation                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocationIfSuccess                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Extents                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AgentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::BPFindClosestPointOnNavmesh(class UObject* WorldContextObject, const struct FVector& OriginalLocation, struct FVector* OutLocationIfSuccess, const struct FVector& Extents, class FName AgentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "BPFindClosestPointOnNavmesh");

	Params::AiFunctionLibrary_BPFindClosestPointOnNavmesh Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OriginalLocation = std::move(OriginalLocation);
	Parms.Extents = std::move(Extents);
	Parms.AgentName = AgentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationIfSuccess != nullptr)
		*OutLocationIfSuccess = std::move(Parms.OutLocationIfSuccess);

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.BPGetManagedRandomPointOnNavmesh
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          MassEnemyCharacter                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   CenterLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocationIfSuccess                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AgentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnsureReachable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>NavFilter                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::BPGetManagedRandomPointOnNavmesh(class AMassEnemyCharacterBase* MassEnemyCharacter, const struct FVector& CenterLocation, struct FVector* OutLocationIfSuccess, float Radius, class FName AgentName, bool bEnsureReachable, class AAIController* AIController, TSubclassOf<class UNavigationQueryFilter> NavFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "BPGetManagedRandomPointOnNavmesh");

	Params::AiFunctionLibrary_BPGetManagedRandomPointOnNavmesh Parms{};

	Parms.MassEnemyCharacter = MassEnemyCharacter;
	Parms.CenterLocation = std::move(CenterLocation);
	Parms.Radius = Radius;
	Parms.AgentName = AgentName;
	Parms.bEnsureReachable = bEnsureReachable;
	Parms.AIController = AIController;
	Parms.NavFilter = NavFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationIfSuccess != nullptr)
		*OutLocationIfSuccess = std::move(Parms.OutLocationIfSuccess);

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.BPGetManagedTargetLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AMassEnemyCharacterBase*    MassEnemyCharacterBase                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutTargetLocation                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AgentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::BPGetManagedTargetLocation(const class AMassEnemyCharacterBase* MassEnemyCharacterBase, const class AActor* TargetActor, struct FVector* OutTargetLocation, class FName AgentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "BPGetManagedTargetLocation");

	Params::AiFunctionLibrary_BPGetManagedTargetLocation Parms{};

	Parms.MassEnemyCharacterBase = MassEnemyCharacterBase;
	Parms.TargetActor = TargetActor;
	Parms.AgentName = AgentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTargetLocation != nullptr)
		*OutTargetLocation = std::move(Parms.OutTargetLocation);

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.BPGetRandomPointOnNavmesh
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   CenterLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocationIfSuccess                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Radius                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AgentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnsureReachable                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AAIController*                    AIController                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UNavigationQueryFilter>NavFilter                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::BPGetRandomPointOnNavmesh(class UObject* WorldContextObject, const struct FVector& CenterLocation, struct FVector* OutLocationIfSuccess, float Radius, class FName AgentName, bool bEnsureReachable, class AAIController* AIController, TSubclassOf<class UNavigationQueryFilter> NavFilter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "BPGetRandomPointOnNavmesh");

	Params::AiFunctionLibrary_BPGetRandomPointOnNavmesh Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CenterLocation = std::move(CenterLocation);
	Parms.Radius = Radius;
	Parms.AgentName = AgentName;
	Parms.bEnsureReachable = bEnsureReachable;
	Parms.AIController = AIController;
	Parms.NavFilter = NavFilter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationIfSuccess != nullptr)
		*OutLocationIfSuccess = std::move(Parms.OutLocationIfSuccess);

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.CalculateJumpParabolaParameters
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector2D&                 Start                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 Middle                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector2D&                 End                                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAiFunctionLibrary::CalculateJumpParabolaParameters(const struct FVector2D& Start, const struct FVector2D& Middle, const struct FVector2D& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "CalculateJumpParabolaParameters");

	Params::AiFunctionLibrary_CalculateJumpParabolaParameters Parms{};

	Parms.Start = std::move(Start);
	Parms.Middle = std::move(Middle);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.CanActorRunAway
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::CanActorRunAway(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "CanActorRunAway");

	Params::AiFunctionLibrary_CanActorRunAway Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.CanEnemyPlaySpawnAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          EnemyCharacterBase                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::CanEnemyPlaySpawnAnim(class AMassEnemyCharacterBase* EnemyCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "CanEnemyPlaySpawnAnim");

	Params::AiFunctionLibrary_CanEnemyPlaySpawnAnim Parms{};

	Parms.EnemyCharacterBase = EnemyCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.CanPerformMovementAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          Enemy                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::CanPerformMovementAttack(class AMassEnemyCharacterBase* Enemy, const class AActor* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "CanPerformMovementAttack");

	Params::AiFunctionLibrary_CanPerformMovementAttack Parms{};

	Parms.Enemy = Enemy;
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.DealDamageToActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     CallingCActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           TargetActor                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      PlayerDamageEffect                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      AiDamageEffect                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BuildingInfectionDamage                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::DealDamageToActor(const class AActor* CallingCActor, class AActor* TargetActor, TSubclassOf<class UGameplayEffect> PlayerDamageEffect, TSubclassOf<class UGameplayEffect> AiDamageEffect, float BuildingInfectionDamage, float MaxDistance, float ConeHalfAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "DealDamageToActor");

	Params::AiFunctionLibrary_DealDamageToActor Parms{};

	Parms.CallingCActor = CallingCActor;
	Parms.TargetActor = TargetActor;
	Parms.PlayerDamageEffect = PlayerDamageEffect;
	Parms.AiDamageEffect = AiDamageEffect;
	Parms.BuildingInfectionDamage = BuildingInfectionDamage;
	Parms.MaxDistance = MaxDistance;
	Parms.ConeHalfAngle = ConeHalfAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.DealDamageToEntityAtProjectileHitLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     ProjectileActor                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                ProjectileHitTransform                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      PlayerDamageEffect                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      AiDamageEffect                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BuildingInfectionDamage                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EntitySearchExtents                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BuildingSearchExtents                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::DealDamageToEntityAtProjectileHitLocation(const class AActor* ProjectileActor, const struct FTransform& ProjectileHitTransform, TSubclassOf<class UGameplayEffect> PlayerDamageEffect, TSubclassOf<class UGameplayEffect> AiDamageEffect, float BuildingInfectionDamage, float EntitySearchExtents, float BuildingSearchExtents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "DealDamageToEntityAtProjectileHitLocation");

	Params::AiFunctionLibrary_DealDamageToEntityAtProjectileHitLocation Parms{};

	Parms.ProjectileActor = ProjectileActor;
	Parms.ProjectileHitTransform = std::move(ProjectileHitTransform);
	Parms.PlayerDamageEffect = PlayerDamageEffect;
	Parms.AiDamageEffect = AiDamageEffect;
	Parms.BuildingInfectionDamage = BuildingInfectionDamage;
	Parms.EntitySearchExtents = EntitySearchExtents;
	Parms.BuildingSearchExtents = BuildingSearchExtents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.DebugSetZeroHPForAllEnemies
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAiFunctionLibrary::DebugSetZeroHPForAllEnemies(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "DebugSetZeroHPForAllEnemies");

	Params::AiFunctionLibrary_DebugSetZeroHPForAllEnemies Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.DebugSwitchBetweenDefaultAndBigNavmeshVisibility
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAiFunctionLibrary::DebugSwitchBetweenDefaultAndBigNavmeshVisibility(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "DebugSwitchBetweenDefaultAndBigNavmeshVisibility");

	Params::AiFunctionLibrary_DebugSwitchBetweenDefaultAndBigNavmeshVisibility Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.FindPointsForLongAoeAttack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float&                            Distance                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32&                            StepsNum                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float&                            StartAdditionalDistance                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> UAiFunctionLibrary::FindPointsForLongAoeAttack(class AActor* Instigator, const float& Distance, const int32& StepsNum, const float& StartAdditionalDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "FindPointsForLongAoeAttack");

	Params::AiFunctionLibrary_FindPointsForLongAoeAttack Parms{};

	Parms.Instigator = Instigator;
	Parms.Distance = Distance;
	Parms.StepsNum = StepsNum;
	Parms.StartAdditionalDistance = StartAdditionalDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.FindSpawnPosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      Bounds                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutSpawnPosition                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AgentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::FindSpawnPosition(const class UWorld* World, const struct FBox& Bounds, struct FVector* OutSpawnPosition, class FName AgentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "FindSpawnPosition");

	Params::AiFunctionLibrary_FindSpawnPosition Parms{};

	Parms.World = World;
	Parms.Bounds = std::move(Bounds);
	Parms.AgentName = AgentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSpawnPosition != nullptr)
		*OutSpawnPosition = std::move(Parms.OutSpawnPosition);

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetClosestPointOnBounds
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   BoundsCenter                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   BoundsExtents                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  BoundsRotation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   SourcePoint                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PreserveSourceZ                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAiFunctionLibrary::GetClosestPointOnBounds(class UObject* WorldContext, const struct FVector& BoundsCenter, const struct FVector& BoundsExtents, const struct FRotator& BoundsRotation, const struct FVector& SourcePoint, bool PreserveSourceZ)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetClosestPointOnBounds");

	Params::AiFunctionLibrary_GetClosestPointOnBounds Parms{};

	Parms.WorldContext = WorldContext;
	Parms.BoundsCenter = std::move(BoundsCenter);
	Parms.BoundsExtents = std::move(BoundsExtents);
	Parms.BoundsRotation = std::move(BoundsRotation);
	Parms.SourcePoint = std::move(SourcePoint);
	Parms.PreserveSourceZ = PreserveSourceZ;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetCrMassEnemySpawnType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          EnemyCharacterBase                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemySpawnType                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrEnemySpawnType UAiFunctionLibrary::GetCrMassEnemySpawnType(class AMassEnemyCharacterBase* EnemyCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetCrMassEnemySpawnType");

	Params::AiFunctionLibrary_GetCrMassEnemySpawnType Parms{};

	Parms.EnemyCharacterBase = EnemyCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetCrMassEnemyType
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          EnemyCharacterBase                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyType                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrEnemyType UAiFunctionLibrary::GetCrMassEnemyType(class AMassEnemyCharacterBase* EnemyCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetCrMassEnemyType");

	Params::AiFunctionLibrary_GetCrMassEnemyType Parms{};

	Parms.EnemyCharacterBase = EnemyCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetDebugMassEnemiesData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, struct FCrDebugEnemyData>   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<int32, struct FCrDebugEnemyData> UAiFunctionLibrary::GetDebugMassEnemiesData(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetDebugMassEnemiesData");

	Params::AiFunctionLibrary_GetDebugMassEnemiesData Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetJumpParabolaY
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   ParabolaParameters                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAiFunctionLibrary::GetJumpParabolaY(const struct FVector& ParabolaParameters, float X)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetJumpParabolaY");

	Params::AiFunctionLibrary_GetJumpParabolaY Parms{};

	Parms.ParabolaParameters = std::move(ParabolaParameters);
	Parms.X = X;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetLootEndLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAiFunctionLibrary::GetLootEndLocation(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetLootEndLocation");

	Params::AiFunctionLibrary_GetLootEndLocation Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetLootStartLocation
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UAiFunctionLibrary::GetLootStartLocation(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetLootStartLocation");

	Params::AiFunctionLibrary_GetLootStartLocation Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetMassEnemyState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          EnemyCharacterBase                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMassEnemyInitializationState           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMassEnemyInitializationState UAiFunctionLibrary::GetMassEnemyState(class AMassEnemyCharacterBase* EnemyCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetMassEnemyState");

	Params::AiFunctionLibrary_GetMassEnemyState Parms{};

	Parms.EnemyCharacterBase = EnemyCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetPitchAngleFromForwardToPosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                SelfTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAiFunctionLibrary::GetPitchAngleFromForwardToPosition(const struct FTransform& SelfTransform, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetPitchAngleFromForwardToPosition");

	Params::AiFunctionLibrary_GetPitchAngleFromForwardToPosition Parms{};

	Parms.SelfTransform = std::move(SelfTransform);
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetPlayersInRadius
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Center                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float&                            Radius                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ACrCharacterPlayerBase*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ACrCharacterPlayerBase*> UAiFunctionLibrary::GetPlayersInRadius(const struct FVector& Center, const float& Radius, class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetPlayersInRadius");

	Params::AiFunctionLibrary_GetPlayersInRadius Parms{};

	Parms.Center = std::move(Center);
	Parms.Radius = Radius;
	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetYawAngleFromForwardToPosition
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                SelfTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAiFunctionLibrary::GetYawAngleFromForwardToPosition(const struct FTransform& SelfTransform, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetYawAngleFromForwardToPosition");

	Params::AiFunctionLibrary_GetYawAngleFromForwardToPosition Parms{};

	Parms.SelfTransform = std::move(SelfTransform);
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.GetYawAngleFromForwardToVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform&                SelfTransform                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   VelocityVector                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAiFunctionLibrary::GetYawAngleFromForwardToVelocity(const struct FTransform& SelfTransform, const struct FVector& VelocityVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "GetYawAngleFromForwardToVelocity");

	Params::AiFunctionLibrary_GetYawAngleFromForwardToVelocity Parms{};

	Parms.SelfTransform = std::move(SelfTransform);
	Parms.VelocityVector = std::move(VelocityVector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.HasLineOfSightToLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TestedActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreOtherAiCollision                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::HasLineOfSightToLocation(class UWorld* World, const class AActor* TestedActor, const struct FVector& TargetLocation, float ConeHalfAngle, bool IgnoreOtherAiCollision, float DebugDrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "HasLineOfSightToLocation");

	Params::AiFunctionLibrary_HasLineOfSightToLocation Parms{};

	Parms.World = World;
	Parms.TestedActor = TestedActor;
	Parms.TargetLocation = std::move(TargetLocation);
	Parms.ConeHalfAngle = ConeHalfAngle;
	Parms.IgnoreOtherAiCollision = IgnoreOtherAiCollision;
	Parms.DebugDrawTime = DebugDrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.HasLineOfSightToTarget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TestedActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ConeHalfAngle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IgnoreOtherAiCollision                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DebugDrawTime                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::HasLineOfSightToTarget(class UWorld* World, const class AActor* TestedActor, const class AActor* TargetActor, float ConeHalfAngle, bool IgnoreOtherAiCollision, float DebugDrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "HasLineOfSightToTarget");

	Params::AiFunctionLibrary_HasLineOfSightToTarget Parms{};

	Parms.World = World;
	Parms.TestedActor = TestedActor;
	Parms.TargetActor = TargetActor;
	Parms.ConeHalfAngle = ConeHalfAngle;
	Parms.IgnoreOtherAiCollision = IgnoreOtherAiCollision;
	Parms.DebugDrawTime = DebugDrawTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.IsActorInFence
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AMassEnemyCharacterBase*    MassEnemyCharacterBase                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::IsActorInFence(const class AMassEnemyCharacterBase* MassEnemyCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "IsActorInFence");

	Params::AiFunctionLibrary_IsActorInFence Parms{};

	Parms.MassEnemyCharacterBase = MassEnemyCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.IsFenceForcedForActor
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AMassEnemyCharacterBase*    MassEnemyCharacterBase                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::IsFenceForcedForActor(const class AMassEnemyCharacterBase* MassEnemyCharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "IsFenceForcedForActor");

	Params::AiFunctionLibrary_IsFenceForcedForActor Parms{};

	Parms.MassEnemyCharacterBase = MassEnemyCharacterBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.IsLocalPlayerIsInsideBox
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   BoxLocation                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ScaledBoxExtent                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutLocalPlayerId                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::IsLocalPlayerIsInsideBox(class UWorld* World, const struct FVector& BoxLocation, const struct FVector& ScaledBoxExtent, int32* OutLocalPlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "IsLocalPlayerIsInsideBox");

	Params::AiFunctionLibrary_IsLocalPlayerIsInsideBox Parms{};

	Parms.World = World;
	Parms.BoxLocation = std::move(BoxLocation);
	Parms.ScaledBoxExtent = std::move(ScaledBoxExtent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalPlayerId != nullptr)
		*OutLocalPlayerId = Parms.OutLocalPlayerId;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.IsLocalPlayerIsInsideSphere
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   SphereLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SphereRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutLocalPlayerId                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::IsLocalPlayerIsInsideSphere(const class UWorld* World, const struct FVector& SphereLocation, float SphereRadius, int32* OutLocalPlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "IsLocalPlayerIsInsideSphere");

	Params::AiFunctionLibrary_IsLocalPlayerIsInsideSphere Parms{};

	Parms.World = World;
	Parms.SphereLocation = std::move(SphereLocation);
	Parms.SphereRadius = SphereRadius;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalPlayerId != nullptr)
		*OutLocalPlayerId = Parms.OutLocalPlayerId;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.IsLootTriggered
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::IsLootTriggered(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "IsLootTriggered");

	Params::AiFunctionLibrary_IsLootTriggered Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.IsNavmeshGenerated
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UWorld*                     World                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      BoundsToCheck                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             AgentName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::IsNavmeshGenerated(const class UWorld* World, const struct FBox& BoundsToCheck, class FName AgentName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "IsNavmeshGenerated");

	Params::AiFunctionLibrary_IsNavmeshGenerated Parms{};

	Parms.World = World;
	Parms.BoundsToCheck = std::move(BoundsToCheck);
	Parms.AgentName = AgentName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.LongAoEAttack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     Attacker                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<class AActor*>&            IgnoredActors                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           AoePoints                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// float                                   PushZDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackRadius                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      PlayerDamageEffect                                     (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      AiDamageEffect                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BuildingDamageAmount                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPushDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PushDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EnemyActorPushVelocity                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EnemyEntityPushVelocity                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::LongAoEAttack(const class AActor* Attacker, const TArray<class AActor*>& IgnoredActors, const TArray<struct FVector>& AoePoints, float PushZDistance, float AttackRadius, TSubclassOf<class UGameplayEffect> PlayerDamageEffect, TSubclassOf<class UGameplayEffect> AiDamageEffect, float BuildingDamageAmount, float MaxPushDistance, float PushDuration, float EnemyActorPushVelocity, float EnemyEntityPushVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "LongAoEAttack");

	Params::AiFunctionLibrary_LongAoEAttack Parms{};

	Parms.Attacker = Attacker;
	Parms.IgnoredActors = std::move(IgnoredActors);
	Parms.AoePoints = std::move(AoePoints);
	Parms.PushZDistance = PushZDistance;
	Parms.AttackRadius = AttackRadius;
	Parms.PlayerDamageEffect = PlayerDamageEffect;
	Parms.AiDamageEffect = AiDamageEffect;
	Parms.BuildingDamageAmount = BuildingDamageAmount;
	Parms.MaxPushDistance = MaxPushDistance;
	Parms.PushDuration = PushDuration;
	Parms.EnemyActorPushVelocity = EnemyActorPushVelocity;
	Parms.EnemyEntityPushVelocity = EnemyEntityPushVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.PushBackEnemyActorFromAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Attacker                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PushSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetZAxis                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::PushBackEnemyActorFromAttack(const class AActor* Attacker, const class AActor* Target, float PushSpeed, bool bResetZAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "PushBackEnemyActorFromAttack");

	Params::AiFunctionLibrary_PushBackEnemyActorFromAttack Parms{};

	Parms.Attacker = Attacker;
	Parms.Target = Target;
	Parms.PushSpeed = PushSpeed;
	Parms.bResetZAxis = bResetZAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.PushBackPlayerFromAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class AActor*                     Attacker                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AActor*                     Target                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPushDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PushDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bResetZAxis                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::PushBackPlayerFromAttack(const class AActor* Attacker, const class AActor* Target, float MaxPushDistance, float PushDuration, bool bResetZAxis)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "PushBackPlayerFromAttack");

	Params::AiFunctionLibrary_PushBackPlayerFromAttack Parms{};

	Parms.Attacker = Attacker;
	Parms.Target = Target;
	Parms.MaxPushDistance = MaxPushDistance;
	Parms.PushDuration = PushDuration;
	Parms.bResetZAxis = bResetZAxis;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.PushEnemyActorInDirection
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   PushVelocity                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::PushEnemyActorInDirection(const class AActor* TargetActor, const struct FVector& PushVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "PushEnemyActorInDirection");

	Params::AiFunctionLibrary_PushEnemyActorInDirection Parms{};

	Parms.TargetActor = TargetActor;
	Parms.PushVelocity = std::move(PushVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.PushPlayerInDirection
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     TargetActor                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Direction                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPushDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PushDuration                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::PushPlayerInDirection(const class AActor* TargetActor, const struct FVector& Direction, float MaxPushDistance, float PushDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "PushPlayerInDirection");

	Params::AiFunctionLibrary_PushPlayerInDirection Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Direction = std::move(Direction);
	Parms.MaxPushDistance = MaxPushDistance;
	Parms.PushDuration = PushDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.RemoveLooseGameplayTagFromEnemyCharacter
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAiFunctionLibrary::RemoveLooseGameplayTagFromEnemyCharacter(class AMassEnemyCharacterBase* Character, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "RemoveLooseGameplayTagFromEnemyCharacter");

	Params::AiFunctionLibrary_RemoveLooseGameplayTagFromEnemyCharacter Parms{};

	Parms.Character = Character;
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.SetIsLootTriggered
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNew                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAiFunctionLibrary::SetIsLootTriggered(class AActor* Actor, bool bNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "SetIsLootTriggered");

	Params::AiFunctionLibrary_SetIsLootTriggered Parms{};

	Parms.Actor = Actor;
	Parms.bNew = bNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.SetIsStuckForActorEnemy
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AActor*                           ActorEnemy                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsStuck                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAiFunctionLibrary::SetIsStuckForActorEnemy(class AActor* ActorEnemy, bool bIsStuck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "SetIsStuckForActorEnemy");

	Params::AiFunctionLibrary_SetIsStuckForActorEnemy Parms{};

	Parms.ActorEnemy = ActorEnemy;
	Parms.bIsStuck = bIsStuck;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.SetMassEnemyState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AMassEnemyCharacterBase*          EnemyCharacterBase                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMassEnemyInitializationState           NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAiFunctionLibrary::SetMassEnemyState(class AMassEnemyCharacterBase* EnemyCharacterBase, EMassEnemyInitializationState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "SetMassEnemyState");

	Params::AiFunctionLibrary_SetMassEnemyState Parms{};

	Parms.EnemyCharacterBase = EnemyCharacterBase;
	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.SpawnEntityAtLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class AActor*                           CallingActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuAPMassSpawnedEntityType&EntityType                                             (Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Scale                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::SpawnEntityAtLocation(class AActor* CallingActor, const struct FAuAPMassSpawnedEntityType& EntityType, const struct FVector& Location, const struct FVector& Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "SpawnEntityAtLocation");

	Params::AiFunctionLibrary_SpawnEntityAtLocation Parms{};

	Parms.CallingActor = CallingActor;
	Parms.EntityType = std::move(EntityType);
	Parms.Location = std::move(Location);
	Parms.Scale = std::move(Scale);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.AiFunctionLibrary.TryStartRagdollForMassEnemy
// (Final, Native, Static, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FMassEntityHandle&         Entity                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiDeathSequenceSubsystem*      DeathSequenceSubsystem                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform&                EntityWorldTransform                                   (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   KillingHitLocation                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   KillingHitNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   KillingHitDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              KillingDamageTag                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMassEnemyStateFragment*         StateFragment                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FCrMassEnemyConfigurationFragment&MassEnemyConfiguration                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FVector&                   VisualVariationSeed                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAiFunctionLibrary::TryStartRagdollForMassEnemy(const struct FMassEntityHandle& Entity, class UCrAiDeathSequenceSubsystem* DeathSequenceSubsystem, const struct FTransform& EntityWorldTransform, const struct FVector& KillingHitLocation, const struct FVector& KillingHitNormal, float KillingHitDistance, const struct FGameplayTag& KillingDamageTag, struct FMassEnemyStateFragment* StateFragment, const struct FCrMassEnemyConfigurationFragment& MassEnemyConfiguration, const struct FVector& VisualVariationSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AiFunctionLibrary", "TryStartRagdollForMassEnemy");

	Params::AiFunctionLibrary_TryStartRagdollForMassEnemy Parms{};

	Parms.Entity = std::move(Entity);
	Parms.DeathSequenceSubsystem = DeathSequenceSubsystem;
	Parms.EntityWorldTransform = std::move(EntityWorldTransform);
	Parms.KillingHitLocation = std::move(KillingHitLocation);
	Parms.KillingHitNormal = std::move(KillingHitNormal);
	Parms.KillingHitDistance = KillingHitDistance;
	Parms.KillingDamageTag = std::move(KillingDamageTag);
	Parms.MassEnemyConfiguration = std::move(MassEnemyConfiguration);
	Parms.VisualVariationSeed = std::move(VisualVariationSeed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (StateFragment != nullptr)
		*StateFragment = std::move(Parms.StateFragment);

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackSpawnIndicator.BP_OnActivateVisuals
// (Event, Public, BlueprintEvent)

void ABaseAttackSpawnIndicator::BP_OnActivateVisuals()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttackSpawnIndicator", "BP_OnActivateVisuals");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackSpawnIndicator.BP_OnDelayedDestroyRequested
// (Event, Public, BlueprintEvent)

void ABaseAttackSpawnIndicator::BP_OnDelayedDestroyRequested()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttackSpawnIndicator", "BP_OnDelayedDestroyRequested");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackSpawnIndicator.BP_OnDied
// (Event, Public, BlueprintEvent)

void ABaseAttackSpawnIndicator::BP_OnDied()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttackSpawnIndicator", "BP_OnDied");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackSpawnIndicator.OnRep_Activated
// (Final, Native, Public)

void ABaseAttackSpawnIndicator::OnRep_Activated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttackSpawnIndicator", "OnRep_Activated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackSpawnIndicator.OnRep_Died
// (Final, Native, Public)

void ABaseAttackSpawnIndicator::OnRep_Died()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseAttackSpawnIndicator", "OnRep_Died");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackVisualizationInterface.OnActivateDonut
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBaseAttackVisualizationInterface::OnActivateDonut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseAttackVisualizationInterface", "OnActivateDonut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackVisualizationInterface.OnAttackIndicatorSpawned
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBaseAttackVisualizationInterface::OnAttackIndicatorSpawned(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseAttackVisualizationInterface", "OnAttackIndicatorSpawned");

	Params::BaseAttackVisualizationInterface_OnAttackIndicatorSpawned Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackVisualizationInterface.OnDeactivateDonut
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IBaseAttackVisualizationInterface::OnDeactivateDonut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseAttackVisualizationInterface", "OnDeactivateDonut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseAttackVisualizationInterface.SetFloatingTrailObjectCount
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IBaseAttackVisualizationInterface::SetFloatingTrailObjectCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("BaseAttackVisualizationInterface", "SetFloatingTrailObjectCount");

	Params::BaseAttackVisualizationInterface_SetFloatingTrailObjectCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyFXEventSubsystem.RegisterEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AMassEnemyCharacterBase*    Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              EventTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMassEnemyFXEventSubsystem::RegisterEvent(const class AMassEnemyCharacterBase* Character, const struct FGameplayTag& EventTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyFXEventSubsystem", "RegisterEvent");

	Params::MassEnemyFXEventSubsystem_RegisterEvent Parms{};

	Parms.Character = Character;
	Parms.EventTag = std::move(EventTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.DonutVisualizationActor.ClearArrayByIndex
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UNiagaraComponent*>&       Array                                                  (Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADonutVisualizationActor::ClearArrayByIndex(TArray<class UNiagaraComponent*>& Array, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DonutVisualizationActor", "ClearArrayByIndex");

	Params::DonutVisualizationActor_ClearArrayByIndex Parms{};

	Parms.Array = std::move(Array);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Array = std::move(Parms.Array);
}


// Function MassAIPrototypeEnemyRuntime.DonutVisualizationActor.OnRep_FloatingTrails
// (Final, Native, Protected)

void ADonutVisualizationActor::OnRep_FloatingTrails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DonutVisualizationActor", "OnRep_FloatingTrails");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.DonutVisualizationActor.SetFloatingTrailObjectCount
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADonutVisualizationActor::SetFloatingTrailObjectCount(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DonutVisualizationActor", "SetFloatingTrailObjectCount");

	Params::DonutVisualizationActor_SetFloatingTrailObjectCount Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.DonutVisualizationActor.StartFallingRandomFloatingTrail
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADonutVisualizationActor::StartFallingRandomFloatingTrail(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DonutVisualizationActor", "StartFallingRandomFloatingTrail");

	Params::DonutVisualizationActor_StartFallingRandomFloatingTrail Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.DonutVisualizationActor.UpdateFallingTrails
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// float                                   DeltaTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADonutVisualizationActor::UpdateFallingTrails(float DeltaTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DonutVisualizationActor", "UpdateFallingTrails");

	Params::DonutVisualizationActor_UpdateFallingTrails Parms{};

	Parms.DeltaTime = DeltaTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.DonutVisualizationActor.UpdateFloatingTrails
// (Final, Native, Protected, BlueprintCallable)

void ADonutVisualizationActor::UpdateFloatingTrails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DonutVisualizationActor", "UpdateFloatingTrails");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MovingTowardsBaseActor.OnDespawnScheduled
// (Event, Protected, BlueprintEvent)

void AMovingTowardsBaseActor::OnDespawnScheduled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingTowardsBaseActor", "OnDespawnScheduled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function MassAIPrototypeEnemyRuntime.MovingTowardsBaseActor.ScheduleDespawnMulticast
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void AMovingTowardsBaseActor::ScheduleDespawnMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovingTowardsBaseActor", "ScheduleDespawnMulticast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.DebugKillAllEnemies
// (Final, Native, Public)

void UBaseSiteAttackSubsystem::DebugKillAllEnemies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "DebugKillAllEnemies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.OnBaseCoreInfected
// (Final, Native, Public)
// Parameters:
// const struct FMassEntityHandle&         Core                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseSiteAttackSubsystem::OnBaseCoreInfected(const struct FMassEntityHandle& Core)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "OnBaseCoreInfected");

	Params::BaseSiteAttackSubsystem_OnBaseCoreInfected Parms{};

	Parms.Core = std::move(Core);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.OnBaseCoreInfectionActorDestroyed
// (Final, Native, Public)
// Parameters:
// const struct FMassEntityHandle&         BaseCore                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    LaseActor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseSiteAttackSubsystem::OnBaseCoreInfectionActorDestroyed(const struct FMassEntityHandle& BaseCore, bool LaseActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "OnBaseCoreInfectionActorDestroyed");

	Params::BaseSiteAttackSubsystem_OnBaseCoreInfectionActorDestroyed Parms{};

	Parms.BaseCore = std::move(BaseCore);
	Parms.LaseActor = LaseActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.OnBaseCoreInfectionCleanedUp
// (Final, Native, Public)
// Parameters:
// const struct FMassEntityHandle&         Core                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseSiteAttackSubsystem::OnBaseCoreInfectionCleanedUp(const struct FMassEntityHandle& Core)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "OnBaseCoreInfectionCleanedUp");

	Params::BaseSiteAttackSubsystem_OnBaseCoreInfectionCleanedUp Parms{};

	Parms.Core = std::move(Core);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.OnCoreInfectionActorDestroyed
// (Final, Native, Public)
// Parameters:
// const struct FMassEntityHandle&         Core                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseSiteAttackSubsystem::OnCoreInfectionActorDestroyed(const struct FMassEntityHandle& Core)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "OnCoreInfectionActorDestroyed");

	Params::BaseSiteAttackSubsystem_OnCoreInfectionActorDestroyed Parms{};

	Parms.Core = std::move(Core);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UBaseSiteAttackSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.OnSaveLoaded
// (Final, Native, Private)

void UBaseSiteAttackSubsystem::OnSaveLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "OnSaveLoaded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.OnWavePositionChanged
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEnviroWave                             Wave                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseSiteAttackSubsystem::OnWavePositionChanged(EEnviroWave Wave, const struct FCrEnviroWaveSettings& Settings, float Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "OnWavePositionChanged");

	Params::BaseSiteAttackSubsystem_OnWavePositionChanged Parms{};

	Parms.Wave = Wave;
	Parms.Settings = std::move(Settings);
	Parms.Position = Position;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.BaseSiteAttackSubsystem.OnWaveStarted
// (Final, Native, Public, HasOutParams)
// Parameters:
// EEnviroWave                             Wave                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EEnviroWaveStage                        Stage                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrEnviroWaveSettings&     Settings                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseSiteAttackSubsystem::OnWaveStarted(EEnviroWave Wave, EEnviroWaveStage Stage, const struct FCrEnviroWaveSettings& Settings, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseSiteAttackSubsystem", "OnWaveStarted");

	Params::BaseSiteAttackSubsystem_OnWaveStarted Parms{};

	Parms.Wave = Wave;
	Parms.Stage = Stage;
	Parms.Settings = std::move(Settings);
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionAttack.Create_CrAiActionAttack
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionAttack>    ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyAttackType                      NewAttackType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewWaitForAnimFinishEvent                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      NewDamageGameplayEffect                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewBuildingInfectionDamage                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedBuildingAttackDistance                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackConeHalfAngle                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeepRotatedToMovement_0                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   TargetPosition_0                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewAttackWithTurnInPlace                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionAttack*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionAttack* UCrAiActionAttack::Create_CrAiActionAttack(TSubclassOf<class UCrAiActionAttack> ActionType, float NewMaxLifetimeS, ECrEnemyAttackType NewAttackType, bool bNewWaitForAnimFinishEvent, TSubclassOf<class UGameplayEffect> NewDamageGameplayEffect, float NewBuildingInfectionDamage, float NewAllowedAttackDistance, float NewAllowedBuildingAttackDistance, float NewAllowedAttackConeHalfAngle, bool bKeepRotatedToMovement_0, float NewYawRotationRate, const struct FVector& TargetPosition_0, bool bNewAttackWithTurnInPlace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionAttack", "Create_CrAiActionAttack");

	Params::CrAiActionAttack_Create_CrAiActionAttack Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewAttackType = NewAttackType;
	Parms.bNewWaitForAnimFinishEvent = bNewWaitForAnimFinishEvent;
	Parms.NewDamageGameplayEffect = NewDamageGameplayEffect;
	Parms.NewBuildingInfectionDamage = NewBuildingInfectionDamage;
	Parms.NewAllowedAttackDistance = NewAllowedAttackDistance;
	Parms.NewAllowedBuildingAttackDistance = NewAllowedBuildingAttackDistance;
	Parms.NewAllowedAttackConeHalfAngle = NewAllowedAttackConeHalfAngle;
	Parms.bKeepRotatedToMovement_0 = bKeepRotatedToMovement_0;
	Parms.NewYawRotationRate = NewYawRotationRate;
	Parms.TargetPosition_0 = std::move(TargetPosition_0);
	Parms.bNewAttackWithTurnInPlace = bNewAttackWithTurnInPlace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemySpawnerTriggerSphere.OnSphereBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMassEnemySpawnerTriggerSphere::OnSphereBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemySpawnerTriggerSphere", "OnSphereBeginOverlap");

	Params::MassEnemySpawnerTriggerSphere_OnSphereBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemySpawnerTriggerSphere.OnSphereEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMassEnemySpawnerTriggerSphere::OnSphereEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemySpawnerTriggerSphere", "OnSphereEndOverlap");

	Params::MassEnemySpawnerTriggerSphere_OnSphereEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionDealAoeDamage.Create_CrAiDealAoeDamage
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionDealAoeDamage>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   AttackLocation_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackRadius_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      DamageGameplayEffect_0                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      DamageToAiGameplayEffect_0                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BuildingInfectionDamage_0                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPushDistance_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PushDuration_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EnemyActorPushVelocity_0                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EnemyEntityPushVelocity_0                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionDealAoeDamage*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionDealAoeDamage* UCrAiActionDealAoeDamage::Create_CrAiDealAoeDamage(TSubclassOf<class UCrAiActionDealAoeDamage> ActionType, float NewMaxLifetimeS, const struct FVector& AttackLocation_0, float AttackRadius_0, TSubclassOf<class UGameplayEffect> DamageGameplayEffect_0, TSubclassOf<class UGameplayEffect> DamageToAiGameplayEffect_0, float BuildingInfectionDamage_0, float MaxPushDistance_0, float PushDuration_0, float EnemyActorPushVelocity_0, float EnemyEntityPushVelocity_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionDealAoeDamage", "Create_CrAiDealAoeDamage");

	Params::CrAiActionDealAoeDamage_Create_CrAiDealAoeDamage Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.AttackLocation_0 = std::move(AttackLocation_0);
	Parms.AttackRadius_0 = AttackRadius_0;
	Parms.DamageGameplayEffect_0 = DamageGameplayEffect_0;
	Parms.DamageToAiGameplayEffect_0 = DamageToAiGameplayEffect_0;
	Parms.BuildingInfectionDamage_0 = BuildingInfectionDamage_0;
	Parms.MaxPushDistance_0 = MaxPushDistance_0;
	Parms.PushDuration_0 = PushDuration_0;
	Parms.EnemyActorPushVelocity_0 = EnemyActorPushVelocity_0;
	Parms.EnemyEntityPushVelocity_0 = EnemyEntityPushVelocity_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionDealDamage.Create_CrAiDealDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionDealDamage>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewTarget                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      NewDamageGameplayEffect                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewBuildingInfectionDamage                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedBuildingAttackDistance                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackConeHalfAngle                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionDealDamage*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionDealDamage* UCrAiActionDealDamage::Create_CrAiDealDamage(TSubclassOf<class UCrAiActionDealDamage> ActionType, float NewMaxLifetimeS, class AActor* NewTarget, TSubclassOf<class UGameplayEffect> NewDamageGameplayEffect, float NewBuildingInfectionDamage, float NewAllowedAttackDistance, float NewAllowedBuildingAttackDistance, float NewAllowedAttackConeHalfAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionDealDamage", "Create_CrAiDealDamage");

	Params::CrAiActionDealDamage_Create_CrAiDealDamage Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewTarget = NewTarget;
	Parms.NewDamageGameplayEffect = NewDamageGameplayEffect;
	Parms.NewBuildingInfectionDamage = NewBuildingInfectionDamage;
	Parms.NewAllowedAttackDistance = NewAllowedAttackDistance;
	Parms.NewAllowedBuildingAttackDistance = NewAllowedBuildingAttackDistance;
	Parms.NewAllowedAttackConeHalfAngle = NewAllowedAttackConeHalfAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionDealLongAoeDamage.Create_CrAiDealLongAoeDamage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionDealLongAoeDamage>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           AoePoints_0                                            (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// float                                   PushZDistance_0                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AttackRadius_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      DamageGameplayEffect_0                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      DamageToAiGameplayEffect_0                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   BuildingInfectionDamage_0                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxPushDistance_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PushDuration_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EnemyActorPushVelocity_0                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EnemyEntityPushVelocity_0                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionDealLongAoeDamage*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionDealLongAoeDamage* UCrAiActionDealLongAoeDamage::Create_CrAiDealLongAoeDamage(TSubclassOf<class UCrAiActionDealLongAoeDamage> ActionType, float NewMaxLifetimeS, const TArray<struct FVector>& AoePoints_0, float PushZDistance_0, float AttackRadius_0, TSubclassOf<class UGameplayEffect> DamageGameplayEffect_0, TSubclassOf<class UGameplayEffect> DamageToAiGameplayEffect_0, float BuildingInfectionDamage_0, float MaxPushDistance_0, float PushDuration_0, float EnemyActorPushVelocity_0, float EnemyEntityPushVelocity_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionDealLongAoeDamage", "Create_CrAiDealLongAoeDamage");

	Params::CrAiActionDealLongAoeDamage_Create_CrAiDealLongAoeDamage Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.AoePoints_0 = std::move(AoePoints_0);
	Parms.PushZDistance_0 = PushZDistance_0;
	Parms.AttackRadius_0 = AttackRadius_0;
	Parms.DamageGameplayEffect_0 = DamageGameplayEffect_0;
	Parms.DamageToAiGameplayEffect_0 = DamageToAiGameplayEffect_0;
	Parms.BuildingInfectionDamage_0 = BuildingInfectionDamage_0;
	Parms.MaxPushDistance_0 = MaxPushDistance_0;
	Parms.PushDuration_0 = PushDuration_0;
	Parms.EnemyActorPushVelocity_0 = EnemyActorPushVelocity_0;
	Parms.EnemyEntityPushVelocity_0 = EnemyEntityPushVelocity_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionDissolve.Create_CrAiActionDissolve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionDissolve>  ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionDissolve*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionDissolve* UCrAiActionDissolve::Create_CrAiActionDissolve(TSubclassOf<class UCrAiActionDissolve> ActionType, float NewMaxLifetimeS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionDissolve", "Create_CrAiActionDissolve");

	Params::CrAiActionDissolve_Create_CrAiActionDissolve Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionFinishMassAnim.Create_CrAiActionFinishMassAnim
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionFinishMassAnim>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewWaitForAnimFinishEvent                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewFinishImmediately                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeepRotatedToMovement_0                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionFinishMassAnim*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionFinishMassAnim* UCrAiActionFinishMassAnim::Create_CrAiActionFinishMassAnim(TSubclassOf<class UCrAiActionFinishMassAnim> ActionType, float NewMaxLifetimeS, bool bNewWaitForAnimFinishEvent, bool bNewFinishImmediately, bool bKeepRotatedToMovement_0, float NewYawRotationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionFinishMassAnim", "Create_CrAiActionFinishMassAnim");

	Params::CrAiActionFinishMassAnim_Create_CrAiActionFinishMassAnim Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.bNewWaitForAnimFinishEvent = bNewWaitForAnimFinishEvent;
	Parms.bNewFinishImmediately = bNewFinishImmediately;
	Parms.bKeepRotatedToMovement_0 = bKeepRotatedToMovement_0;
	Parms.NewYawRotationRate = NewYawRotationRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionFinishMassAnim.OnAnimFinished
// (Final, Native, Public)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyLocomotionType                  NewLocomotionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyAttackType                      NewAttackType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyJumpState                       NewJumpState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionFinishMassAnim::OnAnimFinished(class AActor* AiActor, ECrEnemyLocomotionType NewLocomotionType, ECrEnemyAttackType NewAttackType, ECrEnemyJumpState NewJumpState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionFinishMassAnim", "OnAnimFinished");

	Params::CrAiActionFinishMassAnim_OnAnimFinished Parms{};

	Parms.AiActor = AiActor;
	Parms.NewLocomotionType = NewLocomotionType;
	Parms.NewAttackType = NewAttackType;
	Parms.NewJumpState = NewJumpState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionHitReaction.Create_CrAiActionHitReaction
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionHitReaction>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NewHitWorldPosition_0                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NewHitDirection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewIsWeakpointDamage                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionHitReaction*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionHitReaction* UCrAiActionHitReaction::Create_CrAiActionHitReaction(TSubclassOf<class UCrAiActionHitReaction> ActionType, float NewMaxLifetimeS, const struct FVector& NewHitWorldPosition_0, const struct FVector& NewHitDirection, bool bNewIsWeakpointDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionHitReaction", "Create_CrAiActionHitReaction");

	Params::CrAiActionHitReaction_Create_CrAiActionHitReaction Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewHitWorldPosition_0 = std::move(NewHitWorldPosition_0);
	Parms.NewHitDirection = std::move(NewHitDirection);
	Parms.bNewIsWeakpointDamage = bNewIsWeakpointDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionJumpAttack.Create_CrAiActionJumpAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionAttack>    ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyAttackType                      NewAttackType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewWaitForAnimFinishEvent                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      NewDamageGameplayEffect                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewBuildingInfectionDamage                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackConeHalfAngle                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NewKeepRotatedToMovement                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewJumpArcParam01                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewExpectedJumpDuration                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewJumpAttackFocusPriority                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMinJumpVelocity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxJumpVelocity                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxPushDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewPushDuration                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionJumpAttack*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionJumpAttack* UCrAiActionJumpAttack::Create_CrAiActionJumpAttack(TSubclassOf<class UCrAiActionAttack> ActionType, float NewMaxLifetimeS, ECrEnemyAttackType NewAttackType, bool bNewWaitForAnimFinishEvent, TSubclassOf<class UGameplayEffect> NewDamageGameplayEffect, float NewBuildingInfectionDamage, float NewAllowedAttackDistance, float NewAllowedAttackConeHalfAngle, bool NewKeepRotatedToMovement, float NewYawRotationRate, float NewJumpArcParam01, float NewExpectedJumpDuration, float NewJumpAttackFocusPriority, float NewMinJumpVelocity, float NewMaxJumpVelocity, float NewMaxPushDistance, float NewPushDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionJumpAttack", "Create_CrAiActionJumpAttack");

	Params::CrAiActionJumpAttack_Create_CrAiActionJumpAttack Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewAttackType = NewAttackType;
	Parms.bNewWaitForAnimFinishEvent = bNewWaitForAnimFinishEvent;
	Parms.NewDamageGameplayEffect = NewDamageGameplayEffect;
	Parms.NewBuildingInfectionDamage = NewBuildingInfectionDamage;
	Parms.NewAllowedAttackDistance = NewAllowedAttackDistance;
	Parms.NewAllowedAttackConeHalfAngle = NewAllowedAttackConeHalfAngle;
	Parms.NewKeepRotatedToMovement = NewKeepRotatedToMovement;
	Parms.NewYawRotationRate = NewYawRotationRate;
	Parms.NewJumpArcParam01 = NewJumpArcParam01;
	Parms.NewExpectedJumpDuration = NewExpectedJumpDuration;
	Parms.NewJumpAttackFocusPriority = NewJumpAttackFocusPriority;
	Parms.NewMinJumpVelocity = NewMinJumpVelocity;
	Parms.NewMaxJumpVelocity = NewMaxJumpVelocity;
	Parms.NewMaxPushDistance = NewMaxPushDistance;
	Parms.NewPushDuration = NewPushDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionJumpAttack.OnCharacterMovementLanded
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrAiActionJumpAttack::OnCharacterMovementLanded(class AActor* AiActor, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionJumpAttack", "OnCharacterMovementLanded");

	Params::CrAiActionJumpAttack_OnCharacterMovementLanded Parms{};

	Parms.AiActor = AiActor;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionJumpAttack.OnCharacterMovementLanded_Client
// (Final, Native, Public)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionJumpAttack::OnCharacterMovementLanded_Client(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionJumpAttack", "OnCharacterMovementLanded_Client");

	Params::CrAiActionJumpAttack_OnCharacterMovementLanded_Client Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionJumpAttack.OnOwnerHit
// (Final, Native, Public, HasOutParams, HasDefaults)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NormalImpulse                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrAiActionJumpAttack::OnOwnerHit(class AActor* AiActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionJumpAttack", "OnOwnerHit");

	Params::CrAiActionJumpAttack_OnOwnerHit Parms{};

	Parms.AiActor = AiActor;
	Parms.OtherActor = OtherActor;
	Parms.NormalImpulse = std::move(NormalImpulse);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiMovementAttackInstigator.GetMovementAttackStage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMovementAttackStage                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMovementAttackStage ICrAiMovementAttackInstigator::GetMovementAttackStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAiMovementAttackInstigator", "GetMovementAttackStage");

	Params::CrAiMovementAttackInstigator_GetMovementAttackStage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiMovementAttackInstigator.SetMovementAttackStage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMovementAttackStage                    MovementAttackStage                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ICrAiMovementAttackInstigator::SetMovementAttackStage(EMovementAttackStage MovementAttackStage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("CrAiMovementAttackInstigator", "SetMovementAttackStage");

	Params::CrAiMovementAttackInstigator_SetMovementAttackStage Parms{};

	Parms.MovementAttackStage = MovementAttackStage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionMovementAttack.Create_CrAiActionMovementAttack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionMovementAttack>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyAttackType                      NewAttackType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewWaitForAnimFinishEvent                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      NewDamageGameplayEffect                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewBuildingInfectionDamage                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackConeHalfAngle                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewKeepRotatedToMovement                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMovementSpeed                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewMidAnimLoopsNum                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionMovementAttack*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionMovementAttack* UCrAiActionMovementAttack::Create_CrAiActionMovementAttack(TSubclassOf<class UCrAiActionMovementAttack> ActionType, float NewMaxLifetimeS, ECrEnemyAttackType NewAttackType, bool bNewWaitForAnimFinishEvent, TSubclassOf<class UGameplayEffect> NewDamageGameplayEffect, float NewBuildingInfectionDamage, float NewAllowedAttackDistance, float NewAllowedAttackConeHalfAngle, bool bNewKeepRotatedToMovement, float NewYawRotationRate, float NewMovementSpeed, int32 NewMidAnimLoopsNum)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionMovementAttack", "Create_CrAiActionMovementAttack");

	Params::CrAiActionMovementAttack_Create_CrAiActionMovementAttack Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewAttackType = NewAttackType;
	Parms.bNewWaitForAnimFinishEvent = bNewWaitForAnimFinishEvent;
	Parms.NewDamageGameplayEffect = NewDamageGameplayEffect;
	Parms.NewBuildingInfectionDamage = NewBuildingInfectionDamage;
	Parms.NewAllowedAttackDistance = NewAllowedAttackDistance;
	Parms.NewAllowedAttackConeHalfAngle = NewAllowedAttackConeHalfAngle;
	Parms.bNewKeepRotatedToMovement = bNewKeepRotatedToMovement;
	Parms.NewYawRotationRate = NewYawRotationRate;
	Parms.NewMovementSpeed = NewMovementSpeed;
	Parms.NewMidAnimLoopsNum = NewMidAnimLoopsNum;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionMoveTo.Create_CrAiActionMoveTo
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionMoveTo>    ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrAiActionDataMovement&   NewMovementActionData                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// ECrEnemyLocomotionType                  LocomotionType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionMoveTo*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionMoveTo* UCrAiActionMoveTo::Create_CrAiActionMoveTo(TSubclassOf<class UCrAiActionMoveTo> ActionType, float NewMaxLifetimeS, const struct FCrAiActionDataMovement& NewMovementActionData, ECrEnemyLocomotionType LocomotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionMoveTo", "Create_CrAiActionMoveTo");

	Params::CrAiActionMoveTo_Create_CrAiActionMoveTo Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewMovementActionData = std::move(NewMovementActionData);
	Parms.LocomotionType = LocomotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionMoveTo.OnEnterNavlink
// (Final, Native, Public, HasDefaults)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionMoveTo::OnEnterNavlink(class AActor* AiActor, const struct FVector& Start, const struct FVector& End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionMoveTo", "OnEnterNavlink");

	Params::CrAiActionMoveTo_OnEnterNavlink Parms{};

	Parms.AiActor = AiActor;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionMoveTo.OnNavlikJumpEnded
// (Final, Native, Public)
// Parameters:
// class UCrAiAction*                      Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionMoveTo::OnNavlikJumpEnded(class UCrAiAction* Action)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionMoveTo", "OnNavlikJumpEnded");

	Params::CrAiActionMoveTo_OnNavlikJumpEnded Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionPlayAnimation.Create_CrAiActionPlayAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionPlayAnimation>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyLocomotionType                  NewLocomotionState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWaitForAnimFinishEvent_0                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewFinishImmediately                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bKeepRotatedToMovement_0                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionPlayAnimation*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionPlayAnimation* UCrAiActionPlayAnimation::Create_CrAiActionPlayAnimation(TSubclassOf<class UCrAiActionPlayAnimation> ActionType, float NewMaxLifetimeS, ECrEnemyLocomotionType NewLocomotionState, bool bWaitForAnimFinishEvent_0, bool bNewFinishImmediately, bool bKeepRotatedToMovement_0, float NewYawRotationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionPlayAnimation", "Create_CrAiActionPlayAnimation");

	Params::CrAiActionPlayAnimation_Create_CrAiActionPlayAnimation Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewLocomotionState = NewLocomotionState;
	Parms.bWaitForAnimFinishEvent_0 = bWaitForAnimFinishEvent_0;
	Parms.bNewFinishImmediately = bNewFinishImmediately;
	Parms.bKeepRotatedToMovement_0 = bKeepRotatedToMovement_0;
	Parms.NewYawRotationRate = NewYawRotationRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionRotateToFocus.Create_CrAiActionRotateToFocus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionRotateToFocus>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewThresholdAngleDeg                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionRotateToFocus*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionRotateToFocus* UCrAiActionRotateToFocus::Create_CrAiActionRotateToFocus(TSubclassOf<class UCrAiActionRotateToFocus> ActionType, float NewMaxLifetimeS, float NewThresholdAngleDeg, float NewYawRotationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionRotateToFocus", "Create_CrAiActionRotateToFocus");

	Params::CrAiActionRotateToFocus_Create_CrAiActionRotateToFocus Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewThresholdAngleDeg = NewThresholdAngleDeg;
	Parms.NewYawRotationRate = NewYawRotationRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionSetEyeState.Create_CrAiActionSetEyeState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionSetEyeState>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bModifyIsAggro_0                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsAggro_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bModifyIsBoosted_0                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsBoosted_0                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bModifyIsJumpWindup_0                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsJumpWindup_0                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionSetEyeState*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionSetEyeState* UCrAiActionSetEyeState::Create_CrAiActionSetEyeState(TSubclassOf<class UCrAiActionSetEyeState> ActionType, float NewMaxLifetimeS, bool bModifyIsAggro_0, bool bIsAggro_0, bool bModifyIsBoosted_0, bool bIsBoosted_0, bool bModifyIsJumpWindup_0, bool bIsJumpWindup_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionSetEyeState", "Create_CrAiActionSetEyeState");

	Params::CrAiActionSetEyeState_Create_CrAiActionSetEyeState Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.bModifyIsAggro_0 = bModifyIsAggro_0;
	Parms.bIsAggro_0 = bIsAggro_0;
	Parms.bModifyIsBoosted_0 = bModifyIsBoosted_0;
	Parms.bIsBoosted_0 = bIsBoosted_0;
	Parms.bModifyIsJumpWindup_0 = bModifyIsJumpWindup_0;
	Parms.bIsJumpWindup_0 = bIsJumpWindup_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionSetFocus.Create_CrAiActionSetFocus
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionSetFocus>  ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewClearFocus                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           NewFocusActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NewFocusPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewFocusPriority                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionSetFocus*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionSetFocus* UCrAiActionSetFocus::Create_CrAiActionSetFocus(TSubclassOf<class UCrAiActionSetFocus> ActionType, float NewMaxLifetimeS, bool bNewClearFocus, class AActor* NewFocusActor, const struct FVector& NewFocusPosition, int32 NewFocusPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionSetFocus", "Create_CrAiActionSetFocus");

	Params::CrAiActionSetFocus_Create_CrAiActionSetFocus Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.bNewClearFocus = bNewClearFocus;
	Parms.NewFocusActor = NewFocusActor;
	Parms.NewFocusPosition = std::move(NewFocusPosition);
	Parms.NewFocusPriority = NewFocusPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionShoot.Create_CrAiActionShoot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionShoot>     ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class ACrAiProjectileActor> PooledProjectileType_0                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   StartLocation_0                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   EndLocation_0                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ArcParam_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   GravityOverride_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ShootVelocityVariance                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ProjectileSpawnMeshSlotName                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyAttackType                      NewAttackType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffect>      NewDamageGameplayEffect                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewBuildingInfectionDamage                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackDistance                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewAllowedAttackConeHalfAngle                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionShoot*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionShoot* UCrAiActionShoot::Create_CrAiActionShoot(TSubclassOf<class UCrAiActionShoot> ActionType, float NewMaxLifetimeS, TSubclassOf<class ACrAiProjectileActor> PooledProjectileType_0, const struct FVector& StartLocation_0, const struct FVector& EndLocation_0, float ArcParam_0, float GravityOverride_0, float ShootVelocityVariance, const class FName& ProjectileSpawnMeshSlotName, ECrEnemyAttackType NewAttackType, TSubclassOf<class UGameplayEffect> NewDamageGameplayEffect, float NewBuildingInfectionDamage, float NewAllowedAttackDistance, float NewAllowedAttackConeHalfAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionShoot", "Create_CrAiActionShoot");

	Params::CrAiActionShoot_Create_CrAiActionShoot Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.PooledProjectileType_0 = PooledProjectileType_0;
	Parms.StartLocation_0 = std::move(StartLocation_0);
	Parms.EndLocation_0 = std::move(EndLocation_0);
	Parms.ArcParam_0 = ArcParam_0;
	Parms.GravityOverride_0 = GravityOverride_0;
	Parms.ShootVelocityVariance = ShootVelocityVariance;
	Parms.ProjectileSpawnMeshSlotName = ProjectileSpawnMeshSlotName;
	Parms.NewAttackType = NewAttackType;
	Parms.NewDamageGameplayEffect = NewDamageGameplayEffect;
	Parms.NewBuildingInfectionDamage = NewBuildingInfectionDamage;
	Parms.NewAllowedAttackDistance = NewAllowedAttackDistance;
	Parms.NewAllowedAttackConeHalfAngle = NewAllowedAttackConeHalfAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionShoot.OnShootAnimEvent
// (Final, Native, Public)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionShoot::OnShootAnimEvent(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionShoot", "OnShootAnimEvent");

	Params::CrAiActionShoot_OnShootAnimEvent Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionShoot.OnShootAnimEventOnClient
// (Final, Native, Public)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionShoot::OnShootAnimEventOnClient(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionShoot", "OnShootAnimEventOnClient");

	Params::CrAiActionShoot_OnShootAnimEventOnClient Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionSpawnAnimation.Create_CrAiActionSpawnAnimation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionPlayAnimation>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyLocomotionType                  NewLocomotionState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewWaitForAnimFinishEvent                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewNewFinishImmediately                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewKeepRotatedToMovement                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemySpawnType                       InSpawnType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionSpawnAnimation*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionSpawnAnimation* UCrAiActionSpawnAnimation::Create_CrAiActionSpawnAnimation(TSubclassOf<class UCrAiActionPlayAnimation> ActionType, float NewMaxLifetimeS, ECrEnemyLocomotionType NewLocomotionState, bool bNewWaitForAnimFinishEvent, bool bNewNewFinishImmediately, bool bNewKeepRotatedToMovement, float NewYawRotationRate, ECrEnemySpawnType InSpawnType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionSpawnAnimation", "Create_CrAiActionSpawnAnimation");

	Params::CrAiActionSpawnAnimation_Create_CrAiActionSpawnAnimation Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewLocomotionState = NewLocomotionState;
	Parms.bNewWaitForAnimFinishEvent = bNewWaitForAnimFinishEvent;
	Parms.bNewNewFinishImmediately = bNewNewFinishImmediately;
	Parms.bNewKeepRotatedToMovement = bNewKeepRotatedToMovement;
	Parms.NewYawRotationRate = NewYawRotationRate;
	Parms.InSpawnType = InSpawnType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionSpawnEntity.Create_CrAiActionSpawnEntity
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionSpawnEntity>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAuAPMassSpawnedEntityType&EntityType_0                                           (Parm, NativeAccessSpecifierPublic)
// const struct FTransform&                SpawnTransform_0                                       (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionSpawnEntity*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionSpawnEntity* UCrAiActionSpawnEntity::Create_CrAiActionSpawnEntity(TSubclassOf<class UCrAiActionSpawnEntity> ActionType, float NewMaxLifetimeS, const struct FAuAPMassSpawnedEntityType& EntityType_0, const struct FTransform& SpawnTransform_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionSpawnEntity", "Create_CrAiActionSpawnEntity");

	Params::CrAiActionSpawnEntity_Create_CrAiActionSpawnEntity Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.EntityType_0 = std::move(EntityType_0);
	Parms.SpawnTransform_0 = std::move(SpawnTransform_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionTaunt.Create_CrAiActionTaunt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionPlayAnimation>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyLocomotionType                  NewLocomotionState                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewWaitForAnimFinishEvent                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewFinishImmediately                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bNewKeepRotatedToMovement                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<ECrEnemyTauntType>&        NewAvailableTauntTypes                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UCrAiActionTaunt*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionTaunt* UCrAiActionTaunt::Create_CrAiActionTaunt(TSubclassOf<class UCrAiActionPlayAnimation> ActionType, float NewMaxLifetimeS, ECrEnemyLocomotionType NewLocomotionState, bool bNewWaitForAnimFinishEvent, bool bNewFinishImmediately, bool bNewKeepRotatedToMovement, float NewYawRotationRate, const TArray<ECrEnemyTauntType>& NewAvailableTauntTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionTaunt", "Create_CrAiActionTaunt");

	Params::CrAiActionTaunt_Create_CrAiActionTaunt Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.NewLocomotionState = NewLocomotionState;
	Parms.bNewWaitForAnimFinishEvent = bNewWaitForAnimFinishEvent;
	Parms.bNewFinishImmediately = bNewFinishImmediately;
	Parms.bNewKeepRotatedToMovement = bNewKeepRotatedToMovement;
	Parms.NewYawRotationRate = NewYawRotationRate;
	Parms.NewAvailableTauntTypes = std::move(NewAvailableTauntTypes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionUseNavlink.Create_CrAiActionUseNavlink
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UCrAiActionUseNavlink>ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewMaxLifetimeS                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ActorStartLocation_0                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NavlinkStartLocation_0                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NavlinkEndLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FCrUseNavLinkActionConfiguration&InUseNavLinkActionConfiguration                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bPerformJumpEvenIfLocationNotFree_0                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiActionUseNavlink*            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiActionUseNavlink* UCrAiActionUseNavlink::Create_CrAiActionUseNavlink(TSubclassOf<class UCrAiActionUseNavlink> ActionType, float NewMaxLifetimeS, const struct FVector& ActorStartLocation_0, const struct FVector& NavlinkStartLocation_0, const struct FVector& NavlinkEndLocation, const struct FCrUseNavLinkActionConfiguration& InUseNavLinkActionConfiguration, bool bPerformJumpEvenIfLocationNotFree_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CrAiActionUseNavlink", "Create_CrAiActionUseNavlink");

	Params::CrAiActionUseNavlink_Create_CrAiActionUseNavlink Parms{};

	Parms.ActionType = ActionType;
	Parms.NewMaxLifetimeS = NewMaxLifetimeS;
	Parms.ActorStartLocation_0 = std::move(ActorStartLocation_0);
	Parms.NavlinkStartLocation_0 = std::move(NavlinkStartLocation_0);
	Parms.NavlinkEndLocation = std::move(NavlinkEndLocation);
	Parms.InUseNavLinkActionConfiguration = std::move(InUseNavLinkActionConfiguration);
	Parms.bPerformJumpEvenIfLocationNotFree_0 = bPerformJumpEvenIfLocationNotFree_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionUseNavlink.OnBeforeLand
// (Final, Native, Public)

void UCrAiActionUseNavlink::OnBeforeLand()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionUseNavlink", "OnBeforeLand");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionUseNavlink.OnCharacterMovementLanded
// (Final, Native, Public, HasOutParams)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UCrAiActionUseNavlink::OnCharacterMovementLanded(class AActor* AiActor, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionUseNavlink", "OnCharacterMovementLanded");

	Params::CrAiActionUseNavlink_OnCharacterMovementLanded Parms{};

	Parms.AiActor = AiActor;
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionUseNavlink.OnJumpAnimationEvent
// (Final, Native, Public)
// Parameters:
// class AActor*                           AiActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionUseNavlink::OnJumpAnimationEvent(class AActor* AiActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionUseNavlink", "OnJumpAnimationEvent");

	Params::CrAiActionUseNavlink_OnJumpAnimationEvent Parms{};

	Parms.AiActor = AiActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionUseNavlink.OnLandAnimationEnded
// (Final, Native, Public)

void UCrAiActionUseNavlink::OnLandAnimationEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionUseNavlink", "OnLandAnimationEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionUseNavlink.OnLandAnimationEnded_Client
// (Final, Native, Public)

void UCrAiActionUseNavlink::OnLandAnimationEnded_Client()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionUseNavlink", "OnLandAnimationEnded_Client");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionUseNavlink.OnRep_CalculatedJumpVelocity
// (Final, Native, Public)

void UCrAiActionUseNavlink::OnRep_CalculatedJumpVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionUseNavlink", "OnRep_CalculatedJumpVelocity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiActionUseNavlink.OnServerLanded
// (Final, Native, Public)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiActionUseNavlink::OnServerLanded(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiActionUseNavlink", "OnServerLanded");

	Params::CrAiActionUseNavlink_OnServerLanded Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiPcgNavlinkSubsystem.InitNavlinkSubsystem
// (Final, Native, Protected)

void UCrAiPcgNavlinkSubsystem::InitNavlinkSubsystem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiPcgNavlinkSubsystem", "InitNavlinkSubsystem");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiPcgNavlinkSubsystem.OnTileGenerated
// (Final, Native, Protected)
// Parameters:
// int32                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETileGenerationType                     TileGenerationType                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCrAiPcgNavlinkSubsystem::OnTileGenerated(int32 X, int32 Y, ETileGenerationType TileGenerationType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiPcgNavlinkSubsystem", "OnTileGenerated");

	Params::CrAiPcgNavlinkSubsystem_OnTileGenerated Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.TileGenerationType = TileGenerationType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.CrAiPcgNavlinkSubsystem.GetNavmeshEdgeData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   MaxMoveInsideNavmeshOffset                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MinMoveInsideNavmeshOffset                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceBetweenPoints                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PosX                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PosY                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Points                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Directions                                             (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UCrAiPcgNavlinkSubsystem::GetNavmeshEdgeData(float MaxMoveInsideNavmeshOffset, float MinMoveInsideNavmeshOffset, float DistanceBetweenPoints, int32 PosX, int32 PosY, TArray<struct FVector>* Points, TArray<struct FVector>* Directions) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAiPcgNavlinkSubsystem", "GetNavmeshEdgeData");

	Params::CrAiPcgNavlinkSubsystem_GetNavmeshEdgeData Parms{};

	Parms.MaxMoveInsideNavmeshOffset = MaxMoveInsideNavmeshOffset;
	Parms.MinMoveInsideNavmeshOffset = MinMoveInsideNavmeshOffset;
	Parms.DistanceBetweenPoints = DistanceBetweenPoints;
	Parms.PosX = PosX;
	Parms.PosY = PosY;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Points != nullptr)
		*Points = std::move(Parms.Points);

	if (Directions != nullptr)
		*Directions = std::move(Parms.Directions);
}


// Function MassAIPrototypeEnemyRuntime.CrAnimNotify_RunAiAction.CreateAiAction
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCrAiAction*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCrAiAction* UCrAnimNotify_RunAiAction::CreateAiAction(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CrAnimNotify_RunAiAction", "CreateAiAction");

	Params::CrAnimNotify_RunAiAction_CreateAiAction Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAiSpawner.DespawnAll
// (Final, Native, Public, BlueprintCallable)

void AMassEnemyAiSpawner::DespawnAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAiSpawner", "DespawnAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAiSpawner.DisableActivationTrigger
// (Native, Public, BlueprintCallable)

void AMassEnemyAiSpawner::DisableActivationTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAiSpawner", "DisableActivationTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAiSpawner.DisableSpawning
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bPermanently                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyAiSpawner::DisableSpawning(bool bPermanently)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAiSpawner", "DisableSpawning");

	Params::MassEnemyAiSpawner_DisableSpawning Parms{};

	Parms.bPermanently = bPermanently;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAiSpawner.EnableActivationTrigger
// (Native, Public, BlueprintCallable)

void AMassEnemyAiSpawner::EnableActivationTrigger()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAiSpawner", "EnableActivationTrigger");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAiSpawner.EnableSpawning
// (Native, Public, BlueprintCallable)

void AMassEnemyAiSpawner::EnableSpawning()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAiSpawner", "EnableSpawning");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.BanCurrentTarget
// (Native, Public)

void IMassEnemyActor::BanCurrentTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "BanCurrentTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.ClearFocus
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   FocusPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::ClearFocus(int32 FocusPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "ClearFocus");

	Params::MassEnemyActor_ClearFocus Parms{};

	Parms.FocusPriority = FocusPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.GetArcParamOverride
// (Native, Public)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IMassEnemyActor::GetArcParamOverride()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "GetArcParamOverride");

	Params::MassEnemyActor_GetArcParamOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.GetFocusPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IMassEnemyActor::GetFocusPosition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "GetFocusPosition");

	Params::MassEnemyActor_GetFocusPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.GetMassEnemyInitializationState
// (Native, Public)
// Parameters:
// EMassEnemyInitializationState           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EMassEnemyInitializationState IMassEnemyActor::GetMassEnemyInitializationState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "GetMassEnemyInitializationState");

	Params::MassEnemyActor_GetMassEnemyInitializationState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.IsMovementBlocked
// (Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMassEnemyActor::IsMovementBlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "IsMovementBlocked");

	Params::MassEnemyActor_IsMovementBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.IsRotationBlocked
// (Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IMassEnemyActor::IsRotationBlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "IsRotationBlocked");

	Params::MassEnemyActor_IsRotationBlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.NotifyAnimationFinished
// (Native, Public)

void IMassEnemyActor::NotifyAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "NotifyAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.OnAnimationFinished
// (Native, Public)
// Parameters:
// ECrEnemyLocomotionType                  LocomotionType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyAttackType                      AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyJumpState                       JumpState                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::OnAnimationFinished(ECrEnemyLocomotionType LocomotionType, ECrEnemyAttackType AttackType, ECrEnemyJumpState JumpState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "OnAnimationFinished");

	Params::MassEnemyActor_OnAnimationFinished Parms{};

	Parms.LocomotionType = LocomotionType;
	Parms.AttackType = AttackType;
	Parms.JumpState = JumpState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.OnAttackAnimationFinished
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECrEnemyAttackType                      AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::OnAttackAnimationFinished(ECrEnemyAttackType AttackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "OnAttackAnimationFinished");

	Params::MassEnemyActor_OnAttackAnimationFinished Parms{};

	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.OnDamageReceived
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FVector&                   HitWorldPosition                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   HitDirection                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsWeakpointDamage                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::OnDamageReceived(const struct FVector& HitWorldPosition, const struct FVector& HitDirection, bool bIsWeakpointDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "OnDamageReceived");

	Params::MassEnemyActor_OnDamageReceived Parms{};

	Parms.HitWorldPosition = std::move(HitWorldPosition);
	Parms.HitDirection = std::move(HitDirection);
	Parms.bIsWeakpointDamage = bIsWeakpointDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.OnDealDamageAnimationEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECrEnemyAttackType                      AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::OnDealDamageAnimationEvent(ECrEnemyAttackType AttackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "OnDealDamageAnimationEvent");

	Params::MassEnemyActor_OnDealDamageAnimationEvent Parms{};

	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.OnJumpedAnimationEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IMassEnemyActor::OnJumpedAnimationEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "OnJumpedAnimationEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.OnLandedAnimationEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IMassEnemyActor::OnLandedAnimationEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "OnLandedAnimationEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.OnShootAnimationEvent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void IMassEnemyActor::OnShootAnimationEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "OnShootAnimationEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.OverrideDefaultActorVisibility
// (Native, Public)
// Parameters:
// float                                   DelayedActorShouldBeVisibleTimestamp                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::OverrideDefaultActorVisibility(float DelayedActorShouldBeVisibleTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "OverrideDefaultActorVisibility");

	Params::MassEnemyActor_OverrideDefaultActorVisibility Parms{};

	Parms.DelayedActorShouldBeVisibleTimestamp = DelayedActorShouldBeVisibleTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetActorSyncData
// (Native, Public)
// Parameters:
// const struct FMassEnemyAnimationSyncData&ActorSyncData                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetActorSyncData(const struct FMassEnemyAnimationSyncData& ActorSyncData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetActorSyncData");

	Params::MassEnemyActor_SetActorSyncData Parms{};

	Parms.ActorSyncData = std::move(ActorSyncData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetArcParamOverride
// (Native, Public)
// Parameters:
// float                                   NewForcedArcParam                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetArcParamOverride(float NewForcedArcParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetArcParamOverride");

	Params::MassEnemyActor_SetArcParamOverride Parms{};

	Parms.NewForcedArcParam = NewForcedArcParam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetAttackType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECrEnemyAttackType                      AttackType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetAttackType(ECrEnemyAttackType AttackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetAttackType");

	Params::MassEnemyActor_SetAttackType Parms{};

	Parms.AttackType = AttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetDissolveProgress
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetDissolveProgress(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetDissolveProgress");

	Params::MassEnemyActor_SetDissolveProgress Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetFocusActor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           NewFocusActor                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FocusPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetFocusActor(class AActor* NewFocusActor, int32 FocusPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetFocusActor");

	Params::MassEnemyActor_SetFocusActor Parms{};

	Parms.NewFocusActor = NewFocusActor;
	Parms.FocusPriority = FocusPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetFocusPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   NewFocusPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FocusPriority                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetFocusPosition(const struct FVector& NewFocusPosition, int32 FocusPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetFocusPosition");

	Params::MassEnemyActor_SetFocusPosition Parms{};

	Parms.NewFocusPosition = std::move(NewFocusPosition);
	Parms.FocusPriority = FocusPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetGroundHitResult
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetGroundHitResult(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetGroundHitResult");

	Params::MassEnemyActor_SetGroundHitResult Parms{};

	Parms.HitResult = std::move(HitResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetIsAggroEyeColor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewIsAggro                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetIsAggroEyeColor(bool NewIsAggro)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetIsAggroEyeColor");

	Params::MassEnemyActor_SetIsAggroEyeColor Parms{};

	Parms.NewIsAggro = NewIsAggro;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetIsBoostedEyeColor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewIsBoosted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetIsBoostedEyeColor(bool NewIsBoosted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetIsBoostedEyeColor");

	Params::MassEnemyActor_SetIsBoostedEyeColor Parms{};

	Parms.NewIsBoosted = NewIsBoosted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetIsJumpEyeBehaviour
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewIsJumpEyeBehaviour                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetIsJumpEyeBehaviour(bool NewIsJumpEyeBehaviour)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetIsJumpEyeBehaviour");

	Params::MassEnemyActor_SetIsJumpEyeBehaviour Parms{};

	Parms.NewIsJumpEyeBehaviour = NewIsJumpEyeBehaviour;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetIsPlayingRootMotionAnim
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewIsPlayingRootMotionAnim                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetIsPlayingRootMotionAnim(bool NewIsPlayingRootMotionAnim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetIsPlayingRootMotionAnim");

	Params::MassEnemyActor_SetIsPlayingRootMotionAnim Parms{};

	Parms.NewIsPlayingRootMotionAnim = NewIsPlayingRootMotionAnim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetIsTurnInPlaceActive
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewIsTurnInPlaceActive                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetIsTurnInPlaceActive(bool NewIsTurnInPlaceActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetIsTurnInPlaceActive");

	Params::MassEnemyActor_SetIsTurnInPlaceActive Parms{};

	Parms.NewIsTurnInPlaceActive = NewIsTurnInPlaceActive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetJumpLandAnimPlayRation
// (Native, Public, HasOutParams)
// Parameters:
// const float&                            Time                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetJumpLandAnimPlayRation(const float& Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetJumpLandAnimPlayRation");

	Params::MassEnemyActor_SetJumpLandAnimPlayRation Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetJumpLandVelocity
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FVector&                   LandVelocity                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetJumpLandVelocity(const struct FVector& LandVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetJumpLandVelocity");

	Params::MassEnemyActor_SetJumpLandVelocity Parms{};

	Parms.LandVelocity = std::move(LandVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetJumpLaunchVelocity
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// const struct FVector&                   LaunchVelocity                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetJumpLaunchVelocity(const struct FVector& LaunchVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetJumpLaunchVelocity");

	Params::MassEnemyActor_SetJumpLaunchVelocity Parms{};

	Parms.LaunchVelocity = std::move(LaunchVelocity);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetJumpState
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECrEnemyJumpState                       NewJumpState                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetJumpState(ECrEnemyJumpState NewJumpState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetJumpState");

	Params::MassEnemyActor_SetJumpState Parms{};

	Parms.NewJumpState = NewJumpState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetJumpTime
// (Native, Public, HasOutParams)
// Parameters:
// const float&                            Time                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetJumpTime(const float& Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetJumpTime");

	Params::MassEnemyActor_SetJumpTime Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetLocomotionType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECrEnemyLocomotionType                  NewLocomotionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyLocomotionType                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECrEnemyLocomotionType IMassEnemyActor::SetLocomotionType(ECrEnemyLocomotionType NewLocomotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetLocomotionType");

	Params::MassEnemyActor_SetLocomotionType Parms{};

	Parms.NewLocomotionType = NewLocomotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetMassEnemyInitializationState
// (Native, Public)
// Parameters:
// EMassEnemyInitializationState           InitializationState                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetMassEnemyInitializationState(EMassEnemyInitializationState InitializationState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetMassEnemyInitializationState");

	Params::MassEnemyActor_SetMassEnemyInitializationState Parms{};

	Parms.InitializationState = InitializationState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetMassSpawnerFenceData
// (Native, Public, HasOutParams, HasDefaults)
// Parameters:
// ECrSpawnFenceType                       FenceType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FBox&                      FenceBox                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetMassSpawnerFenceData(ECrSpawnFenceType FenceType, const struct FBox& FenceBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetMassSpawnerFenceData");

	Params::MassEnemyActor_SetMassSpawnerFenceData Parms{};

	Parms.FenceType = FenceType;
	Parms.FenceBox = std::move(FenceBox);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetMaxSpeed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewMaxSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateAnimGraphMaxSpeed                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IMassEnemyActor::SetMaxSpeed(float NewMaxSpeed, bool bUpdateAnimGraphMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetMaxSpeed");

	Params::MassEnemyActor_SetMaxSpeed Parms{};

	Parms.NewMaxSpeed = NewMaxSpeed;
	Parms.bUpdateAnimGraphMaxSpeed = bUpdateAnimGraphMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetOrientRotationToMovement
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    NewOrientRotationToMovement                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetOrientRotationToMovement(bool NewOrientRotationToMovement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetOrientRotationToMovement");

	Params::MassEnemyActor_SetOrientRotationToMovement Parms{};

	Parms.NewOrientRotationToMovement = NewOrientRotationToMovement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetSpawnType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECrEnemySpawnType                       SpawnType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetSpawnType(ECrEnemySpawnType SpawnType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetSpawnType");

	Params::MassEnemyActor_SetSpawnType Parms{};

	Parms.SpawnType = SpawnType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetTauntType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ECrEnemyTauntType                       TauntType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetTauntType(ECrEnemyTauntType TauntType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetTauntType");

	Params::MassEnemyActor_SetTauntType Parms{};

	Parms.TauntType = TauntType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetTriggerSpawnAnim
// (Native, Public)

void IMassEnemyActor::SetTriggerSpawnAnim()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetTriggerSpawnAnim");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.SetYawRotationRate
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewYawRotationRate                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyActor::SetYawRotationRate(float NewYawRotationRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "SetYawRotationRate");

	Params::MassEnemyActor_SetYawRotationRate Parms{};

	Parms.NewYawRotationRate = NewYawRotationRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyActor.GetIdleEyeColor
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor IMassEnemyActor::GetIdleEyeColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyActor", "GetIdleEyeColor");

	Params::MassEnemyActor_GetIdleEyeColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAiController.GetNavAgentQueryExtent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AMassEnemyAiController::GetNavAgentQueryExtent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAiController", "GetNavAgentQueryExtent");

	Params::MassEnemyAiController_GetNavAgentQueryExtent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.BPOnAttackTypeChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ECrEnemyAttackType                      OldAttackType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyAttackType                      NewAttackType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMassEnemyAnimationInstance::BPOnAttackTypeChanged(ECrEnemyAttackType OldAttackType, ECrEnemyAttackType NewAttackType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "BPOnAttackTypeChanged");

	Params::MassEnemyAnimationInstance_BPOnAttackTypeChanged Parms{};

	Parms.OldAttackType = OldAttackType;
	Parms.NewAttackType = NewAttackType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.BPOnDamageReceived
// (Native, Event, Public, BlueprintEvent)

void UMassEnemyAnimationInstance::BPOnDamageReceived()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "BPOnDamageReceived");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.BPOnLocomotionTypeChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ECrEnemyLocomotionType                  OldLocomotionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrEnemyLocomotionType                  NewLocomotionType                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMassEnemyAnimationInstance::BPOnLocomotionTypeChanged(ECrEnemyLocomotionType OldLocomotionType, ECrEnemyLocomotionType NewLocomotionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "BPOnLocomotionTypeChanged");

	Params::MassEnemyAnimationInstance_BPOnLocomotionTypeChanged Parms{};

	Parms.OldLocomotionType = OldLocomotionType;
	Parms.NewLocomotionType = NewLocomotionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.GetAnimationSyncData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FMassEnemyAnimationSyncDataReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FMassEnemyAnimationSyncData UMassEnemyAnimationInstance::GetAnimationSyncData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "GetAnimationSyncData");

	Params::MassEnemyAnimationInstance_GetAnimationSyncData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.InitWithAnimSyncData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMassEnemyAnimationSyncData&NewMassEnemyAnimationSyncData                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMassEnemyAnimationInstance::InitWithAnimSyncData(const struct FMassEnemyAnimationSyncData& NewMassEnemyAnimationSyncData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "InitWithAnimSyncData");

	Params::MassEnemyAnimationInstance_InitWithAnimSyncData Parms{};

	Parms.NewMassEnemyAnimationSyncData = std::move(NewMassEnemyAnimationSyncData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.NotifyAnimationFinished
// (Final, Native, Public, BlueprintCallable)

void UMassEnemyAnimationInstance::NotifyAnimationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "NotifyAnimationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.NotifyAttackAnimationFinishedAnimEvent
// (Final, Native, Protected, BlueprintCallable)

void UMassEnemyAnimationInstance::NotifyAttackAnimationFinishedAnimEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "NotifyAttackAnimationFinishedAnimEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.NotifyDealDamageAnimationEvent
// (Final, Native, Protected, BlueprintCallable)

void UMassEnemyAnimationInstance::NotifyDealDamageAnimationEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "NotifyDealDamageAnimationEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.NotifyJumpedAnimationEvent
// (Final, Native, Protected, BlueprintCallable)

void UMassEnemyAnimationInstance::NotifyJumpedAnimationEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "NotifyJumpedAnimationEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.NotifyLandedAnimationEvent
// (Final, Native, Protected, BlueprintCallable)

void UMassEnemyAnimationInstance::NotifyLandedAnimationEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "NotifyLandedAnimationEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.OnJumpTimeSet
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMassEnemyAnimationInstance::OnJumpTimeSet(float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "OnJumpTimeSet");

	Params::MassEnemyAnimationInstance_OnJumpTimeSet Parms{};

	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.OnOwnerHit
// (Native, Event, Public, BlueprintEvent)

void UMassEnemyAnimationInstance::OnOwnerHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "OnOwnerHit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.ResetVertexAnimSyncData
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UMassEnemyAnimationInstance::ResetVertexAnimSyncData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "ResetVertexAnimSyncData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAnimationInstance.SetVertexAnimationState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMassEnemyVertexAnimState               VertexAnimState                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMassEnemyAnimationInstance::SetVertexAnimationState(EMassEnemyVertexAnimState VertexAnimState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAnimationInstance", "SetVertexAnimationState");

	Params::MassEnemyAnimationInstance_SetVertexAnimationState Parms{};

	Parms.VertexAnimState = VertexAnimState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAttackGateSubsystem.TryRequestAttackSlot
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FMassEntityHandle*               EntityToAttack                                         (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxAttackers                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int64                                   AttackSlotCooldownS                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMassEnemyAttackGateSubsystem::TryRequestAttackSlot(struct FMassEntityHandle* EntityToAttack, int32 MaxAttackers, int64 AttackSlotCooldownS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAttackGateSubsystem", "TryRequestAttackSlot");

	Params::MassEnemyAttackGateSubsystem_TryRequestAttackSlot Parms{};

	Parms.MaxAttackers = MaxAttackers;
	Parms.AttackSlotCooldownS = AttackSlotCooldownS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (EntityToAttack != nullptr)
		*EntityToAttack = std::move(Parms.EntityToAttack);

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyAttackGateSubsystem.GetSecondsToNextAttackTimeWindow
// (Final, Native, Public, Const)
// Parameters:
// class UWorld*                           World                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMassEnemyAttackGateSubsystem::GetSecondsToNextAttackTimeWindow(class UWorld* World) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyAttackGateSubsystem", "GetSecondsToNextAttackTimeWindow");

	Params::MassEnemyAttackGateSubsystem_GetSecondsToNextAttackTimeWindow Parms{};

	Parms.World = World;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.BanCurrentTarget
// (Native, Public, BlueprintCallable)

void AMassEnemyCharacterBase::BanCurrentTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "BanCurrentTarget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.Multicast_OnAiDied
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              KillingDamageTag                                       (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::Multicast_OnAiDied(const struct FHitResult& HitResult, const struct FGameplayTag& KillingDamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "Multicast_OnAiDied");

	Params::MassEnemyCharacterBase_Multicast_OnAiDied Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.KillingDamageTag = std::move(KillingDamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.Multicast_StartDeathSequence
// (Net, NetReliable, Native, Event, NetMulticast, Public, BlueprintCallable)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              KillingDamageTag                                       (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::Multicast_StartDeathSequence(const struct FHitResult& HitResult, const struct FGameplayTag& KillingDamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "Multicast_StartDeathSequence");

	Params::MassEnemyCharacterBase_Multicast_StartDeathSequence Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.KillingDamageTag = std::move(KillingDamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.NotifyAggroTargetChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    bHasAggroTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::NotifyAggroTargetChanged(bool bHasAggroTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "NotifyAggroTargetChanged");

	Params::MassEnemyCharacterBase_NotifyAggroTargetChanged Parms{};

	Parms.bHasAggroTarget = bHasAggroTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.NotifyNearbyPlayerCharactersAboutSpawn
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMassEnemyCharacterBase::NotifyNearbyPlayerCharactersAboutSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "NotifyNearbyPlayerCharactersAboutSpawn");

	Params::MassEnemyCharacterBase_NotifyNearbyPlayerCharactersAboutSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnAggroTargetChange
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bHasAggroTarget                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::OnAggroTargetChange(bool bHasAggroTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnAggroTargetChange");

	Params::MassEnemyCharacterBase_OnAggroTargetChange Parms{};

	Parms.bHasAggroTarget = bHasAggroTarget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnAiDied
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              KillingDamageTag                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::OnAiDied(const struct FHitResult& HitResult, const struct FGameplayTag& KillingDamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnAiDied");

	Params::MassEnemyCharacterBase_OnAiDied Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.KillingDamageTag = std::move(KillingDamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnBlackboardConfigured
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class UMassEnemyDataAsset*              Config                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::OnBlackboardConfigured(class UMassEnemyDataAsset* Config)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnBlackboardConfigured");

	Params::MassEnemyCharacterBase_OnBlackboardConfigured Parms{};

	Parms.Config = Config;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnDamage
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   InDamage                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::OnDamage(class AActor* Actor, const struct FHitResult& HitResult, float InDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnDamage");

	Params::MassEnemyCharacterBase_OnDamage Parms{};

	Parms.Actor = Actor;
	Parms.HitResult = std::move(HitResult);
	Parms.InDamage = InDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnDiedFromGas
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                LastHit                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              KillingDamageTag                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::OnDiedFromGas(const struct FHitResult& LastHit, const struct FGameplayTag& KillingDamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnDiedFromGas");

	Params::MassEnemyCharacterBase_OnDiedFromGas Parms{};

	Parms.LastHit = std::move(LastHit);
	Parms.KillingDamageTag = std::move(KillingDamageTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnDiedWithoutEntity
// (Final, Native, Public)

void AMassEnemyCharacterBase::OnDiedWithoutEntity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnDiedWithoutEntity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnDissolveValueSet
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// float                                   NewDissolveProgress                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::OnDissolveValueSet(float NewDissolveProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnDissolveValueSet");

	Params::MassEnemyCharacterBase_OnDissolveValueSet Parms{};

	Parms.NewDissolveProgress = NewDissolveProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnRep_Dissolve
// (Final, Native, Protected)

void AMassEnemyCharacterBase::OnRep_Dissolve()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnRep_Dissolve");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnRep_VisualVariation
// (Final, Native, Protected)

void AMassEnemyCharacterBase::OnRep_VisualVariation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnRep_VisualVariation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnStartDeathSequence
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                HitResult                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              KillingDamageTag                                       (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::OnStartDeathSequence(const struct FHitResult& HitResult, const struct FGameplayTag& KillingDamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnStartDeathSequence");

	Params::MassEnemyCharacterBase_OnStartDeathSequence Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.KillingDamageTag = std::move(KillingDamageTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnVisualVariationChanged
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   NewVisualVariationSeed                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::OnVisualVariationChanged(const struct FVector& NewVisualVariationSeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnVisualVariationChanged");

	Params::MassEnemyCharacterBase_OnVisualVariationChanged Parms{};

	Parms.NewVisualVariationSeed = std::move(NewVisualVariationSeed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.ServerOnLanded_Multicast
// (Net, NetReliable, Native, Event, NetMulticast, Protected)

void AMassEnemyCharacterBase::ServerOnLanded_Multicast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "ServerOnLanded_Multicast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.SetDynamicMaterial
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   MeshMaterialIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInterface*               NewMaterial                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AMassEnemyCharacterBase::SetDynamicMaterial(int32 MeshMaterialIndex, class UMaterialInterface* NewMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "SetDynamicMaterial");

	Params::MassEnemyCharacterBase_SetDynamicMaterial Parms{};

	Parms.MeshMaterialIndex = MeshMaterialIndex;
	Parms.NewMaterial = NewMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.SetMaterialParameterFloatValue
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   MeshMaterialIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName&                      ParameterName                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMassEnemyCharacterBase::SetMaterialParameterFloatValue(int32 MeshMaterialIndex, const class FName& ParameterName, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "SetMaterialParameterFloatValue");

	Params::MassEnemyCharacterBase_SetMaterialParameterFloatValue Parms{};

	Parms.MeshMaterialIndex = MeshMaterialIndex;
	Parms.ParameterName = ParameterName;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.DealDamageToCurrentAggroTarget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMassEnemyCharacterBase::DealDamageToCurrentAggroTarget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "DealDamageToCurrentAggroTarget");

	Params::MassEnemyCharacterBase_DealDamageToCurrentAggroTarget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.GetActiveFenceBox
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FBox AMassEnemyCharacterBase::GetActiveFenceBox() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "GetActiveFenceBox");

	Params::MassEnemyCharacterBase_GetActiveFenceBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.GetAiTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag AMassEnemyCharacterBase::GetAiTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "GetAiTag");

	Params::MassEnemyCharacterBase_GetAiTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.GetDamageReceivedInTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Times                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AMassEnemyCharacterBase::GetDamageReceivedInTime(float Times) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "GetDamageReceivedInTime");

	Params::MassEnemyCharacterBase_GetDamageReceivedInTime Parms{};

	Parms.Times = Times;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.GetTargetEntity
// (Final, Native, Public, Const)
// Parameters:
// struct FMassEntityHandle                ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FMassEntityHandle AMassEnemyCharacterBase::GetTargetEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "GetTargetEntity");

	Params::MassEnemyCharacterBase_GetTargetEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.HasAttackSlotForActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECrAttackSlotType                       AttackSlotType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   RequestLifetime                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMassEnemyCharacterBase::HasAttackSlotForActor(class AActor* Target, ECrAttackSlotType AttackSlotType, float RequestLifetime) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "HasAttackSlotForActor");

	Params::MassEnemyCharacterBase_HasAttackSlotForActor Parms{};

	Parms.Target = Target;
	Parms.AttackSlotType = AttackSlotType;
	Parms.RequestLifetime = RequestLifetime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.IsAnyDamageRegisteredInTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Times                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMassEnemyCharacterBase::IsAnyDamageRegisteredInTime(float Times) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "IsAnyDamageRegisteredInTime");

	Params::MassEnemyCharacterBase_IsAnyDamageRegisteredInTime Parms{};

	Parms.Times = Times;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.IsInActiveFence
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AMassEnemyCharacterBase::IsInActiveFence() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "IsInActiveFence");

	Params::MassEnemyCharacterBase_IsInActiveFence Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyCharacterBase.OnRep_SpawnType
// (Final, Native, Protected, Const)

void AMassEnemyCharacterBase::OnRep_SpawnType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyCharacterBase", "OnRep_SpawnType");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.SetAllowedAttackConeHalfAngle
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewAttackConeHalfAngle                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyDamageInterface::SetAllowedAttackConeHalfAngle(float NewAttackConeHalfAngle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "SetAllowedAttackConeHalfAngle");

	Params::MassEnemyDamageInterface_SetAllowedAttackConeHalfAngle Parms{};

	Parms.NewAttackConeHalfAngle = NewAttackConeHalfAngle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.SetAllowedAttackDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewAttackDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyDamageInterface::SetAllowedAttackDistance(float NewAttackDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "SetAllowedAttackDistance");

	Params::MassEnemyDamageInterface_SetAllowedAttackDistance Parms{};

	Parms.NewAttackDistance = NewAttackDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.SetAllowedBuildingAttackDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewAttackDistance                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyDamageInterface::SetAllowedBuildingAttackDistance(float NewAttackDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "SetAllowedBuildingAttackDistance");

	Params::MassEnemyDamageInterface_SetAllowedBuildingAttackDistance Parms{};

	Parms.NewAttackDistance = NewAttackDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.SetAttackTargetPosition
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   NewAttackTargetPosition                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyDamageInterface::SetAttackTargetPosition(const struct FVector& NewAttackTargetPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "SetAttackTargetPosition");

	Params::MassEnemyDamageInterface_SetAttackTargetPosition Parms{};

	Parms.NewAttackTargetPosition = std::move(NewAttackTargetPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.SetBuildingInfectionDamage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   NewBuildingInfectionDamage                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyDamageInterface::SetBuildingInfectionDamage(float NewBuildingInfectionDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "SetBuildingInfectionDamage");

	Params::MassEnemyDamageInterface_SetBuildingInfectionDamage Parms{};

	Parms.NewBuildingInfectionDamage = NewBuildingInfectionDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.SetDamageGameplayEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSubclassOf<class UGameplayEffect>      DamageEffect                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMassEnemyDamageInterface::SetDamageGameplayEffect(TSubclassOf<class UGameplayEffect> DamageEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "SetDamageGameplayEffect");

	Params::MassEnemyDamageInterface_SetDamageGameplayEffect Parms{};

	Parms.DamageEffect = DamageEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.GetAggroTargetActor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* IMassEnemyDamageInterface::GetAggroTargetActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "GetAggroTargetActor");

	Params::MassEnemyDamageInterface_GetAggroTargetActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.GetAllowedAttackConeHalfAngle
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IMassEnemyDamageInterface::GetAllowedAttackConeHalfAngle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "GetAllowedAttackConeHalfAngle");

	Params::MassEnemyDamageInterface_GetAllowedAttackConeHalfAngle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.GetAllowedAttackDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IMassEnemyDamageInterface::GetAllowedAttackDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "GetAllowedAttackDistance");

	Params::MassEnemyDamageInterface_GetAllowedAttackDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.GetAllowedBuildingAttackDistance
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IMassEnemyDamageInterface::GetAllowedBuildingAttackDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "GetAllowedBuildingAttackDistance");

	Params::MassEnemyDamageInterface_GetAllowedBuildingAttackDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.GetAttackTargetPosition
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector IMassEnemyDamageInterface::GetAttackTargetPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "GetAttackTargetPosition");

	Params::MassEnemyDamageInterface_GetAttackTargetPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.GetBuildingInfectionDamage
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IMassEnemyDamageInterface::GetBuildingInfectionDamage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "GetBuildingInfectionDamage");

	Params::MassEnemyDamageInterface_GetBuildingInfectionDamage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyDamageInterface.GetDamageGameplayEffect
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UGameplayEffect>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayEffect> IMassEnemyDamageInterface::GetDamageGameplayEffect() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("MassEnemyDamageInterface", "GetDamageGameplayEffect");

	Params::MassEnemyDamageInterface_GetDamageGameplayEffect Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemyEntityHismWrapperSubsystem.GetEntityHismWrapperActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AMassEnemyEntityHismWrapperActor* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AMassEnemyEntityHismWrapperActor* UMassEnemyEntityHismWrapperSubsystem::GetEntityHismWrapperActor(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemyEntityHismWrapperSubsystem", "GetEntityHismWrapperActor");

	Params::MassEnemyEntityHismWrapperSubsystem_GetEntityHismWrapperActor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemySpawnerTriggerBox.OnBoxBeginOverlap
// (Final, Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UMassEnemySpawnerTriggerBox::OnBoxBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemySpawnerTriggerBox", "OnBoxBeginOverlap");

	Params::MassEnemySpawnerTriggerBox_OnBoxBeginOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemySpawnerTriggerBox.OnBoxEndOverlap
// (Final, Native, Public)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMassEnemySpawnerTriggerBox::OnBoxEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemySpawnerTriggerBox", "OnBoxEndOverlap");

	Params::MassEnemySpawnerTriggerBox_OnBoxEndOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemySpawnSubsystem.ClearDebugSpawnPreset
// (Final, Native, Public, BlueprintCallable)

void UMassEnemySpawnSubsystem::ClearDebugSpawnPreset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemySpawnSubsystem", "ClearDebugSpawnPreset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.MassEnemySpawnSubsystem.OnPreSaveStart
// (Final, Native, Private)

void UMassEnemySpawnSubsystem::OnPreSaveStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MassEnemySpawnSubsystem", "OnPreSaveStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.NavLinkGeneratorBox.QueuePcgGeneration
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FIntPoint&                 Request                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANavLinkGeneratorBox::QueuePcgGeneration(const struct FIntPoint& Request)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkGeneratorBox", "QueuePcgGeneration");

	Params::NavLinkGeneratorBox_QueuePcgGeneration Parms{};

	Parms.Request = std::move(Request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.NavLinkGeneratorBox.StartPcgGeneration
// (Final, Native, Public, BlueprintCallable)

void ANavLinkGeneratorBox::StartPcgGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkGeneratorBox", "StartPcgGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function MassAIPrototypeEnemyRuntime.NavLinkGeneratorBox.IsGenerating
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ANavLinkGeneratorBox::IsGenerating() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NavLinkGeneratorBox", "IsGenerating");

	Params::NavLinkGeneratorBox_IsGenerating Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

