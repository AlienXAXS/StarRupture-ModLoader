#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: ContextualDialog

#include "Basic.hpp"

#include "ContextualDialog_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class ContextualDialog.ContextualDialogInterface
// 0x0000 (0x0000 - 0x0000)
class IContextualDialogInterface final
{
public:
	bool CanExecuteAnyContextualResponse(bool bIsImportant);
	bool ExecuteContextualResponse(const struct FContextualResponsePayload& ResponseData, class FName RuleNameContainingResponseData);
	bool IsCharacterTalking();
	bool OnResponseFinished(const struct FContextualResponsePayload& ResponseData, class FName RuleNameContainingResponseData);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ContextualDialogInterface")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ContextualDialogInterface")
	}
	static class IContextualDialogInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContextualDialogInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
DUMPER7_ASSERTS_IContextualDialogInterface;

// Class ContextualDialog.ContextualDialogLibrary
// 0x0000 (0x0028 - 0x0028)
class UContextualDialogLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AddPropertyValue(class UObject* Target, class FName PropertyName, float NumberPropertyValue, class FName NamePropertyValue, bool BoolPropertyValue, uint8 PropertyType);
	static bool ExecuteContextualEvent(class AActor* Target, const class FString& ContextName, const class FString& ContextValue, class AActor* TargetActor, int32 IncreaseCounter, bool bSkipDialoguesRulesCheck);
	static TSet<class FName> GetAllContextsNames(class UDataTable* ObjectsDefinitions);
	static TSet<class FName> GetAllDefinedObjectsGroups(class UDataTable* ObjectsDefinitions);
	static TSet<class FName> GetAllDefinedObjectsNames(class UDataTable* ObjectsDefinitions);
	static TArray<class FName> GetAllDynamicPropertiesNames(class UDataTable* RulesDataTable);
	static TSet<class FName> GetAllObjectsNamesInAGroup(class UDataTable* ObjectsDefinitions, class FName GroupName);
	static TArray<class FName> GetAllPropertiesNames(class UDataTable* PropertiesDefinition);
	static TSet<class FName> GetAllPropertiesNamesSet(class UDataTable* PropertiesDefinition);
	static TMap<class FName, class FText> GetAllPropertiesWithDescriptionsMap(class UDataTable* PropertiesDefinition);
	static TArray<class FName> GetAllResponsesNames(class UDataTable* RulesDataTable);
	static TArray<class FName> GetAllRulesNames(class UDataTable* RulesDataTable);
	static struct FCondition GetConditionFromString(const class FString& ConditionPhrase);
	static TArray<struct FCondition> GetConditionsFromJson(const class FString& Expression, TArray<class FString>* OriginalPhrases);
	static class UPropertiesHolderComponent* GetContextualPropertiesHolderComponent(class UObject* Target);
	static class UContextualQueryObject* GetContextualQueryObject(class AActor* Target);
	static struct FPropertyDefinition GetPropertyDefinitionForPropertyName(class FName PropertyName, class UDataTable* PropertiesDefinition);
	static class FText GetPropertyDescription(class FName PropertyName, class UDataTable* PropertiesDefinition);
	static struct FPropertyModification GetPropertyModificationFromString(const class FString& PropertyName, const class FString& Expression);
	static bool IsPropertyNameBoolType(const class FString& PropertyName, bool* IsInvertedBool, class FString* NotInvertedBoolName);
	static void LogAllProperties(class UObject* Target);
	static bool RemoveProperty(class UObject* Target, const class FString& PropertyName, float* OutValueBeforeRemoving);
	static bool SetNumberPropertyValueForActors(const TArray<class AActor*>& Targets, class FName PropertyName, float NewPropertyValue);

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ContextualDialogLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ContextualDialogLibrary")
	}
	static class UContextualDialogLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualDialogLibrary>();
	}
};
DUMPER7_ASSERTS_UContextualDialogLibrary;

// Class ContextualDialog.ContextualDialogSettings
// 0x0020 (0x0048 - 0x0028)
class UContextualDialogSettings final : public UObject
{
public:
	TArray<class FString>                         PrefixesForBoolTypeDetection;                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<class FName>                           ObjectGroupNames;                                  // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ContextualDialogSettings")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ContextualDialogSettings")
	}
	static class UContextualDialogSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualDialogSettings>();
	}
};
DUMPER7_ASSERTS_UContextualDialogSettings;

// Class ContextualDialog.ContextualDialogSubsystem
// 0x0308 (0x0348 - 0x0040)
class UContextualDialogSubsystem final : public UTickableWorldSubsystem
{
public:
	TMulticastInlineDelegate<void(const class FText& Text)> ShowSubtitleTextDel;                     // 0x0040(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UContextualRuleObject*>          LoadedRules;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected, TObjectPtr)
	TArray<class UContextualRuleObject*>          LoadedRulesOnReplyContext;                         // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected, TObjectPtr)
	TArray<class UContextualRuleObject*>          LoadedRulesNoContext;                              // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected, TObjectPtr)
	TArray<class UContextualRuleObject*>          LoadedRulesWithContextNotOnReply;                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected, TObjectPtr)
	TMap<class AActor*, class UContextualQueryObject*> QueryObjectsForActors;                        // 0x00A0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected, TObjectPtr)
	class UPropertiesHolderComponent*             WorldDataProperties;                               // 0x00F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected, TObjectPtr)
	TSet<class FName>                             UsedRules;                                         // 0x00F8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, float>                      GlobalCooldownsTimeLeftForResponsesMap;            // 0x0148(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TMap<class AActor*, struct FRuleResponseLocalCooldownData> LocalCooldownsDataForActors;          // 0x0198(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E8[0xA0];                                     // 0x01E8(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentItemLookingAtName;                          // 0x0288(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      LookingDuration;                                   // 0x0290(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIgnoreContextualDialogExecutions;                 // 0x02E0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugContextualDialogEvents;                      // 0x02E1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugRulesInitialization;                         // 0x02E2(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugRulesCriterionsChecks;                       // 0x02E3(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class UContextualQueryObject* QueryObject)> OnMatchingRuleToQuery; // 0x02E8(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FQueuedResponseData>            ResponsesQueue;                                    // 0x0300(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMulticastInlineDelegate<void(class AActor* TargetActor, const struct FContextualResponsePayload& ResponseData, class FName RuleRowName)> OnMatchingRuleFoundAndExecutedByActorDel; // 0x0318(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class AActor* Target, class FName ContextName, class FName ContextValue, class AActor* TargetActor)> OnContextualEventExecutedDel; // 0x0330(0x0018)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AddObjectLookingDurationDelta(class FName ObjectName, float DeltaSeconds);
	void AsyncLoadDialogueWave(class AActor* ActorRequestingLoad, TSoftObjectPtr<class UDialogueWave> SoftDialogueWave, const TDelegate<void(class UDialogueWave* DialogueWaveLoaded)>& OnLoadDelegate);
	bool ClearCooldownsData();
	class UContextualRuleObject* ConstructContextualRuleObject(class FName InRuleName, const struct FRuleData& RuleData);
	void DebugLogAllRulesCountForEachContextType();
	bool ExecuteQueuedResponse(class AActor* TargetActor);
	bool ExecuteRuleResponseForTargetActor(class AActor* TargetActor, class UContextualRuleObject* RuleObject);
	class UContextualRuleObject* FindMatchingRuleForQuery(class UContextualQueryObject* QueryObject, bool* RuleFound);
	TArray<class AActor*> GetActorsWithContextualDialogInterface();
	class UContextualQueryObject* GetContextualQueryObjectForActor(class AActor* Actor);
	float GetObjectLookingDuration(class FName ObjectName);
	TArray<class APawn*> GetPawnsWithContextualDialogInterface();
	bool IsResponseQueued(class AActor* TargetActor, class FName ResponseName);
	bool IsRuleAvailable(class UContextualRuleObject* RuleObject, class AActor* TargetActor);
	bool LoadRulesFromDataTable(class UDataTable* DataTable);
	bool LoadRulesFromDataTables(const TArray<class UDataTable*>& DataTables);
	void LogGlobalCooldowns();
	void LogLocalCooldowns();
	void OnDialogueWaveAsyncLoadComplete();

	float GetGlobalDynamicPropertyValueByName(class FName PropertyName) const;
	float GetLocalDynamicPropertyValueByName(class AActor* Actor, class FName PropertyName) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ContextualDialogSubsystem")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ContextualDialogSubsystem")
	}
	static class UContextualDialogSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualDialogSubsystem>();
	}
};
DUMPER7_ASSERTS_UContextualDialogSubsystem;

// Class ContextualDialog.ContextualDialogTriggerBase
// 0x0000 (0x02B0 - 0x02B0)
class AContextualDialogTriggerBase final : public ATriggerBase
{
public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ContextualDialogTriggerBase")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ContextualDialogTriggerBase")
	}
	static class AContextualDialogTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AContextualDialogTriggerBase>();
	}
};
DUMPER7_ASSERTS_AContextualDialogTriggerBase;

// Class ContextualDialog.ContextualQueryObject
// 0x0020 (0x0048 - 0x0028)
class UContextualQueryObject final : public UObject
{
public:
	class UPropertiesHolderComponent*             OwningPropertiesHolderComponent;                   // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic, TObjectPtr)
	TArray<class UPropertiesHolderComponent*>     PropertiesHolderComponents;                        // 0x0030(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate, TObjectPtr)
	class UPropertiesHolderComponent*             ContextualEventTargetPropertiesHolder;             // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate, TObjectPtr)

public:
	class AActor* GetOwningActor();

	bool ContainsProperty(class FName PropertyName) const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ContextualQueryObject")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ContextualQueryObject")
	}
	static class UContextualQueryObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualQueryObject>();
	}
};
DUMPER7_ASSERTS_UContextualQueryObject;

// Class ContextualDialog.ContextualResponse
// 0x0008 (0x0030 - 0x0028)
class UContextualResponse final : public UObject
{
public:
	bool                                          ResponseVariable;                                  // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ExecuteResponse();
	bool OnResponseFinished();
	bool OnResponseStarted();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ContextualResponse")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ContextualResponse")
	}
	static class UContextualResponse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualResponse>();
	}
};
DUMPER7_ASSERTS_UContextualResponse;

// Class ContextualDialog.ContextualRuleObject
// 0x00A0 (0x00C8 - 0x0028)
class UContextualRuleObject final : public UObject
{
public:
	TMap<class FString, struct FCondition>        ConditionsMap;                                     // 0x0028(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FContextualResponseForRule             ResponseData;                                      // 0x0078(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CurrentResponseIndex;                              // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x2C];                                      // 0x009C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoesQueryPassThisRule(class UContextualQueryObject* Query);
	TArray<class FName> GetAllResponsesNames();
	int32 GetCurrentResponseDataAndIndex(struct FContextualResponsePayload* CurrentResponsePlayload, const TArray<class FName>& CurrentlyFrozenResponses);
	float GetRulePriority();

	class FName GetRuleName() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ContextualRuleObject")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ContextualRuleObject")
	}
	static class UContextualRuleObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualRuleObject>();
	}
};
DUMPER7_ASSERTS_UContextualRuleObject;

// Class ContextualDialog.ProjectSpecificFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UProjectSpecificFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TSet<class FName> GetProjectSpecificGroupNames();
	static TSet<class FName> GetProjectSpecificObjectNames();
	static TSet<class FName> GetProjectSpecificObjectNamesForAGroup(class FName GroupName);
	static TSet<class FName> GetProjectSpecificPropertiesNames();

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("ProjectSpecificFunctionLibrary")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"ProjectSpecificFunctionLibrary")
	}
	static class UProjectSpecificFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectSpecificFunctionLibrary>();
	}
};
DUMPER7_ASSERTS_UProjectSpecificFunctionLibrary;

// Class ContextualDialog.PropertiesHolderComponent
// 0x00B8 (0x0170 - 0x00B8)
class UPropertiesHolderComponent final : public UActorComponent
{
public:
	TMap<class FName, float>                      NumberPropertiesMap;                               // 0x00B8(0x0050)(Protected, NativeAccessSpecifierProtected)
	TMap<class FName, class FName>                NamePropertiesMap;                                 // 0x0108(0x0050)(Protected, NativeAccessSpecifierProtected)
	TArray<struct FContextualEventCounter>        ExecutedContextualEventsData;                      // 0x0158(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   OwnerName;                                         // 0x0168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool AddNameProperty(class FName PropertyName, class FName PropertyValue);
	bool AddNumberProperty(class FName PropertyName, float PropertyValue);
	bool ContainsProperty(class FName PropertyName);
	TMap<class FString, class FString> GetAllPropertiesWithValuesAsStrings();
	int32 GetContextualEventExecutionAmount(class FName ContextName);
	int32 GetContextualEventExecutionAmountForValue(class FName ContextName, class FName ContextValue);
	bool GetNamePropertyValue(class FName PropertyName, class FName* PropertyValue);
	bool GetNumberPropertyValue(class FName PropertyName, float* PropertyValue);
	const class FName GetUniqueOwnerName();
	bool RemoveProperty(class FName PropertyName);
	void Server_ExecuteContextualEvent(class AActor* Target, const class FString& ContextName, const class FString& ContextValue, class AActor* TargetActor, int32 IncreaseCounter);
	void SetExecutedContextualEventsArray(const TArray<struct FContextualEventCounter>& NewEventsArray);

	TArray<struct FContextualEventCounter> GetAllExecutedContextualEventsArray() const;

public:
	static class UClass* StaticClass()
	{
		STATIC_CLASS_IMPL("PropertiesHolderComponent")
	}
	static const class FName& StaticName()
	{
		STATIC_NAME_IMPL(L"PropertiesHolderComponent")
	}
	static class UPropertiesHolderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPropertiesHolderComponent>();
	}
};
DUMPER7_ASSERTS_UPropertiesHolderComponent;

}

