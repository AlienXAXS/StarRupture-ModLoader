#pragma once

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <cstdio>
#include <cstdarg>
#include <cstdint>
#include <ctime>
#include <io.h>
#include <fcntl.h>
#include <string>
#include "ue_log.h"

// ---------------------------------------------------------------------------
// Logger — writes to configurable log file next to the game exe.
//
// Levels:  TRACE < DEBUG < INFO < WARN < ERROR
// All output includes: [HH:MM:SS.mmm] [LEVEL] [ThreadID] message
//
// Settings can be configured via version-mod.ini in the [Logging] section:
//   Level=DEBUG  ; Minimum log level (TRACE, DEBUG, INFO, WARN, ERROR)
//   EnableFile=1      ; Enable file logging
//   FileName=version-mod.log ; Log file name
//
// Console window (DEBUG builds only) is enabled when -Log parameter is passed.
// All output is also sent to OutputDebugStringA for debugger capture.
//
// Thread Safety: All logging operations are protected by a critical section.
// ---------------------------------------------------------------------------

namespace Log
{
	// Log level enum — anything below the active level is suppressed
	enum class Level : int
	{
		Trace = 0,
		Debug = 1,
		Info = 2,
		Warn = 3,
		Error = 4,
	};

	inline FILE*  g_file     = nullptr;
	inline Level  g_minLevel = Level::Info; // Default to Info for production
	inline bool   g_enableFile = true;       // Default to enabled
	inline std::wstring g_logFileName = L"version-mod.log"; // Default log file name
	
	// Critical section with explicit initialization flag and init-once semantics
	inline CRITICAL_SECTION g_logLock{};
	inline volatile LONG g_logLockInitialized = 0;  // Use volatile LONG for thread-safe flag

	// -----------------------------------------------------------------------
	// Check if -Log parameter was passed on command line
	// -----------------------------------------------------------------------
	inline bool HasLogCommandLineParam()
	{
		__try
		{
			const wchar_t* cmdLine = GetCommandLineW();
			if (!cmdLine)
				return false;
			return wcsstr(cmdLine, L"-Log") != nullptr || wcsstr(cmdLine, L"-log") != nullptr;
		}
		__except (EXCEPTION_EXECUTE_HANDLER)
		{
			// If command line is not accessible, assume no -Log parameter
			return false;
		}
	}

	// -----------------------------------------------------------------------
	// Parse log level from string
	// -----------------------------------------------------------------------
	inline Level ParseLevel(const std::wstring& levelStr)
	{
		if (levelStr == L"TRACE") return Level::Trace;
		if (levelStr == L"DEBUG") return Level::Debug;
		if (levelStr == L"INFO")  return Level::Info;
		if (levelStr == L"WARN")  return Level::Warn;
		if (levelStr == L"ERROR") return Level::Error;
		return Level::Debug; // Default
	}

	// -----------------------------------------------------------------------
	// Load configuration from INI file
	// -----------------------------------------------------------------------
	inline void LoadConfig()
	{
		// Build the INI path next to the game exe
		wchar_t iniPath[MAX_PATH]{};
		GetModuleFileNameW(nullptr, iniPath, MAX_PATH);

		wchar_t* lastSlash = wcsrchr(iniPath, L'\\');
		if (lastSlash)
			wcscpy_s(lastSlash + 1,
				static_cast<rsize_t>(MAX_PATH - (lastSlash + 1 - iniPath)),
				L"version-mod.ini");

		// Check if INI file exists
		DWORD attribs = GetFileAttributesW(iniPath);
		if (attribs == INVALID_FILE_ATTRIBUTES)
		{
			// INI doesn't exist, create default one
			HANDLE hFile = CreateFileW(
				iniPath,
				GENERIC_WRITE,
				0,
				nullptr,
				CREATE_NEW,
				FILE_ATTRIBUTE_NORMAL,
				nullptr);

			if (hFile != INVALID_HANDLE_VALUE)
			{
				const char* defaultContent =
					"; version-mod configuration file\n"
					"; This file is automatically generated if it doesn't exist\n\n"
					"[Logging]\n"
					"; Log level: TRACE, DEBUG, INFO, WARN, ERROR\n"
					"; INFO is recommended for production, DEBUG for troubleshooting\n"
					"Level=INFO\n\n"
					"; Enable file logging\n"
					"EnableFile=1\n\n"
					"; Log file name (relative to game exe)\n"
					"FileName=version-mod.log\n\n";

				DWORD written = 0;
				WriteFile(hFile, defaultContent, static_cast<DWORD>(strlen(defaultContent)), &written, nullptr);
				CloseHandle(hFile);
			}
		}

		// Read configuration values
		wchar_t buffer[256]{};

		// Log level
		GetPrivateProfileStringW(L"Logging", L"Level", L"DEBUG", buffer, 256, iniPath);
		g_minLevel = ParseLevel(buffer);

		// File logging enable
		g_enableFile = GetPrivateProfileIntW(L"Logging", L"EnableFile", 1, iniPath) != 0;

		// Log file name
		GetPrivateProfileStringW(L"Logging", L"FileName", L"version-mod.log", buffer, 256, iniPath);
		g_logFileName = buffer;
	}

	// -----------------------------------------------------------------------
  // Lifecycle
	// -----------------------------------------------------------------------

	inline void Initialize()
	{
		// Initialize critical section FIRST, before anything else
		// Use InterlockedCompareExchange for thread-safe one-time initialization
		if (InterlockedCompareExchange(&g_logLockInitialized, 1, 0) == 0)
		{
			// We're the first thread to initialize
			InitializeCriticalSection(&g_logLock);
		}
		else
		{
			// Another thread is initializing or has initialized
			// Wait for initialization to complete
			while (InterlockedCompareExchange(&g_logLockInitialized, 2, 1) != 2)
			{
				Sleep(1);
			}
		}

		// Now safe to acquire lock
		EnterCriticalSection(&g_logLock);
		__try
		{
			if (g_file)
			{
				// Already initialized by another thread
				return;
			}

			// Load configuration first
			LoadConfig();

			// Build the log path next to the game exe
			if (g_enableFile)
			{
				wchar_t modulePath[MAX_PATH]{};
				GetModuleFileNameW(nullptr, modulePath, MAX_PATH);

				wchar_t* lastSlash = wcsrchr(modulePath, L'\\');
				if (lastSlash)
					wcscpy_s(lastSlash + 1,
						static_cast<rsize_t>(MAX_PATH - (lastSlash + 1 - modulePath)),
						g_logFileName.c_str());

				// Open with FILE_SHARE_READ so other processes (tail, Get-Content, etc.)
				   // can read the log while we're writing to it.
				HANDLE hFile = CreateFileW(
					modulePath,
					GENERIC_WRITE,
					FILE_SHARE_READ | FILE_SHARE_WRITE,
					nullptr,
					CREATE_ALWAYS,
					FILE_ATTRIBUTE_NORMAL,
					nullptr);

				if (hFile != INVALID_HANDLE_VALUE)
				{
					// Convert Win32 HANDLE -> C runtime fd -> FILE*
					int fd = _open_osfhandle(reinterpret_cast<intptr_t>(hFile), _O_WRONLY | _O_TEXT);
					if (fd != -1)
					{
						g_file = _fdopen(fd, "w");
						if (!g_file)
							_close(fd); // closes the underlying HANDLE too
					}
					else
					{
						CloseHandle(hFile);
					}
				}
			}

#ifdef _DEBUG
			if (HasLogCommandLineParam())
			{
				AllocConsole();
				SetConsoleTitleW(L"version-mod debug console");
				FILE* dummy = nullptr;
				freopen_s(&dummy, "CONOUT$", "w", stdout);
				freopen_s(&dummy, "CONOUT$", "w", stderr);
			}
#endif

			// Mark as fully initialized
			InterlockedExchange(&g_logLockInitialized, 2);
		}
		__finally
		{
			LeaveCriticalSection(&g_logLock);
		}
	}

	inline void Shutdown()
	{
		// Check if we're initialized before attempting shutdown
		if (InterlockedCompareExchange(&g_logLockInitialized, 0, 0) < 2)
		{
			// Not fully initialized, nothing to clean up
			return;
		}

		EnterCriticalSection(&g_logLock);
		__try
		{
			if (g_file)
			{
				fflush(g_file);
				fclose(g_file);
				g_file = nullptr;
			}

#ifdef _DEBUG
			// Free console if it was allocated via -Log parameter
			if (HasLogCommandLineParam())
			{
				FreeConsole();
			}
#endif
		}
		__finally
		{
			LeaveCriticalSection(&g_logLock);
		}

		// Clean up critical section
		DeleteCriticalSection(&g_logLock);
		InterlockedExchange(&g_logLockInitialized, 0);
	}

	// Change the minimum log level at runtime
	inline void SetLevel(Level level) { g_minLevel = level; }

	// -----------------------------------------------------------------------
	// Core write — NOT intended to be called directly
	// Thread-safe: All operations are protected by critical section
	// -----------------------------------------------------------------------

	inline void Write(Level level, const char* levelStr, const char* fmt, va_list args)
	{
		if (level < g_minLevel)
			return;

		// Ensure logging is initialized (with init-once semantics)
		// States: 0 = uninitialized, 1 = initializing, 2 = ready
		LONG state = InterlockedCompareExchange(&g_logLockInitialized, 0, 0);
		
		if (state == 0)
		{
			// Not initialized - try to initialize now
			// This handles the case where logging is called before explicit Initialize()
			Initialize();
			state = 2; // Should be ready now
		}
		else if (state == 1)
		{
			// Another thread is initializing - wait for it
			while (InterlockedCompareExchange(&g_logLockInitialized, 0, 0) != 2)
			{
				Sleep(1);
			}
		}

		// state should be 2 (ready) now, but check to be safe
		if (InterlockedCompareExchange(&g_logLockInitialized, 0, 0) != 2)
		{
			// Still not ready - abort to prevent crash
			return;
		}

		// Acquire lock for thread-safe logging
		EnterCriticalSection(&g_logLock);

		// Use __try/__finally to ensure lock is always released
		__try
		{
			// High-resolution timestamp: HH:MM:SS.mmm
			SYSTEMTIME st{};
			GetLocalTime(&st);

			char timeBuf[64];
			snprintf(timeBuf, sizeof(timeBuf), "%02d:%02d:%02d.%03d",
				st.wHour, st.wMinute, st.wSecond, st.wMilliseconds);

			// Thread ID
			DWORD tid = GetCurrentThreadId();

			// Format the user message
			char messageBuf[4096];
			vsnprintf(messageBuf, sizeof(messageBuf), fmt, args);

			// Assemble final line
			char lineBuf[4400];
			snprintf(lineBuf, sizeof(lineBuf), "[%s] [%-5s] [T:%05lu] %s\n",
				timeBuf, levelStr, tid, messageBuf);

			if (g_file && g_enableFile)
			{
				fputs(lineBuf, g_file);
				fflush(g_file);
			}

#ifdef _DEBUG
			if (HasLogCommandLineParam())
			{
				printf("%s", lineBuf);
			}
#endif

			OutputDebugStringA(lineBuf);

			// Forward Info/Warn/Error to the game's own log (StarRupture.log).
			// Trace and Debug are intentionally excluded to avoid flooding it.
			// UELog::Write() is internally guarded so this is a no-op until
			// UELog::Initialize() has been called from the EngineInit callback.
			if (level >= Level::Info)
			{
				UELog::ELogVerbosity ueVerbosity;
				switch (level)
				{
				case Level::Warn:  ueVerbosity = UELog::ELogVerbosity::Warning; break;
				case Level::Error: ueVerbosity = UELog::ELogVerbosity::Error;   break;
				default:           ueVerbosity = UELog::ELogVerbosity::Log;     break;
				}
				UELog::Write(ueVerbosity, messageBuf);
			}
		}
		__finally
		{
			// Always release the lock, even if an exception occurs
			LeaveCriticalSection(&g_logLock);
		}
	}

	// -----------------------------------------------------------------------
	// Level-specific entry points
	// -----------------------------------------------------------------------

	inline void Trace(const char* fmt, ...)
	{
		va_list args; va_start(args, fmt);
		Write(Level::Trace, "TRACE", fmt, args);
		va_end(args);
	}

	inline void Debug(const char* fmt, ...)
	{
		va_list args; va_start(args, fmt);
		Write(Level::Debug, "DEBUG", fmt, args);
		va_end(args);
	}

	inline void Info(const char* fmt, ...)
	{
		va_list args; va_start(args, fmt);
		Write(Level::Info, "INFO", fmt, args);
		va_end(args);
	}

	inline void Warn(const char* fmt, ...)
	{
		va_list args; va_start(args, fmt);
		Write(Level::Warn, "WARN", fmt, args);
		va_end(args);
	}

	inline void Error(const char* fmt, ...)
	{
		va_list args; va_start(args, fmt);
		Write(Level::Error, "ERROR", fmt, args);
		va_end(args);
	}

	// -----------------------------------------------------------------------
	// Utility: hex dump a block of memory (great for debugging byte patterns)
	// -----------------------------------------------------------------------

	inline void HexDump(Level level, const char* label, const void* data, size_t size)
	{
		if (level < g_minLevel || !data || size == 0)
			return;

		const char* levelStr = "DEBUG";
		switch (level)
		{
		case Level::Trace: levelStr = "TRACE"; break;
		case Level::Debug: levelStr = "DEBUG"; break;
		case Level::Info:  levelStr = "INFO";  break;
		case Level::Warn:  levelStr = "WARN";  break;
		case Level::Error: levelStr = "ERROR"; break;
		}

		// Header line via the normal Write path (we'll build a va_list-less variant)
		Info("--- HexDump: %s (%zu bytes) ---", label, size);

		const auto* bytes = static_cast<const uint8_t*>(data);
		char line[128];

		for (size_t offset = 0; offset < size; offset += 16)
		{
			int pos = snprintf(line, sizeof(line), "  %04zX: ", offset);

			// Hex bytes
			for (size_t i = 0; i < 16; ++i)
			{
				if (offset + i < size)
					pos += snprintf(line + pos, sizeof(line) - pos, "%02X ", bytes[offset + i]);
				else
					pos += snprintf(line + pos, sizeof(line) - pos, "   ");

				if (i == 7)
					pos += snprintf(line + pos, sizeof(line) - pos, " ");
			}

			// ASCII
			pos += snprintf(line + pos, sizeof(line) - pos, " |");
			for (size_t i = 0; i < 16 && offset + i < size; ++i)
			{
				uint8_t c = bytes[offset + i];
				pos += snprintf(line + pos, sizeof(line) - pos, "%c",
					(c >= 0x20 && c <= 0x7E) ? c : '.');
			}
			snprintf(line + pos, sizeof(line) - pos, "|");

			// Write via a dummy va_list
			if (g_file) { fprintf(g_file, "[HEX  ] %s\n", line); fflush(g_file); }
#ifdef _DEBUG
			printf("[HEX  ] %s\n", line);
#endif
			char dbg[256];
			snprintf(dbg, sizeof(dbg), "[HEX  ] %s\n", line);
			OutputDebugStringA(dbg);
		}
	}

	// Convenience overloads at common levels
	inline void HexDumpDebug(const char* label, const void* data, size_t size)
	{
		HexDump(Level::Debug, label, data, size);
	}

	inline void HexDumpTrace(const char* label, const void* data, size_t size)
	{
		HexDump(Level::Trace, label, data, size);
	}

	// -----------------------------------------------------------------------
	// Utility: dump a formatted address + RVA relative to a module base
	// -----------------------------------------------------------------------

	inline void LogAddress(const char* label, uintptr_t address, uintptr_t base = 0)
	{
		if (base)
			Debug("%s: 0x%llX (base+0x%llX)",
				label,
				static_cast<unsigned long long>(address),
				static_cast<unsigned long long>(address - base));
		else
			Debug("%s: 0x%llX", label, static_cast<unsigned long long>(address));
	}

	// -----------------------------------------------------------------------
	// Utility: log the last Win32 error with context
	// -----------------------------------------------------------------------

	inline void LogWin32Error(const char* context)
	{
		DWORD err = GetLastError();
		char* msgBuf = nullptr;
		FormatMessageA(
			FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
			nullptr, err, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			reinterpret_cast<LPSTR>(&msgBuf), 0, nullptr);

		Error("%s: Win32 error %lu: %s", context, err, msgBuf ? msgBuf : "(unknown)");

		if (msgBuf)
			LocalFree(msgBuf);
	}
}
